import {
  __commonJS
} from "./chunk-5AQFBOJN.js";

// node_modules/vis/dist/vis.js
var require_vis = __commonJS({
  "node_modules/vis/dist/vis.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["vis"] = factory();
      else
        root["vis"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 123);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            exports2.default = function(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            };
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _defineProperty = __webpack_require__(169);
            var _defineProperty2 = _interopRequireDefault(_defineProperty);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = /* @__PURE__ */ function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor) descriptor.writable = true;
                  (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _getIterator2 = __webpack_require__(77);
            var _getIterator3 = _interopRequireDefault(_getIterator2);
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var moment = __webpack_require__(9);
            var uuid = __webpack_require__(157);
            exports2.isNumber = function(object) {
              return object instanceof Number || typeof object == "number";
            };
            exports2.recursiveDOMDelete = function(DOMobject) {
              if (DOMobject) {
                while (DOMobject.hasChildNodes() === true) {
                  exports2.recursiveDOMDelete(DOMobject.firstChild);
                  DOMobject.removeChild(DOMobject.firstChild);
                }
              }
            };
            exports2.giveRange = function(min, max, total, value) {
              if (max == min) {
                return 0.5;
              } else {
                var scale = 1 / (max - min);
                return Math.max(0, (value - min) * scale);
              }
            };
            exports2.isString = function(object) {
              return object instanceof String || typeof object == "string";
            };
            exports2.isDate = function(object) {
              if (object instanceof Date) {
                return true;
              } else if (exports2.isString(object)) {
                var match = ASPDateRegex.exec(object);
                if (match) {
                  return true;
                } else if (!isNaN(Date.parse(object))) {
                  return true;
                }
              }
              return false;
            };
            exports2.randomUUID = function() {
              return uuid.v4();
            };
            exports2.assignAllKeys = function(obj, value) {
              for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                  if ((0, _typeof3["default"])(obj[prop]) !== "object") {
                    obj[prop] = value;
                  }
                }
              }
            };
            function copyOrDelete(a, b, prop, allowDeletion) {
              var doDeletion = false;
              if (allowDeletion === true) {
                doDeletion = b[prop] === null && a[prop] !== void 0;
              }
              if (doDeletion) {
                delete a[prop];
              } else {
                a[prop] = b[prop];
              }
            }
            exports2.fillIfDefined = function(a, b) {
              var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              for (var prop in a) {
                if (b[prop] !== void 0) {
                  if (b[prop] === null || (0, _typeof3["default"])(b[prop]) !== "object") {
                    copyOrDelete(a, b, prop, allowDeletion);
                  } else {
                    if ((0, _typeof3["default"])(a[prop]) === "object") {
                      exports2.fillIfDefined(a[prop], b[prop], allowDeletion);
                    }
                  }
                }
              }
            };
            exports2.extend = function(a, b) {
              for (var i = 1; i < arguments.length; i++) {
                var other = arguments[i];
                for (var prop in other) {
                  if (other.hasOwnProperty(prop)) {
                    a[prop] = other[prop];
                  }
                }
              }
              return a;
            };
            exports2.selectiveExtend = function(props, a, b) {
              if (!Array.isArray(props)) {
                throw new Error("Array with property names expected as first argument");
              }
              for (var i = 2; i < arguments.length; i++) {
                var other = arguments[i];
                for (var p = 0; p < props.length; p++) {
                  var prop = props[p];
                  if (other && other.hasOwnProperty(prop)) {
                    a[prop] = other[prop];
                  }
                }
              }
              return a;
            };
            exports2.selectiveDeepExtend = function(props, a, b) {
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              if (Array.isArray(b)) {
                throw new TypeError("Arrays are not supported by deepExtend");
              }
              for (var p = 0; p < props.length; p++) {
                var prop = props[p];
                if (b.hasOwnProperty(prop)) {
                  if (b[prop] && b[prop].constructor === Object) {
                    if (a[prop] === void 0) {
                      a[prop] = {};
                    }
                    if (a[prop].constructor === Object) {
                      exports2.deepExtend(a[prop], b[prop], false, allowDeletion);
                    } else {
                      copyOrDelete(a, b, prop, allowDeletion);
                    }
                  } else if (Array.isArray(b[prop])) {
                    throw new TypeError("Arrays are not supported by deepExtend");
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                }
              }
              return a;
            };
            exports2.selectiveNotDeepExtend = function(propsToExclude, a, b) {
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              if (Array.isArray(b)) {
                throw new TypeError("Arrays are not supported by deepExtend");
              }
              for (var prop in b) {
                if (!b.hasOwnProperty(prop)) continue;
                if (propsToExclude.indexOf(prop) !== -1) continue;
                if (b[prop] && b[prop].constructor === Object) {
                  if (a[prop] === void 0) {
                    a[prop] = {};
                  }
                  if (a[prop].constructor === Object) {
                    exports2.deepExtend(a[prop], b[prop]);
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                } else if (Array.isArray(b[prop])) {
                  a[prop] = [];
                  for (var i = 0; i < b[prop].length; i++) {
                    a[prop].push(b[prop][i]);
                  }
                } else {
                  copyOrDelete(a, b, prop, allowDeletion);
                }
              }
              return a;
            };
            exports2.deepExtend = function(a, b) {
              var protoExtend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var allowDeletion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              for (var prop in b) {
                if (b.hasOwnProperty(prop) || protoExtend === true) {
                  if (b[prop] && b[prop].constructor === Object) {
                    if (a[prop] === void 0) {
                      a[prop] = {};
                    }
                    if (a[prop].constructor === Object) {
                      exports2.deepExtend(a[prop], b[prop], protoExtend);
                    } else {
                      copyOrDelete(a, b, prop, allowDeletion);
                    }
                  } else if (Array.isArray(b[prop])) {
                    a[prop] = [];
                    for (var i = 0; i < b[prop].length; i++) {
                      a[prop].push(b[prop][i]);
                    }
                  } else {
                    copyOrDelete(a, b, prop, allowDeletion);
                  }
                }
              }
              return a;
            };
            exports2.equalArray = function(a, b) {
              if (a.length != b.length) return false;
              for (var i = 0, len = a.length; i < len; i++) {
                if (a[i] != b[i]) return false;
              }
              return true;
            };
            exports2.convert = function(object, type) {
              var match;
              if (object === void 0) {
                return void 0;
              }
              if (object === null) {
                return null;
              }
              if (!type) {
                return object;
              }
              if (!(typeof type === "string") && !(type instanceof String)) {
                throw new Error("Type must be a string");
              }
              switch (type) {
                case "boolean":
                case "Boolean":
                  return Boolean(object);
                case "number":
                case "Number":
                  if (exports2.isString(object) && !isNaN(Date.parse(object))) {
                    return moment(object).valueOf();
                  } else {
                    return Number(object.valueOf());
                  }
                case "string":
                case "String":
                  return String(object);
                case "Date":
                  if (exports2.isNumber(object)) {
                    return new Date(object);
                  }
                  if (object instanceof Date) {
                    return new Date(object.valueOf());
                  } else if (moment.isMoment(object)) {
                    return new Date(object.valueOf());
                  }
                  if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return new Date(Number(match[1]));
                    } else {
                      return moment(new Date(object)).toDate();
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type Date");
                  }
                case "Moment":
                  if (exports2.isNumber(object)) {
                    return moment(object);
                  }
                  if (object instanceof Date) {
                    return moment(object.valueOf());
                  } else if (moment.isMoment(object)) {
                    return moment(object);
                  }
                  if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return moment(Number(match[1]));
                    } else {
                      return moment(object);
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type Date");
                  }
                case "ISODate":
                  if (exports2.isNumber(object)) {
                    return new Date(object);
                  } else if (object instanceof Date) {
                    return object.toISOString();
                  } else if (moment.isMoment(object)) {
                    return object.toDate().toISOString();
                  } else if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    if (match) {
                      return new Date(Number(match[1])).toISOString();
                    } else {
                      return moment(object).format();
                    }
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type ISODate");
                  }
                case "ASPDate":
                  if (exports2.isNumber(object)) {
                    return "/Date(" + object + ")/";
                  } else if (object instanceof Date) {
                    return "/Date(" + object.valueOf() + ")/";
                  } else if (exports2.isString(object)) {
                    match = ASPDateRegex.exec(object);
                    var value;
                    if (match) {
                      value = new Date(Number(match[1])).valueOf();
                    } else {
                      value = new Date(object).valueOf();
                    }
                    return "/Date(" + value + ")/";
                  } else {
                    throw new Error("Cannot convert object of type " + exports2.getType(object) + " to type ASPDate");
                  }
                default:
                  throw new Error('Unknown type "' + type + '"');
              }
            };
            var ASPDateRegex = /^\/?Date\((\-?\d+)/i;
            exports2.getType = function(object) {
              var type = typeof object === "undefined" ? "undefined" : (0, _typeof3["default"])(object);
              if (type == "object") {
                if (object === null) {
                  return "null";
                }
                if (object instanceof Boolean) {
                  return "Boolean";
                }
                if (object instanceof Number) {
                  return "Number";
                }
                if (object instanceof String) {
                  return "String";
                }
                if (Array.isArray(object)) {
                  return "Array";
                }
                if (object instanceof Date) {
                  return "Date";
                }
                return "Object";
              } else if (type == "number") {
                return "Number";
              } else if (type == "boolean") {
                return "Boolean";
              } else if (type == "string") {
                return "String";
              } else if (type === void 0) {
                return "undefined";
              }
              return type;
            };
            exports2.copyAndExtendArray = function(arr, newValue) {
              var newArr = [];
              for (var i = 0; i < arr.length; i++) {
                newArr.push(arr[i]);
              }
              newArr.push(newValue);
              return newArr;
            };
            exports2.copyArray = function(arr) {
              var newArr = [];
              for (var i = 0; i < arr.length; i++) {
                newArr.push(arr[i]);
              }
              return newArr;
            };
            exports2.getAbsoluteLeft = function(elem) {
              return elem.getBoundingClientRect().left;
            };
            exports2.getAbsoluteRight = function(elem) {
              return elem.getBoundingClientRect().right;
            };
            exports2.getAbsoluteTop = function(elem) {
              return elem.getBoundingClientRect().top;
            };
            exports2.addClassName = function(elem, classNames) {
              var classes = elem.className.split(" ");
              var newClasses = classNames.split(" ");
              classes = classes.concat(newClasses.filter(function(className) {
                return classes.indexOf(className) < 0;
              }));
              elem.className = classes.join(" ");
            };
            exports2.removeClassName = function(elem, classNames) {
              var classes = elem.className.split(" ");
              var oldClasses = classNames.split(" ");
              classes = classes.filter(function(className) {
                return oldClasses.indexOf(className) < 0;
              });
              elem.className = classes.join(" ");
            };
            exports2.forEach = function(object, callback) {
              var i, len;
              if (Array.isArray(object)) {
                for (i = 0, len = object.length; i < len; i++) {
                  callback(object[i], i, object);
                }
              } else {
                for (i in object) {
                  if (object.hasOwnProperty(i)) {
                    callback(object[i], i, object);
                  }
                }
              }
            };
            exports2.toArray = function(object) {
              var array = [];
              for (var prop in object) {
                if (object.hasOwnProperty(prop)) array.push(object[prop]);
              }
              return array;
            };
            exports2.updateProperty = function(object, key, value) {
              if (object[key] !== value) {
                object[key] = value;
                return true;
              } else {
                return false;
              }
            };
            exports2.throttle = function(fn) {
              var scheduled = false;
              return function throttled() {
                if (!scheduled) {
                  scheduled = true;
                  requestAnimationFrame(function() {
                    scheduled = false;
                    fn();
                  });
                }
              };
            };
            exports2.addEventListener = function(element, action, listener, useCapture) {
              if (element.addEventListener) {
                if (useCapture === void 0) useCapture = false;
                if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
                  action = "DOMMouseScroll";
                }
                element.addEventListener(action, listener, useCapture);
              } else {
                element.attachEvent("on" + action, listener);
              }
            };
            exports2.removeEventListener = function(element, action, listener, useCapture) {
              if (element.removeEventListener) {
                if (useCapture === void 0) useCapture = false;
                if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
                  action = "DOMMouseScroll";
                }
                element.removeEventListener(action, listener, useCapture);
              } else {
                element.detachEvent("on" + action, listener);
              }
            };
            exports2.preventDefault = function(event) {
              if (!event) event = window.event;
              if (event.preventDefault) {
                event.preventDefault();
              } else {
                event.returnValue = false;
              }
            };
            exports2.getTarget = function(event) {
              if (!event) {
                event = window.event;
              }
              var target;
              if (event.target) {
                target = event.target;
              } else if (event.srcElement) {
                target = event.srcElement;
              }
              if (target.nodeType != void 0 && target.nodeType == 3) {
                target = target.parentNode;
              }
              return target;
            };
            exports2.hasParent = function(element, parent) {
              var e = element;
              while (e) {
                if (e === parent) {
                  return true;
                }
                e = e.parentNode;
              }
              return false;
            };
            exports2.option = {};
            exports2.option.asBoolean = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return value != false;
              }
              return defaultValue || null;
            };
            exports2.option.asNumber = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return Number(value) || defaultValue || null;
              }
              return defaultValue || null;
            };
            exports2.option.asString = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (value != null) {
                return String(value);
              }
              return defaultValue || null;
            };
            exports2.option.asSize = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              if (exports2.isString(value)) {
                return value;
              } else if (exports2.isNumber(value)) {
                return value + "px";
              } else {
                return defaultValue || null;
              }
            };
            exports2.option.asElement = function(value, defaultValue) {
              if (typeof value == "function") {
                value = value();
              }
              return value || defaultValue || null;
            };
            exports2.hexToRGB = function(hex) {
              var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
              hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                return r + r + g + g + b + b;
              });
              var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
              } : null;
            };
            exports2.overrideOpacity = function(color, opacity) {
              var rgb;
              if (color.indexOf("rgba") != -1) {
                return color;
              } else if (color.indexOf("rgb") != -1) {
                rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
                return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
              } else {
                rgb = exports2.hexToRGB(color);
                if (rgb == null) {
                  return color;
                } else {
                  return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
                }
              }
            };
            exports2.RGBToHex = function(red, green, blue) {
              return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
            };
            exports2.parseColor = function(color) {
              var c;
              if (exports2.isString(color) === true) {
                if (exports2.isValidRGB(color) === true) {
                  var rgb = color.substr(4).substr(0, color.length - 5).split(",").map(function(value) {
                    return parseInt(value);
                  });
                  color = exports2.RGBToHex(rgb[0], rgb[1], rgb[2]);
                }
                if (exports2.isValidHex(color) === true) {
                  var hsv = exports2.hexToHSV(color);
                  var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
                  var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
                  var darkerColorHex = exports2.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
                  var lighterColorHex = exports2.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
                  c = {
                    background: color,
                    border: darkerColorHex,
                    highlight: {
                      background: lighterColorHex,
                      border: darkerColorHex
                    },
                    hover: {
                      background: lighterColorHex,
                      border: darkerColorHex
                    }
                  };
                } else {
                  c = {
                    background: color,
                    border: color,
                    highlight: {
                      background: color,
                      border: color
                    },
                    hover: {
                      background: color,
                      border: color
                    }
                  };
                }
              } else {
                c = {};
                c.background = color.background || void 0;
                c.border = color.border || void 0;
                if (exports2.isString(color.highlight)) {
                  c.highlight = {
                    border: color.highlight,
                    background: color.highlight
                  };
                } else {
                  c.highlight = {};
                  c.highlight.background = color.highlight && color.highlight.background || void 0;
                  c.highlight.border = color.highlight && color.highlight.border || void 0;
                }
                if (exports2.isString(color.hover)) {
                  c.hover = {
                    border: color.hover,
                    background: color.hover
                  };
                } else {
                  c.hover = {};
                  c.hover.background = color.hover && color.hover.background || void 0;
                  c.hover.border = color.hover && color.hover.border || void 0;
                }
              }
              return c;
            };
            exports2.RGBToHSV = function(red, green, blue) {
              red = red / 255;
              green = green / 255;
              blue = blue / 255;
              var minRGB = Math.min(red, Math.min(green, blue));
              var maxRGB = Math.max(red, Math.max(green, blue));
              if (minRGB == maxRGB) {
                return { h: 0, s: 0, v: minRGB };
              }
              var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
              var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
              var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
              var saturation = (maxRGB - minRGB) / maxRGB;
              var value = maxRGB;
              return { h: hue, s: saturation, v: value };
            };
            var cssUtil = {
              // split a string with css styles into an object with key/values
              split: function split(cssText) {
                var styles = {};
                cssText.split(";").forEach(function(style) {
                  if (style.trim() != "") {
                    var parts = style.split(":");
                    var key = parts[0].trim();
                    var value = parts[1].trim();
                    styles[key] = value;
                  }
                });
                return styles;
              },
              // build a css text string from an object with key/values
              join: function join(styles) {
                return (0, _keys2["default"])(styles).map(function(key) {
                  return key + ": " + styles[key];
                }).join("; ");
              }
            };
            exports2.addCssText = function(element, cssText) {
              var currentStyles = cssUtil.split(element.style.cssText);
              var newStyles = cssUtil.split(cssText);
              var styles = exports2.extend(currentStyles, newStyles);
              element.style.cssText = cssUtil.join(styles);
            };
            exports2.removeCssText = function(element, cssText) {
              var styles = cssUtil.split(element.style.cssText);
              var removeStyles = cssUtil.split(cssText);
              for (var key in removeStyles) {
                if (removeStyles.hasOwnProperty(key)) {
                  delete styles[key];
                }
              }
              element.style.cssText = cssUtil.join(styles);
            };
            exports2.HSVToRGB = function(h, s, v) {
              var r, g, b;
              var i = Math.floor(h * 6);
              var f = h * 6 - i;
              var p = v * (1 - s);
              var q = v * (1 - f * s);
              var t = v * (1 - (1 - f) * s);
              switch (i % 6) {
                case 0:
                  r = v, g = t, b = p;
                  break;
                case 1:
                  r = q, g = v, b = p;
                  break;
                case 2:
                  r = p, g = v, b = t;
                  break;
                case 3:
                  r = p, g = q, b = v;
                  break;
                case 4:
                  r = t, g = p, b = v;
                  break;
                case 5:
                  r = v, g = p, b = q;
                  break;
              }
              return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
            };
            exports2.HSVToHex = function(h, s, v) {
              var rgb = exports2.HSVToRGB(h, s, v);
              return exports2.RGBToHex(rgb.r, rgb.g, rgb.b);
            };
            exports2.hexToHSV = function(hex) {
              var rgb = exports2.hexToRGB(hex);
              return exports2.RGBToHSV(rgb.r, rgb.g, rgb.b);
            };
            exports2.isValidHex = function(hex) {
              var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
              return isOk;
            };
            exports2.isValidRGB = function(rgb) {
              rgb = rgb.replace(" ", "");
              var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
              return isOk;
            };
            exports2.isValidRGBA = function(rgba) {
              rgba = rgba.replace(" ", "");
              var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
              return isOk;
            };
            exports2.selectiveBridgeObject = function(fields, referenceObject) {
              if (referenceObject !== null && (typeof referenceObject === "undefined" ? "undefined" : (0, _typeof3["default"])(referenceObject)) === "object") {
                var objectTo = (0, _create2["default"])(referenceObject);
                for (var i = 0; i < fields.length; i++) {
                  if (referenceObject.hasOwnProperty(fields[i])) {
                    if ((0, _typeof3["default"])(referenceObject[fields[i]]) == "object") {
                      objectTo[fields[i]] = exports2.bridgeObject(referenceObject[fields[i]]);
                    }
                  }
                }
                return objectTo;
              } else {
                return null;
              }
            };
            exports2.bridgeObject = function(referenceObject) {
              if (referenceObject !== null && (typeof referenceObject === "undefined" ? "undefined" : (0, _typeof3["default"])(referenceObject)) === "object") {
                var objectTo = (0, _create2["default"])(referenceObject);
                if (referenceObject instanceof Element) {
                  objectTo = referenceObject;
                } else {
                  objectTo = (0, _create2["default"])(referenceObject);
                  for (var i in referenceObject) {
                    if (referenceObject.hasOwnProperty(i)) {
                      if ((0, _typeof3["default"])(referenceObject[i]) == "object") {
                        objectTo[i] = exports2.bridgeObject(referenceObject[i]);
                      }
                    }
                  }
                }
                return objectTo;
              } else {
                return null;
              }
            };
            exports2.insertSort = function(a, compare) {
              for (var i = 0; i < a.length; i++) {
                var k = a[i];
                for (var j = i; j > 0 && compare(k, a[j - 1]) < 0; j--) {
                  a[j] = a[j - 1];
                }
                a[j] = k;
              }
              return a;
            };
            exports2.mergeOptions = function(mergeTarget, options, option) {
              var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              var isPresent = function isPresent2(obj) {
                return obj !== null && obj !== void 0;
              };
              var isObject = function isObject2(obj) {
                return obj !== null && (typeof obj === "undefined" ? "undefined" : (0, _typeof3["default"])(obj)) === "object";
              };
              var isEmpty = function isEmpty2(obj) {
                for (var x in obj) {
                  if (obj.hasOwnProperty(x)) return false;
                }
                return true;
              };
              if (!isObject(mergeTarget)) {
                throw new Error("Parameter mergeTarget must be an object");
              }
              if (!isObject(options)) {
                throw new Error("Parameter options must be an object");
              }
              if (!isPresent(option)) {
                throw new Error("Parameter option must have a value");
              }
              if (!isObject(globalOptions)) {
                throw new Error("Parameter globalOptions must be an object");
              }
              var doMerge = function doMerge2(target, options2, option2) {
                if (!isObject(target[option2])) {
                  target[option2] = {};
                }
                var src = options2[option2];
                var dst = target[option2];
                for (var prop in src) {
                  if (src.hasOwnProperty(prop)) {
                    dst[prop] = src[prop];
                  }
                }
              };
              var srcOption = options[option];
              var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);
              var globalOption = globalPassed ? globalOptions[option] : void 0;
              var globalEnabled = globalOption ? globalOption.enabled : void 0;
              if (srcOption === void 0) {
                return;
              }
              if (typeof srcOption === "boolean") {
                if (!isObject(mergeTarget[option])) {
                  mergeTarget[option] = {};
                }
                mergeTarget[option].enabled = srcOption;
                return;
              }
              if (srcOption === null && !isObject(mergeTarget[option])) {
                if (isPresent(globalOption)) {
                  mergeTarget[option] = (0, _create2["default"])(globalOption);
                } else {
                  return;
                }
              }
              if (!isObject(srcOption)) {
                return;
              }
              var enabled = true;
              if (srcOption.enabled !== void 0) {
                enabled = srcOption.enabled;
              } else {
                if (globalEnabled !== void 0) {
                  enabled = globalOption.enabled;
                }
              }
              doMerge(mergeTarget, options, option);
              mergeTarget[option].enabled = enabled;
            };
            exports2.binarySearchCustom = function(orderedItems, comparator, field, field2) {
              var maxIterations = 1e4;
              var iteration = 0;
              var low = 0;
              var high = orderedItems.length - 1;
              while (low <= high && iteration < maxIterations) {
                var middle = Math.floor((low + high) / 2);
                var item = orderedItems[middle];
                var value = field2 === void 0 ? item[field] : item[field][field2];
                var searchResult = comparator(value);
                if (searchResult == 0) {
                  return middle;
                } else if (searchResult == -1) {
                  low = middle + 1;
                } else {
                  high = middle - 1;
                }
                iteration++;
              }
              return -1;
            };
            exports2.binarySearchValue = function(orderedItems, target, field, sidePreference, comparator) {
              var maxIterations = 1e4;
              var iteration = 0;
              var low = 0;
              var high = orderedItems.length - 1;
              var prevValue, value, nextValue, middle;
              comparator = comparator != void 0 ? comparator : function(a, b) {
                return a == b ? 0 : a < b ? -1 : 1;
              };
              while (low <= high && iteration < maxIterations) {
                middle = Math.floor(0.5 * (high + low));
                prevValue = orderedItems[Math.max(0, middle - 1)][field];
                value = orderedItems[middle][field];
                nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];
                if (comparator(value, target) == 0) {
                  return middle;
                } else if (comparator(prevValue, target) < 0 && comparator(value, target) > 0) {
                  return sidePreference == "before" ? Math.max(0, middle - 1) : middle;
                } else if (comparator(value, target) < 0 && comparator(nextValue, target) > 0) {
                  return sidePreference == "before" ? middle : Math.min(orderedItems.length - 1, middle + 1);
                } else {
                  if (comparator(value, target) < 0) {
                    low = middle + 1;
                  } else {
                    high = middle - 1;
                  }
                }
                iteration++;
              }
              return -1;
            };
            exports2.easingFunctions = {
              // no easing, no acceleration
              linear: function linear(t) {
                return t;
              },
              // accelerating from zero velocity
              easeInQuad: function easeInQuad(t) {
                return t * t;
              },
              // decelerating to zero velocity
              easeOutQuad: function easeOutQuad(t) {
                return t * (2 - t);
              },
              // acceleration until halfway, then deceleration
              easeInOutQuad: function easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
              },
              // accelerating from zero velocity
              easeInCubic: function easeInCubic(t) {
                return t * t * t;
              },
              // decelerating to zero velocity
              easeOutCubic: function easeOutCubic(t) {
                return --t * t * t + 1;
              },
              // acceleration until halfway, then deceleration
              easeInOutCubic: function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
              },
              // accelerating from zero velocity
              easeInQuart: function easeInQuart(t) {
                return t * t * t * t;
              },
              // decelerating to zero velocity
              easeOutQuart: function easeOutQuart(t) {
                return 1 - --t * t * t * t;
              },
              // acceleration until halfway, then deceleration
              easeInOutQuart: function easeInOutQuart(t) {
                return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
              },
              // accelerating from zero velocity
              easeInQuint: function easeInQuint(t) {
                return t * t * t * t * t;
              },
              // decelerating to zero velocity
              easeOutQuint: function easeOutQuint(t) {
                return 1 + --t * t * t * t * t;
              },
              // acceleration until halfway, then deceleration
              easeInOutQuint: function easeInOutQuint(t) {
                return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
              }
            };
            exports2.getScrollBarWidth = function() {
              var inner = document.createElement("p");
              inner.style.width = "100%";
              inner.style.height = "200px";
              var outer = document.createElement("div");
              outer.style.position = "absolute";
              outer.style.top = "0px";
              outer.style.left = "0px";
              outer.style.visibility = "hidden";
              outer.style.width = "200px";
              outer.style.height = "150px";
              outer.style.overflow = "hidden";
              outer.appendChild(inner);
              document.body.appendChild(outer);
              var w1 = inner.offsetWidth;
              outer.style.overflow = "scroll";
              var w2 = inner.offsetWidth;
              if (w1 == w2) w2 = outer.clientWidth;
              document.body.removeChild(outer);
              return w1 - w2;
            };
            exports2.topMost = function(pile, accessors) {
              var candidate = void 0;
              if (!Array.isArray(accessors)) {
                accessors = [accessors];
              }
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = void 0;
              try {
                for (var _iterator = (0, _getIterator3["default"])(pile), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var member = _step.value;
                  if (member) {
                    candidate = member[accessors[0]];
                    for (var i = 1; i < accessors.length; i++) {
                      if (candidate) {
                        candidate = candidate[accessors[i]];
                      } else {
                        continue;
                      }
                    }
                    if (typeof candidate != "undefined") {
                      break;
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
              return candidate;
            };
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(194), __esModule: true };
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function(self2, call) {
              if (!self2) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self2;
            };
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _setPrototypeOf = __webpack_require__(196);
            var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = function(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
              }
              subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
            };
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _iterator = __webpack_require__(142);
            var _iterator2 = _interopRequireDefault(_iterator);
            var _symbol = __webpack_require__(144);
            var _symbol2 = _interopRequireDefault(_symbol);
            var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
            };
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function(obj) {
              return typeof obj === "undefined" ? "undefined" : _typeof(obj);
            } : function(obj) {
              return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
            };
          },
          /* 7 */
          /***/
          function(module2, exports2) {
            var core = module2.exports = { version: "2.5.1" };
            if (typeof __e == "number") __e = core;
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(140), __esModule: true };
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            module2.exports = typeof window !== "undefined" && window["moment"] || __webpack_require__(154);
          },
          /* 10 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function hammerMock() {
              var noop = function noop2() {
              };
              return {
                on: noop,
                off: noop,
                destroy: noop,
                emit: noop,
                get: function get(m) {
                  return {
                    set: noop
                  };
                }
              };
            }
            if (typeof window !== "undefined") {
              var propagating = __webpack_require__(175);
              var Hammer = window["Hammer"] || __webpack_require__(176);
              module2.exports = propagating(Hammer, {
                preventDefault: "mouse"
              });
            } else {
              module2.exports = function() {
                return hammerMock();
              };
            }
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Queue = __webpack_require__(43);
            function DataSet(data, options) {
              if (data && !Array.isArray(data)) {
                options = data;
                data = null;
              }
              this._options = options || {};
              this._data = {};
              this.length = 0;
              this._fieldId = this._options.fieldId || "id";
              this._type = {};
              if (this._options.type) {
                var fields = (0, _keys2["default"])(this._options.type);
                for (var i = 0, len = fields.length; i < len; i++) {
                  var field = fields[i];
                  var value = this._options.type[field];
                  if (value == "Date" || value == "ISODate" || value == "ASPDate") {
                    this._type[field] = "Date";
                  } else {
                    this._type[field] = value;
                  }
                }
              }
              this._subscribers = {};
              if (data) {
                this.add(data);
              }
              this.setOptions(options);
            }
            DataSet.prototype.setOptions = function(options) {
              if (options && options.queue !== void 0) {
                if (options.queue === false) {
                  if (this._queue) {
                    this._queue.destroy();
                    delete this._queue;
                  }
                } else {
                  if (!this._queue) {
                    this._queue = Queue.extend(this, {
                      replace: ["add", "update", "remove"]
                    });
                  }
                  if ((0, _typeof3["default"])(options.queue) === "object") {
                    this._queue.setOptions(options.queue);
                  }
                }
              }
            };
            DataSet.prototype.on = function(event, callback) {
              var subscribers = this._subscribers[event];
              if (!subscribers) {
                subscribers = [];
                this._subscribers[event] = subscribers;
              }
              subscribers.push({
                callback
              });
            };
            DataSet.prototype.off = function(event, callback) {
              var subscribers = this._subscribers[event];
              if (subscribers) {
                this._subscribers[event] = subscribers.filter(function(listener) {
                  return listener.callback != callback;
                });
              }
            };
            DataSet.prototype._trigger = function(event, params, senderId) {
              if (event == "*") {
                throw new Error("Cannot trigger event *");
              }
              var subscribers = [];
              if (event in this._subscribers) {
                subscribers = subscribers.concat(this._subscribers[event]);
              }
              if ("*" in this._subscribers) {
                subscribers = subscribers.concat(this._subscribers["*"]);
              }
              for (var i = 0, len = subscribers.length; i < len; i++) {
                var subscriber = subscribers[i];
                if (subscriber.callback) {
                  subscriber.callback(event, params, senderId || null);
                }
              }
            };
            DataSet.prototype.add = function(data, senderId) {
              var addedIds = [], id, me = this;
              if (Array.isArray(data)) {
                for (var i = 0, len = data.length; i < len; i++) {
                  id = me._addItem(data[i]);
                  addedIds.push(id);
                }
              } else if (data && (typeof data === "undefined" ? "undefined" : (0, _typeof3["default"])(data)) === "object") {
                id = me._addItem(data);
                addedIds.push(id);
              } else {
                throw new Error("Unknown dataType");
              }
              if (addedIds.length) {
                this._trigger("add", { items: addedIds }, senderId);
              }
              return addedIds;
            };
            DataSet.prototype.update = function(data, senderId) {
              var addedIds = [];
              var updatedIds = [];
              var oldData = [];
              var updatedData = [];
              var me = this;
              var fieldId = me._fieldId;
              var addOrUpdate = function addOrUpdate2(item) {
                var id = item[fieldId];
                if (me._data[id]) {
                  var oldItem = util.extend({}, me._data[id]);
                  id = me._updateItem(item);
                  updatedIds.push(id);
                  updatedData.push(item);
                  oldData.push(oldItem);
                } else {
                  id = me._addItem(item);
                  addedIds.push(id);
                }
              };
              if (Array.isArray(data)) {
                for (var i = 0, len = data.length; i < len; i++) {
                  if (data[i] && (0, _typeof3["default"])(data[i]) === "object") {
                    addOrUpdate(data[i]);
                  } else {
                    console.warn("Ignoring input item, which is not an object at index " + i);
                  }
                }
              } else if (data && (typeof data === "undefined" ? "undefined" : (0, _typeof3["default"])(data)) === "object") {
                addOrUpdate(data);
              } else {
                throw new Error("Unknown dataType");
              }
              if (addedIds.length) {
                this._trigger("add", { items: addedIds }, senderId);
              }
              if (updatedIds.length) {
                var props = { items: updatedIds, oldData, data: updatedData };
                this._trigger("update", props, senderId);
              }
              return addedIds.concat(updatedIds);
            };
            DataSet.prototype.get = function(args) {
              var me = this;
              var id, ids, options;
              var firstType = util.getType(arguments[0]);
              if (firstType == "String" || firstType == "Number") {
                id = arguments[0];
                options = arguments[1];
              } else if (firstType == "Array") {
                ids = arguments[0];
                options = arguments[1];
              } else {
                options = arguments[0];
              }
              var returnType;
              if (options && options.returnType) {
                var allowedValues = ["Array", "Object"];
                returnType = allowedValues.indexOf(options.returnType) == -1 ? "Array" : options.returnType;
              } else {
                returnType = "Array";
              }
              var type = options && options.type || this._options.type;
              var filter = options && options.filter;
              var items = [], item, itemIds, itemId, i, len;
              if (id != void 0) {
                item = me._getItem(id, type);
                if (item && filter && !filter(item)) {
                  item = null;
                }
              } else if (ids != void 0) {
                for (i = 0, len = ids.length; i < len; i++) {
                  item = me._getItem(ids[i], type);
                  if (!filter || filter(item)) {
                    items.push(item);
                  }
                }
              } else {
                itemIds = (0, _keys2["default"])(this._data);
                for (i = 0, len = itemIds.length; i < len; i++) {
                  itemId = itemIds[i];
                  item = me._getItem(itemId, type);
                  if (!filter || filter(item)) {
                    items.push(item);
                  }
                }
              }
              if (options && options.order && id == void 0) {
                this._sort(items, options.order);
              }
              if (options && options.fields) {
                var fields = options.fields;
                if (id != void 0) {
                  item = this._filterFields(item, fields);
                } else {
                  for (i = 0, len = items.length; i < len; i++) {
                    items[i] = this._filterFields(items[i], fields);
                  }
                }
              }
              if (returnType == "Object") {
                var result = {}, resultant;
                for (i = 0, len = items.length; i < len; i++) {
                  resultant = items[i];
                  result[resultant.id] = resultant;
                }
                return result;
              } else {
                if (id != void 0) {
                  return item;
                } else {
                  return items;
                }
              }
            };
            DataSet.prototype.getIds = function(options) {
              var data = this._data, filter = options && options.filter, order = options && options.order, type = options && options.type || this._options.type, itemIds = (0, _keys2["default"])(data), i, len, id, item, items, ids = [];
              if (filter) {
                if (order) {
                  items = [];
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id = itemIds[i];
                    item = this._getItem(id, type);
                    if (filter(item)) {
                      items.push(item);
                    }
                  }
                  this._sort(items, order);
                  for (i = 0, len = items.length; i < len; i++) {
                    ids.push(items[i][this._fieldId]);
                  }
                } else {
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id = itemIds[i];
                    item = this._getItem(id, type);
                    if (filter(item)) {
                      ids.push(item[this._fieldId]);
                    }
                  }
                }
              } else {
                if (order) {
                  items = [];
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id = itemIds[i];
                    items.push(data[id]);
                  }
                  this._sort(items, order);
                  for (i = 0, len = items.length; i < len; i++) {
                    ids.push(items[i][this._fieldId]);
                  }
                } else {
                  for (i = 0, len = itemIds.length; i < len; i++) {
                    id = itemIds[i];
                    item = data[id];
                    ids.push(item[this._fieldId]);
                  }
                }
              }
              return ids;
            };
            DataSet.prototype.getDataSet = function() {
              return this;
            };
            DataSet.prototype.forEach = function(callback, options) {
              var filter = options && options.filter, type = options && options.type || this._options.type, data = this._data, itemIds = (0, _keys2["default"])(data), i, len, item, id;
              if (options && options.order) {
                var items = this.get(options);
                for (i = 0, len = items.length; i < len; i++) {
                  item = items[i];
                  id = item[this._fieldId];
                  callback(item, id);
                }
              } else {
                for (i = 0, len = itemIds.length; i < len; i++) {
                  id = itemIds[i];
                  item = this._getItem(id, type);
                  if (!filter || filter(item)) {
                    callback(item, id);
                  }
                }
              }
            };
            DataSet.prototype.map = function(callback, options) {
              var filter = options && options.filter, type = options && options.type || this._options.type, mappedItems = [], data = this._data, itemIds = (0, _keys2["default"])(data), i, len, id, item;
              for (i = 0, len = itemIds.length; i < len; i++) {
                id = itemIds[i];
                item = this._getItem(id, type);
                if (!filter || filter(item)) {
                  mappedItems.push(callback(item, id));
                }
              }
              if (options && options.order) {
                this._sort(mappedItems, options.order);
              }
              return mappedItems;
            };
            DataSet.prototype._filterFields = function(item, fields) {
              if (!item) {
                return item;
              }
              var filteredItem = {}, itemFields = (0, _keys2["default"])(item), len = itemFields.length, i, field;
              if (Array.isArray(fields)) {
                for (i = 0; i < len; i++) {
                  field = itemFields[i];
                  if (fields.indexOf(field) != -1) {
                    filteredItem[field] = item[field];
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  field = itemFields[i];
                  if (fields.hasOwnProperty(field)) {
                    filteredItem[fields[field]] = item[field];
                  }
                }
              }
              return filteredItem;
            };
            DataSet.prototype._sort = function(items, order) {
              if (util.isString(order)) {
                var name = order;
                items.sort(function(a, b) {
                  var av = a[name];
                  var bv = b[name];
                  return av > bv ? 1 : av < bv ? -1 : 0;
                });
              } else if (typeof order === "function") {
                items.sort(order);
              } else {
                throw new TypeError("Order must be a function or a string");
              }
            };
            DataSet.prototype.remove = function(id, senderId) {
              var removedIds = [], removedItems = [], ids = [], i, len, itemId, item;
              ids = Array.isArray(id) ? id : [id];
              for (i = 0, len = ids.length; i < len; i++) {
                item = this._remove(ids[i]);
                if (item) {
                  itemId = item[this._fieldId];
                  if (itemId != void 0) {
                    removedIds.push(itemId);
                    removedItems.push(item);
                  }
                }
              }
              if (removedIds.length) {
                this._trigger("remove", { items: removedIds, oldData: removedItems }, senderId);
              }
              return removedIds;
            };
            DataSet.prototype._remove = function(id) {
              var item, ident;
              if (util.isNumber(id) || util.isString(id)) {
                ident = id;
              } else if (id && (typeof id === "undefined" ? "undefined" : (0, _typeof3["default"])(id)) === "object") {
                ident = id[this._fieldId];
              }
              if (ident !== void 0 && this._data[ident]) {
                item = this._data[ident];
                delete this._data[ident];
                this.length--;
                return item;
              }
              return null;
            };
            DataSet.prototype.clear = function(senderId) {
              var i, len;
              var ids = (0, _keys2["default"])(this._data);
              var items = [];
              for (i = 0, len = ids.length; i < len; i++) {
                items.push(this._data[ids[i]]);
              }
              this._data = {};
              this.length = 0;
              this._trigger("remove", { items: ids, oldData: items }, senderId);
              return ids;
            };
            DataSet.prototype.max = function(field) {
              var data = this._data, itemIds = (0, _keys2["default"])(data), max = null, maxField = null, i, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id = itemIds[i];
                var item = data[id];
                var itemField = item[field];
                if (itemField != null && (!max || itemField > maxField)) {
                  max = item;
                  maxField = itemField;
                }
              }
              return max;
            };
            DataSet.prototype.min = function(field) {
              var data = this._data, itemIds = (0, _keys2["default"])(data), min = null, minField = null, i, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id = itemIds[i];
                var item = data[id];
                var itemField = item[field];
                if (itemField != null && (!min || itemField < minField)) {
                  min = item;
                  minField = itemField;
                }
              }
              return min;
            };
            DataSet.prototype.distinct = function(field) {
              var data = this._data;
              var itemIds = (0, _keys2["default"])(data);
              var values = [];
              var fieldType = this._options.type && this._options.type[field] || null;
              var count = 0;
              var i, j, len;
              for (i = 0, len = itemIds.length; i < len; i++) {
                var id = itemIds[i];
                var item = data[id];
                var value = item[field];
                var exists = false;
                for (j = 0; j < count; j++) {
                  if (values[j] == value) {
                    exists = true;
                    break;
                  }
                }
                if (!exists && value !== void 0) {
                  values[count] = value;
                  count++;
                }
              }
              if (fieldType) {
                for (i = 0, len = values.length; i < len; i++) {
                  values[i] = util.convert(values[i], fieldType);
                }
              }
              return values;
            };
            DataSet.prototype._addItem = function(item) {
              var id = item[this._fieldId];
              if (id != void 0) {
                if (this._data[id]) {
                  throw new Error("Cannot add item: item with id " + id + " already exists");
                }
              } else {
                id = util.randomUUID();
                item[this._fieldId] = id;
              }
              var d = {}, fields = (0, _keys2["default"])(item), i, len;
              for (i = 0, len = fields.length; i < len; i++) {
                var field = fields[i];
                var fieldType = this._type[field];
                d[field] = util.convert(item[field], fieldType);
              }
              this._data[id] = d;
              this.length++;
              return id;
            };
            DataSet.prototype._getItem = function(id, types) {
              var field, value, i, len;
              var raw = this._data[id];
              if (!raw) {
                return null;
              }
              var converted = {}, fields = (0, _keys2["default"])(raw);
              if (types) {
                for (i = 0, len = fields.length; i < len; i++) {
                  field = fields[i];
                  value = raw[field];
                  converted[field] = util.convert(value, types[field]);
                }
              } else {
                for (i = 0, len = fields.length; i < len; i++) {
                  field = fields[i];
                  value = raw[field];
                  converted[field] = value;
                }
              }
              if (!converted[this._fieldId]) {
                converted[this._fieldId] = raw.id;
              }
              return converted;
            };
            DataSet.prototype._updateItem = function(item) {
              var id = item[this._fieldId];
              if (id == void 0) {
                throw new Error("Cannot update item: item has no id (item: " + (0, _stringify2["default"])(item) + ")");
              }
              var d = this._data[id];
              if (!d) {
                throw new Error("Cannot update item: no item with id " + id + " found");
              }
              var fields = (0, _keys2["default"])(item);
              for (var i = 0, len = fields.length; i < len; i++) {
                var field = fields[i];
                var fieldType = this._type[field];
                d[field] = util.convert(item[field], fieldType);
              }
              return id;
            };
            module2.exports = DataSet;
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            function DataView(data, options) {
              this._data = null;
              this._ids = {};
              this.length = 0;
              this._options = options || {};
              this._fieldId = "id";
              this._subscribers = {};
              var me = this;
              this.listener = function() {
                me._onEvent.apply(me, arguments);
              };
              this.setData(data);
            }
            DataView.prototype.setData = function(data) {
              var ids, id, i, len, items;
              if (this._data) {
                if (this._data.off) {
                  this._data.off("*", this.listener);
                }
                ids = this._data.getIds({ filter: this._options && this._options.filter });
                items = [];
                for (i = 0, len = ids.length; i < len; i++) {
                  items.push(this._data._data[ids[i]]);
                }
                this._ids = {};
                this.length = 0;
                this._trigger("remove", { items: ids, oldData: items });
              }
              this._data = data;
              if (this._data) {
                this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || "id";
                ids = this._data.getIds({ filter: this._options && this._options.filter });
                for (i = 0, len = ids.length; i < len; i++) {
                  id = ids[i];
                  this._ids[id] = true;
                }
                this.length = ids.length;
                this._trigger("add", { items: ids });
                if (this._data.on) {
                  this._data.on("*", this.listener);
                }
              }
            };
            DataView.prototype.refresh = function() {
              var id, i, len;
              var ids = this._data.getIds({ filter: this._options && this._options.filter }), oldIds = (0, _keys2["default"])(this._ids), newIds = {}, addedIds = [], removedIds = [], removedItems = [];
              for (i = 0, len = ids.length; i < len; i++) {
                id = ids[i];
                newIds[id] = true;
                if (!this._ids[id]) {
                  addedIds.push(id);
                  this._ids[id] = true;
                }
              }
              for (i = 0, len = oldIds.length; i < len; i++) {
                id = oldIds[i];
                if (!newIds[id]) {
                  removedIds.push(id);
                  removedItems.push(this._data._data[id]);
                  delete this._ids[id];
                }
              }
              this.length += addedIds.length - removedIds.length;
              if (addedIds.length) {
                this._trigger("add", { items: addedIds });
              }
              if (removedIds.length) {
                this._trigger("remove", { items: removedIds, oldData: removedItems });
              }
            };
            DataView.prototype.get = function(args) {
              var me = this;
              var ids, options, data;
              var firstType = util.getType(arguments[0]);
              if (firstType == "String" || firstType == "Number" || firstType == "Array") {
                ids = arguments[0];
                options = arguments[1];
                data = arguments[2];
              } else {
                options = arguments[0];
                data = arguments[1];
              }
              var viewOptions = util.extend({}, this._options, options);
              if (this._options.filter && options && options.filter) {
                viewOptions.filter = function(item) {
                  return me._options.filter(item) && options.filter(item);
                };
              }
              var getArguments = [];
              if (ids != void 0) {
                getArguments.push(ids);
              }
              getArguments.push(viewOptions);
              getArguments.push(data);
              return this._data && this._data.get.apply(this._data, getArguments);
            };
            DataView.prototype.getIds = function(options) {
              var ids;
              if (this._data) {
                var defaultFilter = this._options.filter;
                var filter;
                if (options && options.filter) {
                  if (defaultFilter) {
                    filter = function filter2(item) {
                      return defaultFilter(item) && options.filter(item);
                    };
                  } else {
                    filter = options.filter;
                  }
                } else {
                  filter = defaultFilter;
                }
                ids = this._data.getIds({
                  filter,
                  order: options && options.order
                });
              } else {
                ids = [];
              }
              return ids;
            };
            DataView.prototype.map = function(callback, options) {
              var mappedItems = [];
              if (this._data) {
                var defaultFilter = this._options.filter;
                var filter;
                if (options && options.filter) {
                  if (defaultFilter) {
                    filter = function filter2(item) {
                      return defaultFilter(item) && options.filter(item);
                    };
                  } else {
                    filter = options.filter;
                  }
                } else {
                  filter = defaultFilter;
                }
                mappedItems = this._data.map(callback, {
                  filter,
                  order: options && options.order
                });
              } else {
                mappedItems = [];
              }
              return mappedItems;
            };
            DataView.prototype.getDataSet = function() {
              var dataSet = this;
              while (dataSet instanceof DataView) {
                dataSet = dataSet._data;
              }
              return dataSet || null;
            };
            DataView.prototype._onEvent = function(event, params, senderId) {
              var i, len, id, item;
              var ids = params && params.items;
              var addedIds = [], updatedIds = [], removedIds = [], oldItems = [], updatedItems = [], removedItems = [];
              if (ids && this._data) {
                switch (event) {
                  case "add":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id = ids[i];
                      item = this.get(id);
                      if (item) {
                        this._ids[id] = true;
                        addedIds.push(id);
                      }
                    }
                    break;
                  case "update":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id = ids[i];
                      item = this.get(id);
                      if (item) {
                        if (this._ids[id]) {
                          updatedIds.push(id);
                          updatedItems.push(params.data[i]);
                          oldItems.push(params.oldData[i]);
                        } else {
                          this._ids[id] = true;
                          addedIds.push(id);
                        }
                      } else {
                        if (this._ids[id]) {
                          delete this._ids[id];
                          removedIds.push(id);
                          removedItems.push(params.oldData[i]);
                        } else {
                        }
                      }
                    }
                    break;
                  case "remove":
                    for (i = 0, len = ids.length; i < len; i++) {
                      id = ids[i];
                      if (this._ids[id]) {
                        delete this._ids[id];
                        removedIds.push(id);
                        removedItems.push(params.oldData[i]);
                      }
                    }
                    break;
                }
                this.length += addedIds.length - removedIds.length;
                if (addedIds.length) {
                  this._trigger("add", { items: addedIds }, senderId);
                }
                if (updatedIds.length) {
                  this._trigger("update", { items: updatedIds, oldData: oldItems, data: updatedItems }, senderId);
                }
                if (removedIds.length) {
                  this._trigger("remove", { items: removedIds, oldData: removedItems }, senderId);
                }
              }
            };
            DataView.prototype.on = DataSet.prototype.on;
            DataView.prototype.off = DataSet.prototype.off;
            DataView.prototype._trigger = DataSet.prototype._trigger;
            DataView.prototype.subscribe = DataView.prototype.on;
            DataView.prototype.unsubscribe = DataView.prototype.off;
            module2.exports = DataView;
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var store = __webpack_require__(57)("wks");
            var uid = __webpack_require__(40);
            var Symbol2 = __webpack_require__(18).Symbol;
            var USE_SYMBOL = typeof Symbol2 == "function";
            var $exports = module2.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          /* 14 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.prepareElements = function(JSONcontainer) {
              for (var elementType in JSONcontainer) {
                if (JSONcontainer.hasOwnProperty(elementType)) {
                  JSONcontainer[elementType].redundant = JSONcontainer[elementType].used;
                  JSONcontainer[elementType].used = [];
                }
              }
            };
            exports2.cleanupElements = function(JSONcontainer) {
              for (var elementType in JSONcontainer) {
                if (JSONcontainer.hasOwnProperty(elementType)) {
                  if (JSONcontainer[elementType].redundant) {
                    for (var i = 0; i < JSONcontainer[elementType].redundant.length; i++) {
                      JSONcontainer[elementType].redundant[i].parentNode.removeChild(JSONcontainer[elementType].redundant[i]);
                    }
                    JSONcontainer[elementType].redundant = [];
                  }
                }
              }
            };
            exports2.resetElements = function(JSONcontainer) {
              exports2.prepareElements(JSONcontainer);
              exports2.cleanupElements(JSONcontainer);
              exports2.prepareElements(JSONcontainer);
            };
            exports2.getSVGElement = function(elementType, JSONcontainer, svgContainer) {
              var element;
              if (JSONcontainer.hasOwnProperty(elementType)) {
                if (JSONcontainer[elementType].redundant.length > 0) {
                  element = JSONcontainer[elementType].redundant[0];
                  JSONcontainer[elementType].redundant.shift();
                } else {
                  element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
                  svgContainer.appendChild(element);
                }
              } else {
                element = document.createElementNS("http://www.w3.org/2000/svg", elementType);
                JSONcontainer[elementType] = { used: [], redundant: [] };
                svgContainer.appendChild(element);
              }
              JSONcontainer[elementType].used.push(element);
              return element;
            };
            exports2.getDOMElement = function(elementType, JSONcontainer, DOMContainer, insertBefore) {
              var element;
              if (JSONcontainer.hasOwnProperty(elementType)) {
                if (JSONcontainer[elementType].redundant.length > 0) {
                  element = JSONcontainer[elementType].redundant[0];
                  JSONcontainer[elementType].redundant.shift();
                } else {
                  element = document.createElement(elementType);
                  if (insertBefore !== void 0) {
                    DOMContainer.insertBefore(element, insertBefore);
                  } else {
                    DOMContainer.appendChild(element);
                  }
                }
              } else {
                element = document.createElement(elementType);
                JSONcontainer[elementType] = { used: [], redundant: [] };
                if (insertBefore !== void 0) {
                  DOMContainer.insertBefore(element, insertBefore);
                } else {
                  DOMContainer.appendChild(element);
                }
              }
              JSONcontainer[elementType].used.push(element);
              return element;
            };
            exports2.drawPoint = function(x, y, groupTemplate, JSONcontainer, svgContainer, labelObj) {
              var point;
              if (groupTemplate.style == "circle") {
                point = exports2.getSVGElement("circle", JSONcontainer, svgContainer);
                point.setAttributeNS(null, "cx", x);
                point.setAttributeNS(null, "cy", y);
                point.setAttributeNS(null, "r", 0.5 * groupTemplate.size);
              } else {
                point = exports2.getSVGElement("rect", JSONcontainer, svgContainer);
                point.setAttributeNS(null, "x", x - 0.5 * groupTemplate.size);
                point.setAttributeNS(null, "y", y - 0.5 * groupTemplate.size);
                point.setAttributeNS(null, "width", groupTemplate.size);
                point.setAttributeNS(null, "height", groupTemplate.size);
              }
              if (groupTemplate.styles !== void 0) {
                point.setAttributeNS(null, "style", groupTemplate.styles);
              }
              point.setAttributeNS(null, "class", groupTemplate.className + " vis-point");
              if (labelObj) {
                var label = exports2.getSVGElement("text", JSONcontainer, svgContainer);
                if (labelObj.xOffset) {
                  x = x + labelObj.xOffset;
                }
                if (labelObj.yOffset) {
                  y = y + labelObj.yOffset;
                }
                if (labelObj.content) {
                  label.textContent = labelObj.content;
                }
                if (labelObj.className) {
                  label.setAttributeNS(null, "class", labelObj.className + " vis-label");
                }
                label.setAttributeNS(null, "x", x);
                label.setAttributeNS(null, "y", y);
              }
              return point;
            };
            exports2.drawBar = function(x, y, width, height, className, JSONcontainer, svgContainer, style) {
              if (height != 0) {
                if (height < 0) {
                  height *= -1;
                  y -= height;
                }
                var rect = exports2.getSVGElement("rect", JSONcontainer, svgContainer);
                rect.setAttributeNS(null, "x", x - 0.5 * width);
                rect.setAttributeNS(null, "y", y);
                rect.setAttributeNS(null, "width", width);
                rect.setAttributeNS(null, "height", height);
                rect.setAttributeNS(null, "class", className);
                if (style) {
                  rect.setAttributeNS(null, "style", style);
                }
              }
            };
          },
          /* 15 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.printStyle = void 0;
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var errorFound = false;
            var allOptions = void 0;
            var printStyle = "background: #FFeeee; color: #dd0000";
            var Validator = function() {
              function Validator2() {
                (0, _classCallCheck3["default"])(this, Validator2);
              }
              (0, _createClass3["default"])(Validator2, null, [{
                key: "validate",
                value: function validate(options, referenceOptions, subObject) {
                  errorFound = false;
                  allOptions = referenceOptions;
                  var usedOptions = referenceOptions;
                  if (subObject !== void 0) {
                    usedOptions = referenceOptions[subObject];
                  }
                  Validator2.parse(options, usedOptions, []);
                  return errorFound;
                }
                /**
                 * Will traverse an object recursively and check every value
                 * @param {Object} options
                 * @param {Object} referenceOptions
                 * @param {array} path    | where to look for the actual option
                 * @static
                 */
              }, {
                key: "parse",
                value: function parse(options, referenceOptions, path) {
                  for (var option in options) {
                    if (options.hasOwnProperty(option)) {
                      Validator2.check(option, options, referenceOptions, path);
                    }
                  }
                }
                /**
                 * Check every value. If the value is an object, call the parse function on that object.
                 * @param {string} option
                 * @param {Object} options
                 * @param {Object} referenceOptions
                 * @param {array} path    | where to look for the actual option
                 * @static
                 */
              }, {
                key: "check",
                value: function check(option, options, referenceOptions, path) {
                  if (referenceOptions[option] === void 0 && referenceOptions.__any__ === void 0) {
                    Validator2.getSuggestion(option, referenceOptions, path);
                    return;
                  }
                  var referenceOption = option;
                  var is_object = true;
                  if (referenceOptions[option] === void 0 && referenceOptions.__any__ !== void 0) {
                    referenceOption = "__any__";
                    is_object = Validator2.getType(options[option]) === "object";
                  } else {
                  }
                  var refOptionObj = referenceOptions[referenceOption];
                  if (is_object && refOptionObj.__type__ !== void 0) {
                    refOptionObj = refOptionObj.__type__;
                  }
                  Validator2.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);
                }
                /**
                 *
                 * @param {string}  option           | the option property
                 * @param {Object}  options          | The supplied options object
                 * @param {Object}  referenceOptions | The reference options containing all options and their allowed formats
                 * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
                 * @param {string}  refOptionObj     | This is the type object from the reference options
                 * @param {Array}   path             | where in the object is the option
                 * @static
                 */
              }, {
                key: "checkFields",
                value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
                  var log = function log2(message) {
                    console.log("%c" + message + Validator2.printLocation(path, option), printStyle);
                  };
                  var optionType = Validator2.getType(options[option]);
                  var refOptionType = refOptionObj[optionType];
                  if (refOptionType !== void 0) {
                    if (Validator2.getType(refOptionType) === "array" && refOptionType.indexOf(options[option]) === -1) {
                      log('Invalid option detected in "' + option + '". Allowed values are:' + Validator2.print(refOptionType) + ' not "' + options[option] + '". ');
                      errorFound = true;
                    } else if (optionType === "object" && referenceOption !== "__any__") {
                      path = util.copyAndExtendArray(path, option);
                      Validator2.parse(options[option], referenceOptions[referenceOption], path);
                    }
                  } else if (refOptionObj["any"] === void 0) {
                    log('Invalid type received for "' + option + '". Expected: ' + Validator2.print((0, _keys2["default"])(refOptionObj)) + ". Received [" + optionType + '] "' + options[option] + '"');
                    errorFound = true;
                  }
                }
                /**
                 *
                 * @param {Object|boolean|number|string|Array.<number>|Date|Node|Moment|undefined|null} object
                 * @returns {string}
                 * @static
                 */
              }, {
                key: "getType",
                value: function getType(object) {
                  var type = typeof object === "undefined" ? "undefined" : (0, _typeof3["default"])(object);
                  if (type === "object") {
                    if (object === null) {
                      return "null";
                    }
                    if (object instanceof Boolean) {
                      return "boolean";
                    }
                    if (object instanceof Number) {
                      return "number";
                    }
                    if (object instanceof String) {
                      return "string";
                    }
                    if (Array.isArray(object)) {
                      return "array";
                    }
                    if (object instanceof Date) {
                      return "date";
                    }
                    if (object.nodeType !== void 0) {
                      return "dom";
                    }
                    if (object._isAMomentObject === true) {
                      return "moment";
                    }
                    return "object";
                  } else if (type === "number") {
                    return "number";
                  } else if (type === "boolean") {
                    return "boolean";
                  } else if (type === "string") {
                    return "string";
                  } else if (type === void 0) {
                    return "undefined";
                  }
                  return type;
                }
                /**
                 * @param {string} option
                 * @param {Object} options
                 * @param {Array.<string>} path
                 * @static
                 */
              }, {
                key: "getSuggestion",
                value: function getSuggestion(option, options, path) {
                  var localSearch = Validator2.findInOptions(option, options, path, false);
                  var globalSearch = Validator2.findInOptions(option, allOptions, [], true);
                  var localSearchThreshold = 8;
                  var globalSearchThreshold = 4;
                  var msg = void 0;
                  if (localSearch.indexMatch !== void 0) {
                    msg = " in " + Validator2.printLocation(localSearch.path, option, "") + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n';
                  } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
                    msg = " in " + Validator2.printLocation(localSearch.path, option, "") + "Perhaps it was misplaced? Matching option found at: " + Validator2.printLocation(globalSearch.path, globalSearch.closestMatch, "");
                  } else if (localSearch.distance <= localSearchThreshold) {
                    msg = '. Did you mean "' + localSearch.closestMatch + '"?' + Validator2.printLocation(localSearch.path, option);
                  } else {
                    msg = ". Did you mean one of these: " + Validator2.print((0, _keys2["default"])(options)) + Validator2.printLocation(path, option);
                  }
                  console.log('%cUnknown option detected: "' + option + '"' + msg, printStyle);
                  errorFound = true;
                }
                /**
                 * traverse the options in search for a match.
                 * @param {string} option
                 * @param {Object} options
                 * @param {Array} path    | where to look for the actual option
                 * @param {boolean} [recursive=false]
                 * @returns {{closestMatch: string, path: Array, distance: number}}
                 * @static
                 */
              }, {
                key: "findInOptions",
                value: function findInOptions(option, options, path) {
                  var recursive = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  var min = 1e9;
                  var closestMatch = "";
                  var closestMatchPath = [];
                  var lowerCaseOption = option.toLowerCase();
                  var indexMatch = void 0;
                  for (var op in options) {
                    var distance = void 0;
                    if (options[op].__type__ !== void 0 && recursive === true) {
                      var result = Validator2.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
                      if (min > result.distance) {
                        closestMatch = result.closestMatch;
                        closestMatchPath = result.path;
                        min = result.distance;
                        indexMatch = result.indexMatch;
                      }
                    } else {
                      if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
                        indexMatch = op;
                      }
                      distance = Validator2.levenshteinDistance(option, op);
                      if (min > distance) {
                        closestMatch = op;
                        closestMatchPath = util.copyArray(path);
                        min = distance;
                      }
                    }
                  }
                  return { closestMatch, path: closestMatchPath, distance: min, indexMatch };
                }
                /**
                 * @param {Array.<string>} path
                 * @param {Object} option
                 * @param {string} prefix
                 * @returns {String}
                 * @static
                 */
              }, {
                key: "printLocation",
                value: function printLocation(path, option) {
                  var prefix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Problem value found at: \n";
                  var str = "\n\n" + prefix + "options = {\n";
                  for (var i = 0; i < path.length; i++) {
                    for (var j = 0; j < i + 1; j++) {
                      str += "  ";
                    }
                    str += path[i] + ": {\n";
                  }
                  for (var _j = 0; _j < path.length + 1; _j++) {
                    str += "  ";
                  }
                  str += option + "\n";
                  for (var _i = 0; _i < path.length + 1; _i++) {
                    for (var _j2 = 0; _j2 < path.length - _i; _j2++) {
                      str += "  ";
                    }
                    str += "}\n";
                  }
                  return str + "\n\n";
                }
                /**
                 * @param {Object} options
                 * @returns {String}
                 * @static
                 */
              }, {
                key: "print",
                value: function print(options) {
                  return (0, _stringify2["default"])(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ", ");
                }
                /**
                 *  Compute the edit distance between the two given strings
                 * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
                 *
                 * Copyright (c) 2011 Andrei Mackenzie
                 *
                 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
                 *
                 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
                 *
                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                 *
                 * @param {string} a
                 * @param {string} b
                 * @returns {Array.<Array.<number>>}}
                 * @static
                 */
              }, {
                key: "levenshteinDistance",
                value: function levenshteinDistance(a, b) {
                  if (a.length === 0) return b.length;
                  if (b.length === 0) return a.length;
                  var matrix = [];
                  var i;
                  for (i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                  }
                  var j;
                  for (j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                  }
                  for (i = 1; i <= b.length; i++) {
                    for (j = 1; j <= a.length; j++) {
                      if (b.charAt(i - 1) == a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                      } else {
                        matrix[i][j] = Math.min(
                          matrix[i - 1][j - 1] + 1,
                          // substitution
                          Math.min(
                            matrix[i][j - 1] + 1,
                            // insertion
                            matrix[i - 1][j] + 1
                          )
                        );
                      }
                    }
                  }
                  return matrix[b.length][a.length];
                }
              }]);
              return Validator2;
            }();
            exports2["default"] = Validator;
            exports2.printStyle = printStyle;
          },
          /* 16 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(2);
            function Component(body, options) {
              this.options = null;
              this.props = null;
            }
            Component.prototype.setOptions = function(options) {
              if (options) {
                util.extend(this.options, options);
              }
            };
            Component.prototype.redraw = function() {
              return false;
            };
            Component.prototype.destroy = function() {
            };
            Component.prototype._isResized = function() {
              var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;
              this.props._previousWidth = this.props.width;
              this.props._previousHeight = this.props.height;
              return resized;
            };
            module2.exports = Component;
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global = __webpack_require__(18);
            var core = __webpack_require__(7);
            var ctx = __webpack_require__(80);
            var hide = __webpack_require__(26);
            var PROTOTYPE = "prototype";
            var $export = function(type, name, source) {
              var IS_FORCED = type & $export.F;
              var IS_GLOBAL = type & $export.G;
              var IS_STATIC = type & $export.S;
              var IS_PROTO = type & $export.P;
              var IS_BIND = type & $export.B;
              var IS_WRAP = type & $export.W;
              var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports3[PROTOTYPE];
              var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
              var key, own, out;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                if (own && key in exports3) continue;
                out = own ? target[key] : source[key];
                exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                  var F = function(a, b, c) {
                    if (this instanceof C) {
                      switch (arguments.length) {
                        case 0:
                          return new C();
                        case 1:
                          return new C(a);
                        case 2:
                          return new C(a, b);
                      }
                      return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                  };
                  F[PROTOTYPE] = C[PROTOTYPE];
                  return F;
                }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (IS_PROTO) {
                  (exports3.virtual || (exports3.virtual = {}))[key] = out;
                  if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
                }
              }
            };
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module2.exports = $export;
          },
          /* 18 */
          /***/
          function(module2, exports2) {
            var global = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global;
          },
          /* 19 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(160), __esModule: true };
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(27);
            var IE8_DOM_DEFINE = __webpack_require__(81);
            var toPrimitive = __webpack_require__(53);
            var dP = Object.defineProperty;
            exports2.f = __webpack_require__(21) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
              if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
          },
          /* 21 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = !__webpack_require__(28)(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          },
          /* 22 */
          /***/
          function(module2, exports2) {
            var hasOwnProperty = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          /* 23 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var NodeBase = function() {
              function NodeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, NodeBase2);
                this.body = body;
                this.labelModule = labelModule;
                this.setOptions(options);
                this.top = void 0;
                this.left = void 0;
                this.height = void 0;
                this.width = void 0;
                this.radius = void 0;
                this.margin = void 0;
                this.refreshNeeded = true;
                this.boundingBox = { top: 0, left: 0, right: 0, bottom: 0 };
              }
              (0, _createClass3["default"])(NodeBase2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 *
                 * @param {Label} labelModule
                 * @private
                 */
              }, {
                key: "_setMargins",
                value: function _setMargins(labelModule) {
                  this.margin = {};
                  if (this.options.margin) {
                    if ((0, _typeof3["default"])(this.options.margin) == "object") {
                      this.margin.top = this.options.margin.top;
                      this.margin.right = this.options.margin.right;
                      this.margin.bottom = this.options.margin.bottom;
                      this.margin.left = this.options.margin.left;
                    } else {
                      this.margin.top = this.options.margin;
                      this.margin.right = this.options.margin;
                      this.margin.bottom = this.options.margin;
                      this.margin.left = this.options.margin;
                    }
                  }
                  labelModule.adjustSizes(this.margin);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_distanceToBorder",
                value: function _distanceToBorder(ctx, angle) {
                  var borderWidth = this.options.borderWidth;
                  this.resize(ctx);
                  return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "enableShadow",
                value: function enableShadow(ctx, values) {
                  if (values.shadow) {
                    ctx.shadowColor = values.shadowColor;
                    ctx.shadowBlur = values.shadowSize;
                    ctx.shadowOffsetX = values.shadowX;
                    ctx.shadowOffsetY = values.shadowY;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "disableShadow",
                value: function disableShadow(ctx, values) {
                  if (values.shadow) {
                    ctx.shadowColor = "rgba(0,0,0,0)";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "enableBorderDashes",
                value: function enableBorderDashes(ctx, values) {
                  if (values.borderDashes !== false) {
                    if (ctx.setLineDash !== void 0) {
                      var dashes = values.borderDashes;
                      if (dashes === true) {
                        dashes = [5, 15];
                      }
                      ctx.setLineDash(dashes);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
                      this.options.shapeProperties.borderDashes = false;
                      values.borderDashes = false;
                    }
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "disableBorderDashes",
                value: function disableBorderDashes(ctx, values) {
                  if (values.borderDashes !== false) {
                    if (ctx.setLineDash !== void 0) {
                      ctx.setLineDash([0]);
                    } else {
                      console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");
                      this.options.shapeProperties.borderDashes = false;
                      values.borderDashes = false;
                    }
                  }
                }
                /**
                 * Determine if the shape of a node needs to be recalculated.
                 *
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @returns {boolean}
                 * @protected
                 */
              }, {
                key: "needsRefresh",
                value: function needsRefresh(selected, hover) {
                  if (this.refreshNeeded === true) {
                    this.refreshNeeded = false;
                    return true;
                  }
                  return this.width === void 0 || this.labelModule.differentState(selected, hover);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "initContextForDraw",
                value: function initContextForDraw(ctx, values) {
                  var borderWidth = values.borderWidth / this.body.view.scale;
                  ctx.lineWidth = Math.min(this.width, borderWidth);
                  ctx.strokeStyle = values.borderColor;
                  ctx.fillStyle = values.color;
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "performStroke",
                value: function performStroke(ctx, values) {
                  var borderWidth = values.borderWidth / this.body.view.scale;
                  ctx.save();
                  if (borderWidth > 0) {
                    this.enableBorderDashes(ctx, values);
                    ctx.stroke();
                    this.disableBorderDashes(ctx, values);
                  }
                  ctx.restore();
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "performFill",
                value: function performFill(ctx, values) {
                  this.enableShadow(ctx, values);
                  ctx.fill();
                  this.disableShadow(ctx, values);
                  this.performStroke(ctx, values);
                }
                /**
                 *
                 * @param {number} margin
                 * @private
                 */
              }, {
                key: "_addBoundingBoxMargin",
                value: function _addBoundingBoxMargin(margin) {
                  this.boundingBox.left -= margin;
                  this.boundingBox.top -= margin;
                  this.boundingBox.bottom += margin;
                  this.boundingBox.right += margin;
                }
                /**
                 * Actual implementation of this method call.
                 *
                 * Doing it like this makes it easier to override
                 * in the child classes.
                 *
                 * @param {number} x width
                 * @param {number} y height
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @private
                 */
              }, {
                key: "_updateBoundingBox",
                value: function _updateBoundingBox(x, y, ctx, selected, hover) {
                  if (ctx !== void 0) {
                    this.resize(ctx, selected, hover);
                  }
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.boundingBox.left = this.left;
                  this.boundingBox.top = this.top;
                  this.boundingBox.bottom = this.top + this.height;
                  this.boundingBox.right = this.left + this.width;
                }
                /**
                 * Default implementation of this method call.
                 * This acts as a stub which can be overridden.
                 *
                 * @param {number} x width
                 * @param {number} y height
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y, ctx, selected, hover) {
                  this._updateBoundingBox(x, y, ctx, selected, hover);
                }
                /**
                 * Determine the dimensions to use for nodes with an internal label
                 *
                 * Currently, these are: Circle, Ellipse, Database, Box
                 * The other nodes have external labels, and will not call this method
                 *
                 * If there is no label, decent default values are supplied.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} [selected]
                 * @param {boolean} [hover]
                 * @returns {{width:number, height:number}}
                 */
              }, {
                key: "getDimensionsFromLabel",
                value: function getDimensionsFromLabel(ctx, selected, hover) {
                  this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
                  var width = this.textSize.width;
                  var height = this.textSize.height;
                  var DEFAULT_SIZE = 14;
                  if (width === 0) {
                    width = DEFAULT_SIZE;
                    height = DEFAULT_SIZE;
                  }
                  return { width, height };
                }
              }]);
              return NodeBase2;
            }();
            exports2["default"] = NodeBase;
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ShapeBase = function(_NodeBase) {
              (0, _inherits3["default"])(ShapeBase2, _NodeBase);
              function ShapeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, ShapeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (ShapeBase2.__proto__ || (0, _getPrototypeOf2["default"])(ShapeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(ShapeBase2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var values = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { size: this.options.size };
                  if (this.needsRefresh(selected, hover)) {
                    this.labelModule.getTextSize(ctx, selected, hover);
                    var size = 2 * values.size;
                    this.width = size;
                    this.height = size;
                    this.radius = 0.5 * this.width;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {string} shape
                 * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
                 * @param {number} x
                 * @param {number} y
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @private
                 */
              }, {
                key: "_drawShape",
                value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover, values);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx[shape](x, y, values.size);
                  this.performFill(ctx, values);
                  if (this.options.label !== void 0) {
                    this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, "hanging");
                    var yLabel = y + 0.5 * this.height + 0.5 * this.labelModule.size.height;
                    this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
                  }
                  this.updateBoundingBox(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);
                  }
                }
              }]);
              return ShapeBase2;
            }(_NodeBase3["default"]);
            exports2["default"] = ShapeBase;
          },
          /* 25 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var IObject = __webpack_require__(78);
            var defined = __webpack_require__(51);
            module2.exports = function(it) {
              return IObject(defined(it));
            };
          },
          /* 26 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var dP = __webpack_require__(20);
            var createDesc = __webpack_require__(39);
            module2.exports = __webpack_require__(21) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          /* 27 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject = __webpack_require__(32);
            module2.exports = function(it) {
              if (!isObject(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          },
          /* 28 */
          /***/
          function(module2, exports2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          /* 29 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(138), __esModule: true };
          },
          /* 30 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.__esModule = true;
            var _isIterable2 = __webpack_require__(188);
            var _isIterable3 = _interopRequireDefault(_isIterable2);
            var _getIterator2 = __webpack_require__(77);
            var _getIterator3 = _interopRequireDefault(_getIterator2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if ((0, _isIterable3.default)(Object(arr))) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
          },
          /* 31 */
          /***/
          function(module2, exports2) {
            module2.exports = {};
          },
          /* 32 */
          /***/
          function(module2, exports2) {
            module2.exports = function(it) {
              return typeof it === "object" ? it !== null : typeof it === "function";
            };
          },
          /* 33 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $keys = __webpack_require__(84);
            var enumBugKeys = __webpack_require__(58);
            module2.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          /* 34 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function Point3d(x, y, z) {
              this.x = x !== void 0 ? x : 0;
              this.y = y !== void 0 ? y : 0;
              this.z = z !== void 0 ? z : 0;
            }
            Point3d.subtract = function(a, b) {
              var sub = new Point3d();
              sub.x = a.x - b.x;
              sub.y = a.y - b.y;
              sub.z = a.z - b.z;
              return sub;
            };
            Point3d.add = function(a, b) {
              var sum = new Point3d();
              sum.x = a.x + b.x;
              sum.y = a.y + b.y;
              sum.z = a.z + b.z;
              return sum;
            };
            Point3d.avg = function(a, b) {
              return new Point3d((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);
            };
            Point3d.crossProduct = function(a, b) {
              var crossproduct = new Point3d();
              crossproduct.x = a.y * b.z - a.z * b.y;
              crossproduct.y = a.z * b.x - a.x * b.z;
              crossproduct.z = a.x * b.y - a.y * b.x;
              return crossproduct;
            };
            Point3d.prototype.length = function() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            };
            module2.exports = Point3d;
          },
          /* 35 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(root, factory) {
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof exports2 === "object") {
                module2.exports = factory();
              } else {
                root.keycharm = factory();
              }
            })(this, function() {
              function keycharm(options) {
                var preventDefault = options && options.preventDefault || false;
                var container = options && options.container || window;
                var _exportFunctions = {};
                var _bound = { keydown: {}, keyup: {} };
                var _keys = {};
                var i;
                for (i = 97; i <= 122; i++) {
                  _keys[String.fromCharCode(i)] = { code: 65 + (i - 97), shift: false };
                }
                for (i = 65; i <= 90; i++) {
                  _keys[String.fromCharCode(i)] = { code: i, shift: true };
                }
                for (i = 0; i <= 9; i++) {
                  _keys["" + i] = { code: 48 + i, shift: false };
                }
                for (i = 1; i <= 12; i++) {
                  _keys["F" + i] = { code: 111 + i, shift: false };
                }
                for (i = 0; i <= 9; i++) {
                  _keys["num" + i] = { code: 96 + i, shift: false };
                }
                _keys["num*"] = { code: 106, shift: false };
                _keys["num+"] = { code: 107, shift: false };
                _keys["num-"] = { code: 109, shift: false };
                _keys["num/"] = { code: 111, shift: false };
                _keys["num."] = { code: 110, shift: false };
                _keys["left"] = { code: 37, shift: false };
                _keys["up"] = { code: 38, shift: false };
                _keys["right"] = { code: 39, shift: false };
                _keys["down"] = { code: 40, shift: false };
                _keys["space"] = { code: 32, shift: false };
                _keys["enter"] = { code: 13, shift: false };
                _keys["shift"] = { code: 16, shift: void 0 };
                _keys["esc"] = { code: 27, shift: false };
                _keys["backspace"] = { code: 8, shift: false };
                _keys["tab"] = { code: 9, shift: false };
                _keys["ctrl"] = { code: 17, shift: false };
                _keys["alt"] = { code: 18, shift: false };
                _keys["delete"] = { code: 46, shift: false };
                _keys["pageup"] = { code: 33, shift: false };
                _keys["pagedown"] = { code: 34, shift: false };
                _keys["="] = { code: 187, shift: false };
                _keys["-"] = { code: 189, shift: false };
                _keys["]"] = { code: 221, shift: false };
                _keys["["] = { code: 219, shift: false };
                var down = function(event) {
                  handleEvent(event, "keydown");
                };
                var up = function(event) {
                  handleEvent(event, "keyup");
                };
                var handleEvent = function(event, type) {
                  if (_bound[type][event.keyCode] !== void 0) {
                    var bound = _bound[type][event.keyCode];
                    for (var i2 = 0; i2 < bound.length; i2++) {
                      if (bound[i2].shift === void 0) {
                        bound[i2].fn(event);
                      } else if (bound[i2].shift == true && event.shiftKey == true) {
                        bound[i2].fn(event);
                      } else if (bound[i2].shift == false && event.shiftKey == false) {
                        bound[i2].fn(event);
                      }
                    }
                    if (preventDefault == true) {
                      event.preventDefault();
                    }
                  }
                };
                _exportFunctions.bind = function(key, callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  if (_keys[key] === void 0) {
                    throw new Error("unsupported key: " + key);
                  }
                  if (_bound[type][_keys[key].code] === void 0) {
                    _bound[type][_keys[key].code] = [];
                  }
                  _bound[type][_keys[key].code].push({ fn: callback, shift: _keys[key].shift });
                };
                _exportFunctions.bindAll = function(callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  for (var key in _keys) {
                    if (_keys.hasOwnProperty(key)) {
                      _exportFunctions.bind(key, callback, type);
                    }
                  }
                };
                _exportFunctions.getKey = function(event) {
                  for (var key in _keys) {
                    if (_keys.hasOwnProperty(key)) {
                      if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
                        return key;
                      } else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
                        return key;
                      } else if (event.keyCode == _keys[key].code && key == "shift") {
                        return key;
                      }
                    }
                  }
                  return "unknown key, currently not supported";
                };
                _exportFunctions.unbind = function(key, callback, type) {
                  if (type === void 0) {
                    type = "keydown";
                  }
                  if (_keys[key] === void 0) {
                    throw new Error("unsupported key: " + key);
                  }
                  if (callback !== void 0) {
                    var newBindings = [];
                    var bound = _bound[type][_keys[key].code];
                    if (bound !== void 0) {
                      for (var i2 = 0; i2 < bound.length; i2++) {
                        if (!(bound[i2].fn == callback && bound[i2].shift == _keys[key].shift)) {
                          newBindings.push(_bound[type][_keys[key].code][i2]);
                        }
                      }
                    }
                    _bound[type][_keys[key].code] = newBindings;
                  } else {
                    _bound[type][_keys[key].code] = [];
                  }
                };
                _exportFunctions.reset = function() {
                  _bound = { keydown: {}, keyup: {} };
                };
                _exportFunctions.destroy = function() {
                  _bound = { keydown: {}, keyup: {} };
                  container.removeEventListener("keydown", down, true);
                  container.removeEventListener("keyup", up, true);
                };
                container.addEventListener("keydown", down, true);
                container.addEventListener("keyup", up, true);
                return _exportFunctions;
              }
              return keycharm;
            });
          },
          /* 36 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.convertHiddenOptions = function(moment, body, hiddenDates) {
              if (hiddenDates && !Array.isArray(hiddenDates)) {
                return exports2.convertHiddenOptions(moment, body, [hiddenDates]);
              }
              body.hiddenDates = [];
              if (hiddenDates) {
                if (Array.isArray(hiddenDates) == true) {
                  for (var i = 0; i < hiddenDates.length; i++) {
                    if (hiddenDates[i].repeat === void 0) {
                      var dateItem = {};
                      dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
                      dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
                      body.hiddenDates.push(dateItem);
                    }
                  }
                  body.hiddenDates.sort(function(a, b) {
                    return a.start - b.start;
                  });
                }
              }
            };
            exports2.updateHiddenDates = function(moment, body, hiddenDates) {
              if (hiddenDates && !Array.isArray(hiddenDates)) {
                return exports2.updateHiddenDates(moment, body, [hiddenDates]);
              }
              if (hiddenDates && body.domProps.centerContainer.width !== void 0) {
                exports2.convertHiddenOptions(moment, body, hiddenDates);
                var start = moment(body.range.start);
                var end = moment(body.range.end);
                var totalRange = body.range.end - body.range.start;
                var pixelTime = totalRange / body.domProps.centerContainer.width;
                for (var i = 0; i < hiddenDates.length; i++) {
                  if (hiddenDates[i].repeat !== void 0) {
                    var startDate = moment(hiddenDates[i].start);
                    var endDate = moment(hiddenDates[i].end);
                    if (startDate._d == "Invalid Date") {
                      throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
                    }
                    if (endDate._d == "Invalid Date") {
                      throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
                    }
                    var duration = endDate - startDate;
                    if (duration >= 4 * pixelTime) {
                      var offset = 0;
                      var runUntil = end.clone();
                      switch (hiddenDates[i].repeat) {
                        case "daily":
                          if (startDate.day() != endDate.day()) {
                            offset = 1;
                          }
                          startDate.dayOfYear(start.dayOfYear());
                          startDate.year(start.year());
                          startDate.subtract(7, "days");
                          endDate.dayOfYear(start.dayOfYear());
                          endDate.year(start.year());
                          endDate.subtract(7 - offset, "days");
                          runUntil.add(1, "weeks");
                          break;
                        case "weekly":
                          var dayOffset = endDate.diff(startDate, "days");
                          var day = startDate.day();
                          startDate.date(start.date());
                          startDate.month(start.month());
                          startDate.year(start.year());
                          endDate = startDate.clone();
                          startDate.day(day);
                          endDate.day(day);
                          endDate.add(dayOffset, "days");
                          startDate.subtract(1, "weeks");
                          endDate.subtract(1, "weeks");
                          runUntil.add(1, "weeks");
                          break;
                        case "monthly":
                          if (startDate.month() != endDate.month()) {
                            offset = 1;
                          }
                          startDate.month(start.month());
                          startDate.year(start.year());
                          startDate.subtract(1, "months");
                          endDate.month(start.month());
                          endDate.year(start.year());
                          endDate.subtract(1, "months");
                          endDate.add(offset, "months");
                          runUntil.add(1, "months");
                          break;
                        case "yearly":
                          if (startDate.year() != endDate.year()) {
                            offset = 1;
                          }
                          startDate.year(start.year());
                          startDate.subtract(1, "years");
                          endDate.year(start.year());
                          endDate.subtract(1, "years");
                          endDate.add(offset, "years");
                          runUntil.add(1, "years");
                          break;
                        default:
                          console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                          return;
                      }
                      while (startDate < runUntil) {
                        body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
                        switch (hiddenDates[i].repeat) {
                          case "daily":
                            startDate.add(1, "days");
                            endDate.add(1, "days");
                            break;
                          case "weekly":
                            startDate.add(1, "weeks");
                            endDate.add(1, "weeks");
                            break;
                          case "monthly":
                            startDate.add(1, "months");
                            endDate.add(1, "months");
                            break;
                          case "yearly":
                            startDate.add(1, "y");
                            endDate.add(1, "y");
                            break;
                          default:
                            console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                            return;
                        }
                      }
                      body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
                    }
                  }
                }
                exports2.removeDuplicates(body);
                var startHidden = exports2.isHidden(body.range.start, body.hiddenDates);
                var endHidden = exports2.isHidden(body.range.end, body.hiddenDates);
                var rangeStart = body.range.start;
                var rangeEnd = body.range.end;
                if (startHidden.hidden == true) {
                  rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
                }
                if (endHidden.hidden == true) {
                  rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
                }
                if (startHidden.hidden == true || endHidden.hidden == true) {
                  body.range._applyRange(rangeStart, rangeEnd);
                }
              }
            };
            exports2.removeDuplicates = function(body) {
              var hiddenDates = body.hiddenDates;
              var safeDates = [];
              for (var i = 0; i < hiddenDates.length; i++) {
                for (var j = 0; j < hiddenDates.length; j++) {
                  if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
                    if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
                      hiddenDates[j].remove = true;
                    } else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
                      hiddenDates[i].end = hiddenDates[j].end;
                      hiddenDates[j].remove = true;
                    } else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
                      hiddenDates[i].start = hiddenDates[j].start;
                      hiddenDates[j].remove = true;
                    }
                  }
                }
              }
              for (i = 0; i < hiddenDates.length; i++) {
                if (hiddenDates[i].remove !== true) {
                  safeDates.push(hiddenDates[i]);
                }
              }
              body.hiddenDates = safeDates;
              body.hiddenDates.sort(function(a, b) {
                return a.start - b.start;
              });
            };
            exports2.printDates = function(dates) {
              for (var i = 0; i < dates.length; i++) {
                console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
              }
            };
            exports2.stepOverHiddenDates = function(moment, timeStep, previousTime) {
              var stepInHidden = false;
              var currentValue = timeStep.current.valueOf();
              for (var i = 0; i < timeStep.hiddenDates.length; i++) {
                var startDate = timeStep.hiddenDates[i].start;
                var endDate = timeStep.hiddenDates[i].end;
                if (currentValue >= startDate && currentValue < endDate) {
                  stepInHidden = true;
                  break;
                }
              }
              if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
                var prevValue = moment(previousTime);
                var newValue = moment(endDate);
                if (prevValue.year() != newValue.year()) {
                  timeStep.switchedYear = true;
                } else if (prevValue.month() != newValue.month()) {
                  timeStep.switchedMonth = true;
                } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
                  timeStep.switchedDay = true;
                }
                timeStep.current = newValue;
              }
            };
            exports2.toScreen = function(Core, time, width) {
              var conversion;
              if (Core.body.hiddenDates.length == 0) {
                conversion = Core.range.conversion(width);
                return (time.valueOf() - conversion.offset) * conversion.scale;
              } else {
                var hidden = exports2.isHidden(time, Core.body.hiddenDates);
                if (hidden.hidden == true) {
                  time = hidden.startDate;
                }
                var duration = exports2.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
                if (time < Core.range.start) {
                  conversion = Core.range.conversion(width, duration);
                  var hiddenBeforeStart = exports2.getHiddenDurationBeforeStart(Core.body.hiddenDates, time, conversion.offset);
                  time = Core.options.moment(time).toDate().valueOf();
                  time = time + hiddenBeforeStart;
                  return -(conversion.offset - time.valueOf()) * conversion.scale;
                } else if (time > Core.range.end) {
                  var rangeAfterEnd = { start: Core.range.start, end: time };
                  time = exports2.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, rangeAfterEnd, time);
                  conversion = Core.range.conversion(width, duration);
                  return (time.valueOf() - conversion.offset) * conversion.scale;
                } else {
                  time = exports2.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);
                  conversion = Core.range.conversion(width, duration);
                  return (time.valueOf() - conversion.offset) * conversion.scale;
                }
              }
            };
            exports2.toTime = function(Core, x, width) {
              if (Core.body.hiddenDates.length == 0) {
                var conversion = Core.range.conversion(width);
                return new Date(x / conversion.scale + conversion.offset);
              } else {
                var hiddenDuration = exports2.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
                var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
                var partialDuration = totalDuration * x / width;
                var accumulatedHiddenDuration = exports2.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);
                return new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
              }
            };
            exports2.getHiddenDurationBetween = function(hiddenDates, start, end) {
              var duration = 0;
              for (var i = 0; i < hiddenDates.length; i++) {
                var startDate = hiddenDates[i].start;
                var endDate = hiddenDates[i].end;
                if (startDate >= start && endDate < end) {
                  duration += endDate - startDate;
                }
              }
              return duration;
            };
            exports2.getHiddenDurationBeforeStart = function(hiddenDates, start, end) {
              var duration = 0;
              for (var i = 0; i < hiddenDates.length; i++) {
                var startDate = hiddenDates[i].start;
                var endDate = hiddenDates[i].end;
                if (startDate >= start && endDate <= end) {
                  duration += endDate - startDate;
                }
              }
              return duration;
            };
            exports2.correctTimeForHidden = function(moment, hiddenDates, range, time) {
              time = moment(time).toDate().valueOf();
              time -= exports2.getHiddenDurationBefore(moment, hiddenDates, range, time);
              return time;
            };
            exports2.getHiddenDurationBefore = function(moment, hiddenDates, range, time) {
              var timeOffset = 0;
              time = moment(time).toDate().valueOf();
              for (var i = 0; i < hiddenDates.length; i++) {
                var startDate = hiddenDates[i].start;
                var endDate = hiddenDates[i].end;
                if (startDate >= range.start && endDate < range.end) {
                  if (time >= endDate) {
                    timeOffset += endDate - startDate;
                  }
                }
              }
              return timeOffset;
            };
            exports2.getAccumulatedHiddenDuration = function(hiddenDates, range, requiredDuration) {
              var hiddenDuration = 0;
              var duration = 0;
              var previousPoint = range.start;
              for (var i = 0; i < hiddenDates.length; i++) {
                var startDate = hiddenDates[i].start;
                var endDate = hiddenDates[i].end;
                if (startDate >= range.start && endDate < range.end) {
                  duration += startDate - previousPoint;
                  previousPoint = endDate;
                  if (duration >= requiredDuration) {
                    break;
                  } else {
                    hiddenDuration += endDate - startDate;
                  }
                }
              }
              return hiddenDuration;
            };
            exports2.snapAwayFromHidden = function(hiddenDates, time, direction, correctionEnabled) {
              var isHidden = exports2.isHidden(time, hiddenDates);
              if (isHidden.hidden == true) {
                if (direction < 0) {
                  if (correctionEnabled == true) {
                    return isHidden.startDate - (isHidden.endDate - time) - 1;
                  } else {
                    return isHidden.startDate - 1;
                  }
                } else {
                  if (correctionEnabled == true) {
                    return isHidden.endDate + (time - isHidden.startDate) + 1;
                  } else {
                    return isHidden.endDate + 1;
                  }
                }
              } else {
                return time;
              }
            };
            exports2.isHidden = function(time, hiddenDates) {
              for (var i = 0; i < hiddenDates.length; i++) {
                var startDate = hiddenDates[i].start;
                var endDate = hiddenDates[i].end;
                if (time >= startDate && time < endDate) {
                  return { hidden: true, startDate, endDate };
                }
              }
              return { hidden: false, startDate, endDate };
            };
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.onTouch = function(hammer, callback) {
              callback.inputHandler = function(event) {
                if (event.isFirst) {
                  callback(event);
                }
              };
              hammer.on("hammer.input", callback.inputHandler);
            };
            exports2.onRelease = function(hammer, callback) {
              callback.inputHandler = function(event) {
                if (event.isFinal) {
                  callback(event);
                }
              };
              return hammer.on("hammer.input", callback.inputHandler);
            };
            exports2.offTouch = function(hammer, callback) {
              hammer.off("hammer.input", callback.inputHandler);
            };
            exports2.offRelease = exports2.offTouch;
            exports2.disablePreventDefaultVertically = function(pinchRecognizer) {
              var TOUCH_ACTION_PAN_Y = "pan-y";
              pinchRecognizer.getTouchAction = function() {
                return [TOUCH_ACTION_PAN_Y];
              };
              return pinchRecognizer;
            };
          },
          /* 38 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(10);
            var util = __webpack_require__(2);
            var moment = __webpack_require__(9);
            function Item(data, conversion, options) {
              this.id = null;
              this.parent = null;
              this.data = data;
              this.dom = null;
              this.conversion = conversion || {};
              this.options = options || {};
              this.selected = false;
              this.displayed = false;
              this.groupShowing = true;
              this.dirty = true;
              this.top = null;
              this.right = null;
              this.left = null;
              this.width = null;
              this.height = null;
              this.editable = null;
              this._updateEditStatus();
            }
            Item.prototype.stack = true;
            Item.prototype.select = function() {
              this.selected = true;
              this.dirty = true;
              if (this.displayed) this.redraw();
            };
            Item.prototype.unselect = function() {
              this.selected = false;
              this.dirty = true;
              if (this.displayed) this.redraw();
            };
            Item.prototype.setData = function(data) {
              var groupChanged = data.group != void 0 && this.data.group != data.group;
              if (groupChanged && this.parent != null) {
                this.parent.itemSet._moveToGroup(this, data.group);
              }
              if (this.parent) {
                this.parent.stackDirty = true;
              }
              var subGroupChanged = data.subgroup != void 0 && this.data.subgroup != data.subgroup;
              if (subGroupChanged && this.parent != null) {
                this.parent.changeSubgroup(this, this.data.subgroup, data.subgroup);
              }
              this.data = data;
              this._updateEditStatus();
              this.dirty = true;
              if (this.displayed) this.redraw();
            };
            Item.prototype.setParent = function(parent) {
              if (this.displayed) {
                this.hide();
                this.parent = parent;
                if (this.parent) {
                  this.show();
                }
              } else {
                this.parent = parent;
              }
            };
            Item.prototype.isVisible = function(range) {
              return false;
            };
            Item.prototype.show = function() {
              return false;
            };
            Item.prototype.hide = function() {
              return false;
            };
            Item.prototype.redraw = function() {
            };
            Item.prototype.repositionX = function() {
            };
            Item.prototype.repositionY = function() {
            };
            Item.prototype._repaintDragCenter = function() {
              if (this.selected && this.options.editable.updateTime && !this.dom.dragCenter) {
                var me = this;
                var dragCenter = document.createElement("div");
                dragCenter.className = "vis-drag-center";
                dragCenter.dragCenterItem = this;
                var hammer = new Hammer(dragCenter);
                hammer.on("tap", function(event) {
                  me.parent.itemSet.body.emitter.emit("click", {
                    event,
                    item: me.id
                  });
                });
                hammer.on("doubletap", function(event) {
                  event.stopPropagation();
                  me.parent.itemSet._onUpdateItem(me);
                  me.parent.itemSet.body.emitter.emit("doubleClick", {
                    event,
                    item: me.id
                  });
                });
                if (this.dom.box) {
                  if (this.dom.dragLeft) {
                    this.dom.box.insertBefore(dragCenter, this.dom.dragLeft);
                  } else {
                    this.dom.box.appendChild(dragCenter);
                  }
                } else if (this.dom.point) {
                  this.dom.point.appendChild(dragCenter);
                }
                this.dom.dragCenter = dragCenter;
              } else if (!this.selected && this.dom.dragCenter) {
                if (this.dom.dragCenter.parentNode) {
                  this.dom.dragCenter.parentNode.removeChild(this.dom.dragCenter);
                }
                this.dom.dragCenter = null;
              }
            };
            Item.prototype._repaintDeleteButton = function(anchor) {
              var editable = (this.options.editable.overrideItems || this.editable == null) && this.options.editable.remove || !this.options.editable.overrideItems && this.editable != null && this.editable.remove;
              if (this.selected && editable && !this.dom.deleteButton) {
                var me = this;
                var deleteButton = document.createElement("div");
                if (this.options.rtl) {
                  deleteButton.className = "vis-delete-rtl";
                } else {
                  deleteButton.className = "vis-delete";
                }
                deleteButton.title = "Delete this item";
                new Hammer(deleteButton).on("tap", function(event) {
                  event.stopPropagation();
                  me.parent.removeFromDataSet(me);
                });
                anchor.appendChild(deleteButton);
                this.dom.deleteButton = deleteButton;
              } else if (!this.selected && this.dom.deleteButton) {
                if (this.dom.deleteButton.parentNode) {
                  this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
                }
                this.dom.deleteButton = null;
              }
            };
            Item.prototype._repaintOnItemUpdateTimeTooltip = function(anchor) {
              if (!this.options.tooltipOnItemUpdateTime) return;
              var editable = (this.options.editable.updateTime || this.data.editable === true) && this.data.editable !== false;
              if (this.selected && editable && !this.dom.onItemUpdateTimeTooltip) {
                var onItemUpdateTimeTooltip = document.createElement("div");
                onItemUpdateTimeTooltip.className = "vis-onUpdateTime-tooltip";
                anchor.appendChild(onItemUpdateTimeTooltip);
                this.dom.onItemUpdateTimeTooltip = onItemUpdateTimeTooltip;
              } else if (!this.selected && this.dom.onItemUpdateTimeTooltip) {
                if (this.dom.onItemUpdateTimeTooltip.parentNode) {
                  this.dom.onItemUpdateTimeTooltip.parentNode.removeChild(this.dom.onItemUpdateTimeTooltip);
                }
                this.dom.onItemUpdateTimeTooltip = null;
              }
              if (this.dom.onItemUpdateTimeTooltip) {
                this.dom.onItemUpdateTimeTooltip.style.visibility = this.parent.itemSet.touchParams.itemIsDragging ? "visible" : "hidden";
                if (this.options.rtl) {
                  this.dom.onItemUpdateTimeTooltip.style.right = this.dom.content.style.right;
                } else {
                  this.dom.onItemUpdateTimeTooltip.style.left = this.dom.content.style.left;
                }
                var tooltipOffset = 50;
                var scrollTop = this.parent.itemSet.body.domProps.scrollTop;
                var itemDistanceFromTop;
                if (this.options.orientation.item == "top") {
                  itemDistanceFromTop = this.top;
                } else {
                  itemDistanceFromTop = this.parent.height - this.top - this.height;
                }
                var isCloseToTop = itemDistanceFromTop + this.parent.top - tooltipOffset < -scrollTop;
                if (isCloseToTop) {
                  this.dom.onItemUpdateTimeTooltip.style.bottom = "";
                  this.dom.onItemUpdateTimeTooltip.style.top = this.height + 2 + "px";
                } else {
                  this.dom.onItemUpdateTimeTooltip.style.top = "";
                  this.dom.onItemUpdateTimeTooltip.style.bottom = this.height + 2 + "px";
                }
                var content;
                var templateFunction;
                if (this.options.tooltipOnItemUpdateTime && this.options.tooltipOnItemUpdateTime.template) {
                  templateFunction = this.options.tooltipOnItemUpdateTime.template.bind(this);
                  content = templateFunction(this.data);
                } else {
                  content = "start: " + moment(this.data.start).format("MM/DD/YYYY hh:mm");
                  if (this.data.end) {
                    content += "<br> end: " + moment(this.data.end).format("MM/DD/YYYY hh:mm");
                  }
                }
                this.dom.onItemUpdateTimeTooltip.innerHTML = content;
              }
            };
            Item.prototype._updateContents = function(element) {
              var content;
              var changed;
              var templateFunction;
              var itemVisibleFrameContent;
              var visibleFrameTemplateFunction;
              var itemData = this.parent.itemSet.itemsData.get(this.id);
              var frameElement = this.dom.box || this.dom.point;
              var itemVisibleFrameContentElement = frameElement.getElementsByClassName("vis-item-visible-frame")[0];
              if (this.options.visibleFrameTemplate) {
                visibleFrameTemplateFunction = this.options.visibleFrameTemplate.bind(this);
                itemVisibleFrameContent = visibleFrameTemplateFunction(itemData, frameElement);
              } else {
                itemVisibleFrameContent = "";
              }
              if (itemVisibleFrameContentElement) {
                if (itemVisibleFrameContent instanceof Object && !(itemVisibleFrameContent instanceof Element)) {
                  visibleFrameTemplateFunction(itemData, itemVisibleFrameContentElement);
                } else {
                  changed = this._contentToString(this.itemVisibleFrameContent) !== this._contentToString(itemVisibleFrameContent);
                  if (changed) {
                    if (itemVisibleFrameContent instanceof Element) {
                      itemVisibleFrameContentElement.innerHTML = "";
                      itemVisibleFrameContentElement.appendChild(itemVisibleFrameContent);
                    } else if (itemVisibleFrameContent != void 0) {
                      itemVisibleFrameContentElement.innerHTML = itemVisibleFrameContent;
                    } else {
                      if (!(this.data.type == "background" && this.data.content === void 0)) {
                        throw new Error('Property "content" missing in item ' + this.id);
                      }
                    }
                    this.itemVisibleFrameContent = itemVisibleFrameContent;
                  }
                }
              }
              if (this.options.template) {
                templateFunction = this.options.template.bind(this);
                content = templateFunction(itemData, element, this.data);
              } else {
                content = this.data.content;
              }
              if (content instanceof Object && !(content instanceof Element)) {
                templateFunction(itemData, element);
              } else {
                changed = this._contentToString(this.content) !== this._contentToString(content);
                if (changed) {
                  if (content instanceof Element) {
                    element.innerHTML = "";
                    element.appendChild(content);
                  } else if (content != void 0) {
                    element.innerHTML = content;
                  } else {
                    if (!(this.data.type == "background" && this.data.content === void 0)) {
                      throw new Error('Property "content" missing in item ' + this.id);
                    }
                  }
                  this.content = content;
                }
              }
            };
            Item.prototype._updateDataAttributes = function(element) {
              if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
                var attributes = [];
                if (Array.isArray(this.options.dataAttributes)) {
                  attributes = this.options.dataAttributes;
                } else if (this.options.dataAttributes == "all") {
                  attributes = (0, _keys2["default"])(this.data);
                } else {
                  return;
                }
                for (var i = 0; i < attributes.length; i++) {
                  var name = attributes[i];
                  var value = this.data[name];
                  if (value != null) {
                    element.setAttribute("data-" + name, value);
                  } else {
                    element.removeAttribute("data-" + name);
                  }
                }
              }
            };
            Item.prototype._updateStyle = function(element) {
              if (this.style) {
                util.removeCssText(element, this.style);
                this.style = null;
              }
              if (this.data.style) {
                util.addCssText(element, this.data.style);
                this.style = this.data.style;
              }
            };
            Item.prototype._contentToString = function(content) {
              if (typeof content === "string") return content;
              if (content && "outerHTML" in content) return content.outerHTML;
              return content;
            };
            Item.prototype._updateEditStatus = function() {
              if (this.options) {
                if (typeof this.options.editable === "boolean") {
                  this.editable = {
                    updateTime: this.options.editable,
                    updateGroup: this.options.editable,
                    remove: this.options.editable
                  };
                } else if ((0, _typeof3["default"])(this.options.editable) === "object") {
                  this.editable = {};
                  util.selectiveExtend(["updateTime", "updateGroup", "remove"], this.editable, this.options.editable);
                }
              }
              if (!this.options || !this.options.editable || this.options.editable.overrideItems !== true) {
                if (this.data) {
                  if (typeof this.data.editable === "boolean") {
                    this.editable = {
                      updateTime: this.data.editable,
                      updateGroup: this.data.editable,
                      remove: this.data.editable
                    };
                  } else if ((0, _typeof3["default"])(this.data.editable) === "object") {
                    this.editable = {};
                    util.selectiveExtend(["updateTime", "updateGroup", "remove"], this.editable, this.data.editable);
                  }
                }
              }
            };
            Item.prototype.getWidthLeft = function() {
              return 0;
            };
            Item.prototype.getWidthRight = function() {
              return 0;
            };
            Item.prototype.getTitle = function() {
              return this.data.title;
            };
            module2.exports = Item;
          },
          /* 39 */
          /***/
          function(module2, exports2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          /* 40 */
          /***/
          function(module2, exports2) {
            var id = 0;
            var px = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          },
          /* 41 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var defined = __webpack_require__(51);
            module2.exports = function(it) {
              return Object(defined(it));
            };
          },
          /* 42 */
          /***/
          function(module2, exports2) {
            exports2.f = {}.propertyIsEnumerable;
          },
          /* 43 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function Queue(options) {
              this.delay = null;
              this.max = Infinity;
              this._queue = [];
              this._timeout = null;
              this._extended = null;
              this.setOptions(options);
            }
            Queue.prototype.setOptions = function(options) {
              if (options && typeof options.delay !== "undefined") {
                this.delay = options.delay;
              }
              if (options && typeof options.max !== "undefined") {
                this.max = options.max;
              }
              this._flushIfNeeded();
            };
            Queue.extend = function(object, options) {
              var queue = new Queue(options);
              if (object.flush !== void 0) {
                throw new Error("Target object already has a property flush");
              }
              object.flush = function() {
                queue.flush();
              };
              var methods = [{
                name: "flush",
                original: void 0
              }];
              if (options && options.replace) {
                for (var i = 0; i < options.replace.length; i++) {
                  var name = options.replace[i];
                  methods.push({
                    name,
                    original: object[name]
                  });
                  queue.replace(object, name);
                }
              }
              queue._extended = {
                object,
                methods
              };
              return queue;
            };
            Queue.prototype.destroy = function() {
              this.flush();
              if (this._extended) {
                var object = this._extended.object;
                var methods = this._extended.methods;
                for (var i = 0; i < methods.length; i++) {
                  var method = methods[i];
                  if (method.original) {
                    object[method.name] = method.original;
                  } else {
                    delete object[method.name];
                  }
                }
                this._extended = null;
              }
            };
            Queue.prototype.replace = function(object, method) {
              var me = this;
              var original = object[method];
              if (!original) {
                throw new Error("Method " + method + " undefined");
              }
              object[method] = function() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  args[i] = arguments[i];
                }
                me.queue({
                  args,
                  fn: original,
                  context: this
                });
              };
            };
            Queue.prototype.queue = function(entry) {
              if (typeof entry === "function") {
                this._queue.push({ fn: entry });
              } else {
                this._queue.push(entry);
              }
              this._flushIfNeeded();
            };
            Queue.prototype._flushIfNeeded = function() {
              if (this._queue.length > this.max) {
                this.flush();
              }
              clearTimeout(this._timeout);
              if (this.queue.length > 0 && typeof this.delay === "number") {
                var me = this;
                this._timeout = setTimeout(function() {
                  me.flush();
                }, this.delay);
              }
            };
            Queue.prototype.flush = function() {
              while (this._queue.length > 0) {
                var entry = this._queue.shift();
                entry.fn.apply(entry.context || entry.fn, entry.args || []);
              }
            };
            module2.exports = Queue;
          },
          /* 44 */
          /***/
          function(module2, exports2) {
            module2.exports = Emitter;
            function Emitter(obj) {
              if (obj) return mixin(obj);
            }
            ;
            function mixin(obj) {
              for (var key in Emitter.prototype) {
                obj[key] = Emitter.prototype[key];
              }
              return obj;
            }
            Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
              this._callbacks = this._callbacks || {};
              (this._callbacks[event] = this._callbacks[event] || []).push(fn);
              return this;
            };
            Emitter.prototype.once = function(event, fn) {
              var self2 = this;
              this._callbacks = this._callbacks || {};
              function on() {
                self2.off(event, on);
                fn.apply(this, arguments);
              }
              on.fn = fn;
              this.on(event, on);
              return this;
            };
            Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
              this._callbacks = this._callbacks || {};
              if (0 == arguments.length) {
                this._callbacks = {};
                return this;
              }
              var callbacks = this._callbacks[event];
              if (!callbacks) return this;
              if (1 == arguments.length) {
                delete this._callbacks[event];
                return this;
              }
              var cb;
              for (var i = 0; i < callbacks.length; i++) {
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                  callbacks.splice(i, 1);
                  break;
                }
              }
              return this;
            };
            Emitter.prototype.emit = function(event) {
              this._callbacks = this._callbacks || {};
              var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
              if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) {
                  callbacks[i].apply(this, args);
                }
              }
              return this;
            };
            Emitter.prototype.listeners = function(event) {
              this._callbacks = this._callbacks || {};
              return this._callbacks[event] || [];
            };
            Emitter.prototype.hasListeners = function(event) {
              return !!this.listeners(event).length;
            };
          },
          /* 45 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Component = __webpack_require__(16);
            var TimeStep = __webpack_require__(66);
            var DateUtil = __webpack_require__(36);
            var moment = __webpack_require__(9);
            function TimeAxis(body, options) {
              this.dom = {
                foreground: null,
                lines: [],
                majorTexts: [],
                minorTexts: [],
                redundant: {
                  lines: [],
                  majorTexts: [],
                  minorTexts: []
                }
              };
              this.props = {
                range: {
                  start: 0,
                  end: 0,
                  minimumStep: 0
                },
                lineTop: 0
              };
              this.defaultOptions = {
                orientation: {
                  axis: "bottom"
                },
                // axis orientation: 'top' or 'bottom'
                showMinorLabels: true,
                showMajorLabels: true,
                maxMinorChars: 7,
                format: TimeStep.FORMAT,
                moment,
                timeAxis: null
              };
              this.options = util.extend({}, this.defaultOptions);
              this.body = body;
              this._create();
              this.setOptions(options);
            }
            TimeAxis.prototype = new Component();
            TimeAxis.prototype.setOptions = function(options) {
              if (options) {
                util.selectiveExtend(["showMinorLabels", "showMajorLabels", "maxMinorChars", "hiddenDates", "timeAxis", "moment", "rtl"], this.options, options);
                util.selectiveDeepExtend(["format"], this.options, options);
                if ("orientation" in options) {
                  if (typeof options.orientation === "string") {
                    this.options.orientation.axis = options.orientation;
                  } else if ((0, _typeof3["default"])(options.orientation) === "object" && "axis" in options.orientation) {
                    this.options.orientation.axis = options.orientation.axis;
                  }
                }
                if ("locale" in options) {
                  if (typeof moment.locale === "function") {
                    moment.locale(options.locale);
                  } else {
                    moment.lang(options.locale);
                  }
                }
              }
            };
            TimeAxis.prototype._create = function() {
              this.dom.foreground = document.createElement("div");
              this.dom.background = document.createElement("div");
              this.dom.foreground.className = "vis-time-axis vis-foreground";
              this.dom.background.className = "vis-time-axis vis-background";
            };
            TimeAxis.prototype.destroy = function() {
              if (this.dom.foreground.parentNode) {
                this.dom.foreground.parentNode.removeChild(this.dom.foreground);
              }
              if (this.dom.background.parentNode) {
                this.dom.background.parentNode.removeChild(this.dom.background);
              }
              this.body = null;
            };
            TimeAxis.prototype.redraw = function() {
              var props = this.props;
              var foreground = this.dom.foreground;
              var background = this.dom.background;
              var parent = this.options.orientation.axis == "top" ? this.body.dom.top : this.body.dom.bottom;
              var parentChanged = foreground.parentNode !== parent;
              this._calculateCharSize();
              var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== "none";
              var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== "none";
              props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
              props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
              props.height = props.minorLabelHeight + props.majorLabelHeight;
              props.width = foreground.offsetWidth;
              props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == "top" ? this.body.domProps.bottom.height : this.body.domProps.top.height);
              props.minorLineWidth = 1;
              props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
              props.majorLineWidth = 1;
              var foregroundNextSibling = foreground.nextSibling;
              var backgroundNextSibling = background.nextSibling;
              foreground.parentNode && foreground.parentNode.removeChild(foreground);
              background.parentNode && background.parentNode.removeChild(background);
              foreground.style.height = this.props.height + "px";
              this._repaintLabels();
              if (foregroundNextSibling) {
                parent.insertBefore(foreground, foregroundNextSibling);
              } else {
                parent.appendChild(foreground);
              }
              if (backgroundNextSibling) {
                this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
              } else {
                this.body.dom.backgroundVertical.appendChild(background);
              }
              return this._isResized() || parentChanged;
            };
            TimeAxis.prototype._repaintLabels = function() {
              var orientation = this.options.orientation.axis;
              var start = util.convert(this.body.range.start, "Number");
              var end = util.convert(this.body.range.end, "Number");
              var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * this.options.maxMinorChars).valueOf();
              var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
              minimumStep -= this.body.util.toTime(0).valueOf();
              var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates, this.options);
              step.setMoment(this.options.moment);
              if (this.options.format) {
                step.setFormat(this.options.format);
              }
              if (this.options.timeAxis) {
                step.setScale(this.options.timeAxis);
              }
              this.step = step;
              var dom = this.dom;
              dom.redundant.lines = dom.lines;
              dom.redundant.majorTexts = dom.majorTexts;
              dom.redundant.minorTexts = dom.minorTexts;
              dom.lines = [];
              dom.majorTexts = [];
              dom.minorTexts = [];
              var current;
              var next;
              var x;
              var xNext;
              var isMajor;
              var nextIsMajor;
              var showMinorGrid;
              var width = 0, prevWidth;
              var line;
              var labelMinor;
              var xFirstMajorLabel = void 0;
              var count = 0;
              var MAX = 1e3;
              var className;
              step.start();
              next = step.getCurrent();
              xNext = this.body.util.toScreen(next);
              while (step.hasNext() && count < MAX) {
                count++;
                isMajor = step.isMajor();
                className = step.getClassName();
                labelMinor = step.getLabelMinor();
                current = next;
                x = xNext;
                step.next();
                next = step.getCurrent();
                nextIsMajor = step.isMajor();
                xNext = this.body.util.toScreen(next);
                prevWidth = width;
                width = xNext - x;
                switch (step.scale) {
                  case "week":
                    showMinorGrid = true;
                    break;
                  default:
                    showMinorGrid = width >= prevWidth * 0.4;
                    break;
                }
                if (this.options.showMinorLabels && showMinorGrid) {
                  var label = this._repaintMinorText(x, labelMinor, orientation, className);
                  label.style.width = width + "px";
                }
                if (isMajor && this.options.showMajorLabels) {
                  if (x > 0) {
                    if (xFirstMajorLabel == void 0) {
                      xFirstMajorLabel = x;
                    }
                    label = this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
                  }
                  line = this._repaintMajorLine(x, width, orientation, className);
                } else {
                  if (showMinorGrid) {
                    line = this._repaintMinorLine(x, width, orientation, className);
                  } else {
                    if (line) {
                      line.style.width = parseInt(line.style.width) + width + "px";
                    }
                  }
                }
              }
              if (count === MAX && !warnedForOverflow) {
                console.warn("Something is wrong with the Timeline scale. Limited drawing of grid lines to " + MAX + " lines.");
                warnedForOverflow = true;
              }
              if (this.options.showMajorLabels) {
                var leftTime = this.body.util.toTime(0), leftText = step.getLabelMajor(leftTime), widthText = leftText.length * (this.props.majorCharWidth || 10) + 10;
                if (xFirstMajorLabel == void 0 || widthText < xFirstMajorLabel) {
                  this._repaintMajorText(0, leftText, orientation, className);
                }
              }
              util.forEach(this.dom.redundant, function(arr) {
                while (arr.length) {
                  var elem = arr.pop();
                  if (elem && elem.parentNode) {
                    elem.parentNode.removeChild(elem);
                  }
                }
              });
            };
            TimeAxis.prototype._repaintMinorText = function(x, text, orientation, className) {
              var label = this.dom.redundant.minorTexts.shift();
              if (!label) {
                var content = document.createTextNode("");
                label = document.createElement("div");
                label.appendChild(content);
                this.dom.foreground.appendChild(label);
              }
              this.dom.minorTexts.push(label);
              label.innerHTML = text;
              label.style.top = orientation == "top" ? this.props.majorLabelHeight + "px" : "0";
              if (this.options.rtl) {
                label.style.left = "";
                label.style.right = x + "px";
              } else {
                label.style.left = x + "px";
              }
              label.className = "vis-text vis-minor " + className;
              return label;
            };
            TimeAxis.prototype._repaintMajorText = function(x, text, orientation, className) {
              var label = this.dom.redundant.majorTexts.shift();
              if (!label) {
                var content = document.createElement("div");
                label = document.createElement("div");
                label.appendChild(content);
                this.dom.foreground.appendChild(label);
              }
              label.childNodes[0].innerHTML = text;
              label.className = "vis-text vis-major " + className;
              label.style.top = orientation == "top" ? "0" : this.props.minorLabelHeight + "px";
              if (this.options.rtl) {
                label.style.left = "";
                label.style.right = x + "px";
              } else {
                label.style.left = x + "px";
              }
              this.dom.majorTexts.push(label);
              return label;
            };
            TimeAxis.prototype._repaintMinorLine = function(x, width, orientation, className) {
              var line = this.dom.redundant.lines.shift();
              if (!line) {
                line = document.createElement("div");
                this.dom.background.appendChild(line);
              }
              this.dom.lines.push(line);
              var props = this.props;
              if (orientation == "top") {
                line.style.top = props.majorLabelHeight + "px";
              } else {
                line.style.top = this.body.domProps.top.height + "px";
              }
              line.style.height = props.minorLineHeight + "px";
              if (this.options.rtl) {
                line.style.left = "";
                line.style.right = x - props.minorLineWidth / 2 + "px";
                line.className = "vis-grid vis-vertical-rtl vis-minor " + className;
              } else {
                line.style.left = x - props.minorLineWidth / 2 + "px";
                line.className = "vis-grid vis-vertical vis-minor " + className;
              }
              line.style.width = width + "px";
              return line;
            };
            TimeAxis.prototype._repaintMajorLine = function(x, width, orientation, className) {
              var line = this.dom.redundant.lines.shift();
              if (!line) {
                line = document.createElement("div");
                this.dom.background.appendChild(line);
              }
              this.dom.lines.push(line);
              var props = this.props;
              if (orientation == "top") {
                line.style.top = "0";
              } else {
                line.style.top = this.body.domProps.top.height + "px";
              }
              if (this.options.rtl) {
                line.style.left = "";
                line.style.right = x - props.majorLineWidth / 2 + "px";
                line.className = "vis-grid vis-vertical-rtl vis-major " + className;
              } else {
                line.style.left = x - props.majorLineWidth / 2 + "px";
                line.className = "vis-grid vis-vertical vis-major " + className;
              }
              line.style.height = props.majorLineHeight + "px";
              line.style.width = width + "px";
              return line;
            };
            TimeAxis.prototype._calculateCharSize = function() {
              if (!this.dom.measureCharMinor) {
                this.dom.measureCharMinor = document.createElement("DIV");
                this.dom.measureCharMinor.className = "vis-text vis-minor vis-measure";
                this.dom.measureCharMinor.style.position = "absolute";
                this.dom.measureCharMinor.appendChild(document.createTextNode("0"));
                this.dom.foreground.appendChild(this.dom.measureCharMinor);
              }
              this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
              this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;
              if (!this.dom.measureCharMajor) {
                this.dom.measureCharMajor = document.createElement("DIV");
                this.dom.measureCharMajor.className = "vis-text vis-major vis-measure";
                this.dom.measureCharMajor.style.position = "absolute";
                this.dom.measureCharMajor.appendChild(document.createTextNode("0"));
                this.dom.foreground.appendChild(this.dom.measureCharMajor);
              }
              this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
              this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
            };
            var warnedForOverflow = false;
            module2.exports = TimeAxis;
          },
          /* 46 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Hammer = __webpack_require__(10);
            var util = __webpack_require__(2);
            var Component = __webpack_require__(16);
            var moment = __webpack_require__(9);
            var locales = __webpack_require__(98);
            function CustomTime(body, options) {
              this.body = body;
              this.defaultOptions = {
                moment,
                locales,
                locale: "en",
                id: void 0,
                title: void 0
              };
              this.options = util.extend({}, this.defaultOptions);
              if (options && options.time) {
                this.customTime = options.time;
              } else {
                this.customTime = /* @__PURE__ */ new Date();
              }
              this.eventParams = {};
              this.setOptions(options);
              this._create();
            }
            CustomTime.prototype = new Component();
            CustomTime.prototype.setOptions = function(options) {
              if (options) {
                util.selectiveExtend(["moment", "locale", "locales", "id"], this.options, options);
              }
            };
            CustomTime.prototype._create = function() {
              var bar = document.createElement("div");
              bar["custom-time"] = this;
              bar.className = "vis-custom-time " + (this.options.id || "");
              bar.style.position = "absolute";
              bar.style.top = "0px";
              bar.style.height = "100%";
              this.bar = bar;
              var drag = document.createElement("div");
              drag.style.position = "relative";
              drag.style.top = "0px";
              drag.style.left = "-10px";
              drag.style.height = "100%";
              drag.style.width = "20px";
              function onMouseWheel(e) {
                this.body.range._onMouseWheel(e);
              }
              if (drag.addEventListener) {
                drag.addEventListener("mousewheel", onMouseWheel.bind(this), false);
                drag.addEventListener("DOMMouseScroll", onMouseWheel.bind(this), false);
              } else {
                drag.attachEvent("onmousewheel", onMouseWheel.bind(this));
              }
              bar.appendChild(drag);
              this.hammer = new Hammer(drag);
              this.hammer.on("panstart", this._onDragStart.bind(this));
              this.hammer.on("panmove", this._onDrag.bind(this));
              this.hammer.on("panend", this._onDragEnd.bind(this));
              this.hammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
            };
            CustomTime.prototype.destroy = function() {
              this.hide();
              this.hammer.destroy();
              this.hammer = null;
              this.body = null;
            };
            CustomTime.prototype.redraw = function() {
              var parent = this.body.dom.backgroundVertical;
              if (this.bar.parentNode != parent) {
                if (this.bar.parentNode) {
                  this.bar.parentNode.removeChild(this.bar);
                }
                parent.appendChild(this.bar);
              }
              var x = this.body.util.toScreen(this.customTime);
              var locale = this.options.locales[this.options.locale];
              if (!locale) {
                if (!this.warned) {
                  console.log("WARNING: options.locales['" + this.options.locale + "'] not found. See http://visjs.org/docs/timeline/#Localization");
                  this.warned = true;
                }
                locale = this.options.locales["en"];
              }
              var title = this.options.title;
              if (title === void 0) {
                title = locale.time + ": " + this.options.moment(this.customTime).format("dddd, MMMM Do YYYY, H:mm:ss");
                title = title.charAt(0).toUpperCase() + title.substring(1);
              } else if (typeof title === "function") {
                title = title.call(this.customTime);
              }
              this.bar.style.left = x + "px";
              this.bar.title = title;
              return false;
            };
            CustomTime.prototype.hide = function() {
              if (this.bar.parentNode) {
                this.bar.parentNode.removeChild(this.bar);
              }
            };
            CustomTime.prototype.setCustomTime = function(time) {
              this.customTime = util.convert(time, "Date");
              this.redraw();
            };
            CustomTime.prototype.getCustomTime = function() {
              return new Date(this.customTime.valueOf());
            };
            CustomTime.prototype.setCustomTitle = function(title) {
              this.options.title = title;
            };
            CustomTime.prototype._onDragStart = function(event) {
              this.eventParams.dragging = true;
              this.eventParams.customTime = this.customTime;
              event.stopPropagation();
            };
            CustomTime.prototype._onDrag = function(event) {
              if (!this.eventParams.dragging) return;
              var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
              var time = this.body.util.toTime(x);
              this.setCustomTime(time);
              this.body.emitter.emit("timechange", {
                id: this.options.id,
                time: new Date(this.customTime.valueOf()),
                event
              });
              event.stopPropagation();
            };
            CustomTime.prototype._onDragEnd = function(event) {
              if (!this.eventParams.dragging) return;
              this.body.emitter.emit("timechanged", {
                id: this.options.id,
                time: new Date(this.customTime.valueOf()),
                event
              });
              event.stopPropagation();
            };
            CustomTime.customTimeFromTarget = function(event) {
              var target = event.target;
              while (target) {
                if (target.hasOwnProperty("custom-time")) {
                  return target["custom-time"];
                }
                target = target.parentNode;
              }
              return null;
            };
            module2.exports = CustomTime;
          },
          /* 47 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Label = __webpack_require__(117)["default"];
            var ComponentUtil = __webpack_require__(48)["default"];
            var Box = __webpack_require__(193)["default"];
            var Circle = __webpack_require__(200)["default"];
            var CircularImage = __webpack_require__(201)["default"];
            var Database = __webpack_require__(202)["default"];
            var Diamond = __webpack_require__(203)["default"];
            var Dot = __webpack_require__(204)["default"];
            var Ellipse = __webpack_require__(205)["default"];
            var Icon = __webpack_require__(206)["default"];
            var Image2 = __webpack_require__(207)["default"];
            var Square = __webpack_require__(208)["default"];
            var Hexagon = __webpack_require__(209)["default"];
            var Star = __webpack_require__(210)["default"];
            var Text = __webpack_require__(211)["default"];
            var Triangle = __webpack_require__(212)["default"];
            var TriangleDown = __webpack_require__(213)["default"];
            var _require = __webpack_require__(15), printStyle = _require.printStyle;
            var Node = function() {
              function Node2(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Node2);
                this.options = util.bridgeObject(globalOptions);
                this.globalOptions = globalOptions;
                this.defaultOptions = defaultOptions;
                this.body = body;
                this.edges = [];
                this.id = void 0;
                this.imagelist = imagelist;
                this.grouplist = grouplist;
                this.x = void 0;
                this.y = void 0;
                this.baseSize = this.options.size;
                this.baseFontSize = this.options.font.size;
                this.predefinedPosition = false;
                this.selected = false;
                this.hover = false;
                this.labelModule = new Label(
                  this.body,
                  this.options,
                  false
                  /* Not edge label */
                );
                this.setOptions(options);
              }
              (0, _createClass3["default"])(Node2, [{
                key: "attachEdge",
                value: function attachEdge(edge) {
                  if (this.edges.indexOf(edge) === -1) {
                    this.edges.push(edge);
                  }
                }
                /**
                 * Detach a edge from the node
                 *
                 * @param {Edge} edge
                 */
              }, {
                key: "detachEdge",
                value: function detachEdge(edge) {
                  var index = this.edges.indexOf(edge);
                  if (index != -1) {
                    this.edges.splice(index, 1);
                  }
                }
                /**
                 * Set or overwrite options for the node
                 *
                 * @param {Object} options an object with options
                 * @returns {null|boolean}
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  var currentShape = this.options.shape;
                  if (!options) {
                    return;
                  }
                  if (options.id !== void 0) {
                    this.id = options.id;
                  }
                  if (this.id === void 0) {
                    throw new Error("Node must have an id");
                  }
                  Node2.checkMass(options, this.id);
                  if (options.x !== void 0) {
                    if (options.x === null) {
                      this.x = void 0;
                      this.predefinedPosition = false;
                    } else {
                      this.x = parseInt(options.x);
                      this.predefinedPosition = true;
                    }
                  }
                  if (options.y !== void 0) {
                    if (options.y === null) {
                      this.y = void 0;
                      this.predefinedPosition = false;
                    } else {
                      this.y = parseInt(options.y);
                      this.predefinedPosition = true;
                    }
                  }
                  if (options.size !== void 0) {
                    this.baseSize = options.size;
                  }
                  if (options.value !== void 0) {
                    options.value = parseFloat(options.value);
                  }
                  Node2.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);
                  var pile = [options, this.options, this.defaultOptions];
                  this.chooser = ComponentUtil.choosify("node", pile);
                  this._load_images();
                  this.updateLabelModule(options);
                  this.updateShape(currentShape);
                  return options.hidden !== void 0 || options.physics !== void 0;
                }
                /**
                 * Load the images from the options, for the nodes that need them.
                 *
                 * TODO: The imageObj members should be moved to CircularImageBase.
                 *       It's the only place where they are required.
                 *
                 * @private
                 */
              }, {
                key: "_load_images",
                value: function _load_images() {
                  if (this.options.shape !== "circularImage" && this.options.shape !== "image") {
                    return;
                  }
                  if (this.options.image === void 0) {
                    throw new Error("Option image must be defined for node type '" + this.options.shape + "'");
                  }
                  if (this.imagelist === void 0) {
                    throw new Error("Internal Error: No images provided");
                  }
                  if (typeof this.options.image === "string") {
                    this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);
                  } else {
                    if (this.options.image.unselected === void 0) {
                      throw new Error("No unselected image provided");
                    }
                    this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);
                    if (this.options.image.selected !== void 0) {
                      this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);
                    } else {
                      this.imageObjAlt = void 0;
                    }
                  }
                }
                /**
                 * Copy group option values into the node options.
                 *
                 * The group options override the global node options, so the copy of group options
                 *  must happen *after* the global node options have been set.
                 *
                 * This method must also be called also if the global node options have changed and the group options did not.
                 *
                 * @param {Object} parentOptions
                 * @param {Object} newOptions  new values for the options, currently only passed in for check
                 * @param {Object} groupList
                 */
              }, {
                key: "getFormattingValues",
                /**
                 *
                 * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
                 */
                value: function getFormattingValues() {
                  var values = {
                    color: this.options.color.background,
                    borderWidth: this.options.borderWidth,
                    borderColor: this.options.color.border,
                    size: this.options.size,
                    borderDashes: this.options.shapeProperties.borderDashes,
                    borderRadius: this.options.shapeProperties.borderRadius,
                    shadow: this.options.shadow.enabled,
                    shadowColor: this.options.shadow.color,
                    shadowSize: this.options.shadow.size,
                    shadowX: this.options.shadow.x,
                    shadowY: this.options.shadow.y
                  };
                  if (this.selected || this.hover) {
                    if (this.chooser === true) {
                      if (this.selected) {
                        values.borderWidth *= 2;
                        values.color = this.options.color.highlight.background;
                        values.borderColor = this.options.color.highlight.border;
                        values.shadow = this.options.shadow.enabled;
                      } else if (this.hover) {
                        values.color = this.options.color.hover.background;
                        values.borderColor = this.options.color.hover.border;
                        values.shadow = this.options.shadow.enabled;
                      }
                    } else if (typeof this.chooser === "function") {
                      this.chooser(values, this.options.id, this.selected, this.hover);
                      if (values.shadow === false) {
                        if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
                          values.shadow = true;
                        }
                      }
                    }
                  } else {
                    values.shadow = this.options.shadow.enabled;
                  }
                  return values;
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "updateLabelModule",
                value: function updateLabelModule(options) {
                  if (this.options.label === void 0 || this.options.label === null) {
                    this.options.label = "";
                  }
                  Node2.updateGroupOptions(this.options, options, this.grouplist);
                  var currentGroup = this.grouplist.get(this.options.group, false);
                  var pile = [
                    options,
                    // new options
                    this.options,
                    // current node options, see comment above for prototype
                    currentGroup,
                    // group options, if any
                    this.globalOptions,
                    // Currently set global node options
                    this.defaultOptions
                    // Default global node options
                  ];
                  this.labelModule.update(this.options, pile);
                  if (this.labelModule.baseSize !== void 0) {
                    this.baseFontSize = this.labelModule.baseSize;
                  }
                }
                /**
                 *
                 * @param {string} currentShape
                 */
              }, {
                key: "updateShape",
                value: function updateShape(currentShape) {
                  if (currentShape === this.options.shape && this.shape) {
                    this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);
                  } else {
                    switch (this.options.shape) {
                      case "box":
                        this.shape = new Box(this.options, this.body, this.labelModule);
                        break;
                      case "circle":
                        this.shape = new Circle(this.options, this.body, this.labelModule);
                        break;
                      case "circularImage":
                        this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                        break;
                      case "database":
                        this.shape = new Database(this.options, this.body, this.labelModule);
                        break;
                      case "diamond":
                        this.shape = new Diamond(this.options, this.body, this.labelModule);
                        break;
                      case "dot":
                        this.shape = new Dot(this.options, this.body, this.labelModule);
                        break;
                      case "ellipse":
                        this.shape = new Ellipse(this.options, this.body, this.labelModule);
                        break;
                      case "icon":
                        this.shape = new Icon(this.options, this.body, this.labelModule);
                        break;
                      case "image":
                        this.shape = new Image2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);
                        break;
                      case "square":
                        this.shape = new Square(this.options, this.body, this.labelModule);
                        break;
                      case "hexagon":
                        this.shape = new Hexagon(this.options, this.body, this.labelModule);
                        break;
                      case "star":
                        this.shape = new Star(this.options, this.body, this.labelModule);
                        break;
                      case "text":
                        this.shape = new Text(this.options, this.body, this.labelModule);
                        break;
                      case "triangle":
                        this.shape = new Triangle(this.options, this.body, this.labelModule);
                        break;
                      case "triangleDown":
                        this.shape = new TriangleDown(this.options, this.body, this.labelModule);
                        break;
                      default:
                        this.shape = new Ellipse(this.options, this.body, this.labelModule);
                        break;
                    }
                  }
                  this.needsRefresh();
                }
                /**
                 * select this node
                 */
              }, {
                key: "select",
                value: function select() {
                  this.selected = true;
                  this.needsRefresh();
                }
                /**
                 * unselect this node
                 */
              }, {
                key: "unselect",
                value: function unselect() {
                  this.selected = false;
                  this.needsRefresh();
                }
                /**
                 * Reset the calculated size of the node, forces it to recalculate its size
                 */
              }, {
                key: "needsRefresh",
                value: function needsRefresh() {
                  this.shape.refreshNeeded = true;
                }
                /**
                 * get the title of this node.
                 * @return {string} title    The title of the node, or undefined when no title
                 *                           has been set.
                 */
              }, {
                key: "getTitle",
                value: function getTitle() {
                  return this.options.title;
                }
                /**
                 * Calculate the distance to the border of the Node
                 * @param {CanvasRenderingContext2D}   ctx
                 * @param {number} angle        Angle in radians
                 * @returns {number} distance   Distance to the border in pixels
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this.shape.distanceToBorder(ctx, angle);
                }
                /**
                 * Check if this node has a fixed x and y position
                 * @return {boolean}      true if fixed, false if not
                 */
              }, {
                key: "isFixed",
                value: function isFixed() {
                  return this.options.fixed.x && this.options.fixed.y;
                }
                /**
                 * check if this node is selecte
                 * @return {boolean} selected   True if node is selected, else false
                 */
              }, {
                key: "isSelected",
                value: function isSelected() {
                  return this.selected;
                }
                /**
                 * Retrieve the value of the node. Can be undefined
                 * @return {number} value
                 */
              }, {
                key: "getValue",
                value: function getValue() {
                  return this.options.value;
                }
                /**
                 * Get the current dimensions of the label
                 *
                 * @return {rect}
                 */
              }, {
                key: "getLabelSize",
                value: function getLabelSize() {
                  return this.labelModule.size();
                }
                /**
                 * Adjust the value range of the node. The node will adjust it's size
                 * based on its value.
                 * @param {number} min
                 * @param {number} max
                 * @param {number} total
                 */
              }, {
                key: "setValueRange",
                value: function setValueRange(min, max, total) {
                  if (this.options.value !== void 0) {
                    var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
                    var sizeDiff = this.options.scaling.max - this.options.scaling.min;
                    if (this.options.scaling.label.enabled === true) {
                      var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
                      this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
                    }
                    this.options.size = this.options.scaling.min + scale * sizeDiff;
                  } else {
                    this.options.size = this.baseSize;
                    this.options.font.size = this.baseFontSize;
                  }
                  this.updateLabelModule();
                }
                /**
                 * Draw this node in the given canvas
                 * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
                 * @param {CanvasRenderingContext2D}   ctx
                 */
              }, {
                key: "draw",
                value: function draw(ctx) {
                  var values = this.getFormattingValues();
                  this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values);
                }
                /**
                 * Update the bounding box of the shape
                 * @param {CanvasRenderingContext2D}   ctx
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(ctx) {
                  this.shape.updateBoundingBox(this.x, this.y, ctx);
                }
                /**
                 * Recalculate the size of this node in the given canvas
                 * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
                 * @param {CanvasRenderingContext2D}   ctx
                 */
              }, {
                key: "resize",
                value: function resize(ctx) {
                  var values = this.getFormattingValues();
                  this.shape.resize(ctx, this.selected, this.hover, values);
                }
                /**
                 * Determine all visual elements of this node instance, in which the given
                 * point falls within the bounding shape.
                 *
                 * @param {point} point
                 * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
                 */
              }, {
                key: "getItemsOnPoint",
                value: function getItemsOnPoint(point) {
                  var ret = [];
                  if (this.labelModule.visible()) {
                    if (ComponentUtil.pointInRect(this.labelModule.getSize(), point)) {
                      ret.push({ nodeId: this.id, labelId: 0 });
                    }
                  }
                  if (ComponentUtil.pointInRect(this.shape.boundingBox, point)) {
                    ret.push({ nodeId: this.id });
                  }
                  return ret;
                }
                /**
                 * Check if this object is overlapping with the provided object
                 * @param {Object} obj   an object with parameters left, top, right, bottom
                 * @return {boolean}     True if location is located on node
                 */
              }, {
                key: "isOverlappingWith",
                value: function isOverlappingWith(obj) {
                  return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;
                }
                /**
                 * Check if this object is overlapping with the provided object
                 * @param {Object} obj   an object with parameters left, top, right, bottom
                 * @return {boolean}     True if location is located on node
                 */
              }, {
                key: "isBoundingBoxOverlappingWith",
                value: function isBoundingBoxOverlappingWith(obj) {
                  return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;
                }
                /**
                * Check valid values for mass
                *
                * The mass may not be negative or zero. If it is, reset to 1
                *
                * @param {object} options
                * @param {Node.id} id
                 * @static
                */
              }], [{
                key: "updateGroupOptions",
                value: function updateGroupOptions(parentOptions, newOptions, groupList) {
                  if (groupList === void 0) return;
                  var group = parentOptions.group;
                  if (newOptions !== void 0 && newOptions.group !== void 0 && group !== newOptions.group) {
                    throw new Error("updateGroupOptions: group values in options don't match.");
                  }
                  var hasGroup = typeof group === "number" || typeof group === "string" && group != "";
                  if (!hasGroup) return;
                  var groupObj = groupList.get(group);
                  util.selectiveNotDeepExtend(["font"], parentOptions, groupObj);
                  parentOptions.color = util.parseColor(parentOptions.color);
                }
                /**
                 * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
                 * Static so it can also be used by the handler.
                 *
                 * @param {Object} parentOptions
                 * @param {Object} newOptions
                 * @param {boolean} [allowDeletion=false]
                 * @param {Object} [globalOptions={}]
                 * @param {Object} [groupList]
                 * @static
                 */
              }, {
                key: "parseOptions",
                value: function parseOptions(parentOptions, newOptions) {
                  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  var groupList = arguments[4];
                  var fields = ["color", "fixed", "shadow"];
                  util.selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);
                  Node2.checkMass(newOptions);
                  util.mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
                  if (newOptions.color !== void 0 && newOptions.color !== null) {
                    var parsedColor = util.parseColor(newOptions.color);
                    util.fillIfDefined(parentOptions.color, parsedColor);
                  } else if (allowDeletion === true && newOptions.color === null) {
                    parentOptions.color = util.bridgeObject(globalOptions.color);
                  }
                  if (newOptions.fixed !== void 0 && newOptions.fixed !== null) {
                    if (typeof newOptions.fixed === "boolean") {
                      parentOptions.fixed.x = newOptions.fixed;
                      parentOptions.fixed.y = newOptions.fixed;
                    } else {
                      if (newOptions.fixed.x !== void 0 && typeof newOptions.fixed.x === "boolean") {
                        parentOptions.fixed.x = newOptions.fixed.x;
                      }
                      if (newOptions.fixed.y !== void 0 && typeof newOptions.fixed.y === "boolean") {
                        parentOptions.fixed.y = newOptions.fixed.y;
                      }
                    }
                  }
                  if (allowDeletion === true && newOptions.font === null) {
                    parentOptions.font = util.bridgeObject(globalOptions.font);
                  }
                  Node2.updateGroupOptions(parentOptions, newOptions, groupList);
                  if (newOptions.scaling !== void 0) {
                    util.mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
                  }
                }
              }, {
                key: "checkMass",
                value: function checkMass(options, id) {
                  if (options.mass !== void 0 && options.mass <= 0) {
                    var strId = "";
                    if (id !== void 0) {
                      strId = " in node id: " + id;
                    }
                    console.log("%cNegative or zero mass disallowed" + strId + ", setting mass to 1.", printStyle);
                    options.mass = 1;
                  }
                }
              }]);
              return Node2;
            }();
            exports2["default"] = Node;
          },
          /* 48 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ComponentUtil = function() {
              function ComponentUtil2() {
                (0, _classCallCheck3["default"])(this, ComponentUtil2);
              }
              (0, _createClass3["default"])(ComponentUtil2, null, [{
                key: "choosify",
                /**
                 * Determine values to use for (sub)options of 'chosen'.
                 *
                 * This option is either a boolean or an object whose values should be examined further.
                 * The relevant structures are:
                 *
                 * - chosen: <boolean value>
                 * - chosen: { subOption: <boolean or function> }
                 *
                 * Where subOption is 'node', 'edge' or 'label'.
                 *
                 * The intention of this method appears to be to set a specific priority to the options;
                 * Since most properties are either bridged or merged into the local options objects, there
                 * is not much point in handling them separately.
                 * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
                 *       should be able to get rid of this method.
                 *
                 * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
                 * @param {Object}  pile       array of options objects to consider
                 * 
                 * @return {boolean|function}  value for passed subOption of 'chosen' to use
                 */
                value: function choosify(subOption, pile) {
                  var allowed = ["node", "edge", "label"];
                  var value = true;
                  var chosen = util.topMost(pile, "chosen");
                  if (typeof chosen === "boolean") {
                    value = chosen;
                  } else if ((typeof chosen === "undefined" ? "undefined" : (0, _typeof3["default"])(chosen)) === "object") {
                    if (allowed.indexOf(subOption) === -1) {
                      throw new Error("choosify: subOption '" + subOption + "' should be one of '" + allowed.join("', '") + "'");
                    }
                    var chosenEdge = util.topMost(pile, ["chosen", subOption]);
                    if (typeof chosenEdge === "boolean" || typeof chosenEdge === "function") {
                      value = chosenEdge;
                    }
                  }
                  return value;
                }
                /**
                 * Check if the point falls within the given rectangle.
                 *
                 * @param {rect} rect
                 * @param {point} point
                 * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
                 * @returns {boolean}  true if point within rectangle, false otherwise
                 * @static
                 */
              }, {
                key: "pointInRect",
                value: function pointInRect(rect, point, rotationPoint) {
                  if (rect.width <= 0 || rect.height <= 0) {
                    return false;
                  }
                  if (rotationPoint !== void 0) {
                    var tmp = {
                      x: point.x - rotationPoint.x,
                      y: point.y - rotationPoint.y
                    };
                    if (rotationPoint.angle !== 0) {
                      var angle = -rotationPoint.angle;
                      var tmp2 = {
                        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,
                        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y
                      };
                      point = tmp2;
                    } else {
                      point = tmp;
                    }
                  }
                  var right = rect.x + rect.width;
                  var bottom = rect.y + rect.width;
                  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;
                }
                /**
                 * Check if given value is acceptable as a label text.
                 *
                 * @param {*} text value to check; can be anything at this point
                 * @returns {boolean} true if valid label value, false otherwise
                 */
              }, {
                key: "isValidLabel",
                value: function isValidLabel(text) {
                  return typeof text === "string" && text !== "";
                }
              }]);
              return ComponentUtil2;
            }();
            exports2["default"] = ComponentUtil;
          },
          /* 49 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(125);
            var global = __webpack_require__(18);
            var hide = __webpack_require__(26);
            var Iterators = __webpack_require__(31);
            var TO_STRING_TAG = __webpack_require__(13)("toStringTag");
            var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
            for (var i = 0; i < DOMIterables.length; i++) {
              var NAME = DOMIterables[i];
              var Collection = global[NAME];
              var proto = Collection && Collection.prototype;
              if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
              Iterators[NAME] = Iterators.Array;
            }
          },
          /* 50 */
          /***/
          function(module2, exports2) {
            var toString = {}.toString;
            module2.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          /* 51 */
          /***/
          function(module2, exports2) {
            module2.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          /* 52 */
          /***/
          function(module2, exports2) {
            module2.exports = true;
          },
          /* 53 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject = __webpack_require__(32);
            module2.exports = function(it, S) {
              if (!isObject(it)) return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          /* 54 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(27);
            var dPs = __webpack_require__(130);
            var enumBugKeys = __webpack_require__(58);
            var IE_PROTO = __webpack_require__(56)("IE_PROTO");
            var Empty = function() {
            };
            var PROTOTYPE = "prototype";
            var createDict = function() {
              var iframe = __webpack_require__(82)("iframe");
              var i = enumBugKeys.length;
              var lt = "<";
              var gt = ">";
              var iframeDocument;
              iframe.style.display = "none";
              __webpack_require__(134).appendChild(iframe);
              iframe.src = "javascript:";
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
              iframeDocument.close();
              createDict = iframeDocument.F;
              while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
              return createDict();
            };
            module2.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result = new Empty();
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else result = createDict();
              return Properties === void 0 ? result : dPs(result, Properties);
            };
          },
          /* 55 */
          /***/
          function(module2, exports2) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          /* 56 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var shared = __webpack_require__(57)("keys");
            var uid = __webpack_require__(40);
            module2.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          /* 57 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global = __webpack_require__(18);
            var SHARED = "__core-js_shared__";
            var store = global[SHARED] || (global[SHARED] = {});
            module2.exports = function(key) {
              return store[key] || (store[key] = {});
            };
          },
          /* 58 */
          /***/
          function(module2, exports2) {
            module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          /* 59 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var def = __webpack_require__(20).f;
            var has = __webpack_require__(22);
            var TAG = __webpack_require__(13)("toStringTag");
            module2.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
            };
          },
          /* 60 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var $at = __webpack_require__(135)(true);
            __webpack_require__(79)(String, "String", function(iterated) {
              this._t = String(iterated);
              this._i = 0;
            }, function() {
              var O = this._t;
              var index = this._i;
              var point;
              if (index >= O.length) return { value: void 0, done: true };
              point = $at(O, index);
              this._i += point.length;
              return { value: point, done: false };
            });
          },
          /* 61 */
          /***/
          function(module2, exports2, __webpack_require__) {
            exports2.f = __webpack_require__(13);
          },
          /* 62 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global = __webpack_require__(18);
            var core = __webpack_require__(7);
            var LIBRARY = __webpack_require__(52);
            var wksExt = __webpack_require__(61);
            var defineProperty = __webpack_require__(20).f;
            module2.exports = function(name) {
              var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
              if (name.charAt(0) != "_" && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
            };
          },
          /* 63 */
          /***/
          function(module2, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          },
          /* 64 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var moment = __webpack_require__(9);
            var Component = __webpack_require__(16);
            var DateUtil = __webpack_require__(36);
            function Range(body, options) {
              var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
              var start = now.clone().add(-3, "days").valueOf();
              var end = now.clone().add(3, "days").valueOf();
              this.millisecondsPerPixelCache = void 0;
              if (options === void 0) {
                this.start = start;
                this.end = end;
              } else {
                this.start = options.start || start;
                this.end = options.end || end;
              }
              this.rolling = false;
              this.body = body;
              this.deltaDifference = 0;
              this.scaleOffset = 0;
              this.startToFront = false;
              this.endToFront = true;
              this.defaultOptions = {
                rtl: false,
                start: null,
                end: null,
                moment,
                direction: "horizontal",
                // 'horizontal' or 'vertical'
                moveable: true,
                zoomable: true,
                min: null,
                max: null,
                zoomMin: 10,
                // milliseconds
                zoomMax: 1e3 * 60 * 60 * 24 * 365 * 1e4,
                // milliseconds
                rollingMode: {
                  follow: false,
                  offset: 0.5
                }
              };
              this.options = util.extend({}, this.defaultOptions);
              this.props = {
                touch: {}
              };
              this.animationTimer = null;
              this.body.emitter.on("panstart", this._onDragStart.bind(this));
              this.body.emitter.on("panmove", this._onDrag.bind(this));
              this.body.emitter.on("panend", this._onDragEnd.bind(this));
              this.body.emitter.on("mousewheel", this._onMouseWheel.bind(this));
              this.body.emitter.on("touch", this._onTouch.bind(this));
              this.body.emitter.on("pinch", this._onPinch.bind(this));
              this.body.dom.rollingModeBtn.addEventListener("click", this.startRolling.bind(this));
              this.setOptions(options);
            }
            Range.prototype = new Component();
            Range.prototype.setOptions = function(options) {
              if (options) {
                var fields = ["animation", "direction", "min", "max", "zoomMin", "zoomMax", "moveable", "zoomable", "moment", "activate", "hiddenDates", "zoomKey", "rtl", "showCurrentTime", "rollingMode", "horizontalScroll"];
                util.selectiveExtend(fields, this.options, options);
                if (options.rollingMode && options.rollingMode.follow) {
                  this.startRolling();
                }
                if ("start" in options || "end" in options) {
                  this.setRange(options.start, options.end);
                }
              }
            };
            function validateDirection(direction) {
              if (direction != "horizontal" && direction != "vertical") {
                throw new TypeError('Unknown direction "' + direction + '". Choose "horizontal" or "vertical".');
              }
            }
            Range.prototype.startRolling = function() {
              var me = this;
              function update() {
                me.stopRolling();
                me.rolling = true;
                var interval = me.end - me.start;
                var t = util.convert(/* @__PURE__ */ new Date(), "Date").valueOf();
                var start = t - interval * me.options.rollingMode.offset;
                var end = t + interval * (1 - me.options.rollingMode.offset);
                var options = {
                  animation: false
                };
                me.setRange(start, end, options);
                var scale = me.conversion(me.body.domProps.center.width).scale;
                interval = 1 / scale / 10;
                if (interval < 30) interval = 30;
                if (interval > 1e3) interval = 1e3;
                me.body.dom.rollingModeBtn.style.visibility = "hidden";
                me.currentTimeTimer = setTimeout(update, interval);
              }
              update();
            };
            Range.prototype.stopRolling = function() {
              if (this.currentTimeTimer !== void 0) {
                clearTimeout(this.currentTimeTimer);
                this.rolling = false;
                this.body.dom.rollingModeBtn.style.visibility = "visible";
              }
            };
            Range.prototype.setRange = function(start, end, options, callback, frameCallback) {
              if (!options) {
                options = {};
              }
              if (options.byUser !== true) {
                options.byUser = false;
              }
              var me = this;
              var finalStart = start != void 0 ? util.convert(start, "Date").valueOf() : null;
              var finalEnd = end != void 0 ? util.convert(end, "Date").valueOf() : null;
              this._cancelAnimation();
              this.millisecondsPerPixelCache = void 0;
              if (options.animation) {
                var initStart = this.start;
                var initEnd = this.end;
                var duration = (0, _typeof3["default"])(options.animation) === "object" && "duration" in options.animation ? options.animation.duration : 500;
                var easingName = (0, _typeof3["default"])(options.animation) === "object" && "easingFunction" in options.animation ? options.animation.easingFunction : "easeInOutQuad";
                var easingFunction = util.easingFunctions[easingName];
                if (!easingFunction) {
                  throw new Error("Unknown easing function " + (0, _stringify2["default"])(easingName) + ". Choose from: " + (0, _keys2["default"])(util.easingFunctions).join(", "));
                }
                var initTime = (/* @__PURE__ */ new Date()).valueOf();
                var anyChanged = false;
                var next = function next2() {
                  if (!me.props.touch.dragging) {
                    var now = (/* @__PURE__ */ new Date()).valueOf();
                    var time = now - initTime;
                    var ease = easingFunction(time / duration);
                    var done = time > duration;
                    var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
                    var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;
                    changed = me._applyRange(s, e);
                    DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
                    anyChanged = anyChanged || changed;
                    var params2 = {
                      start: new Date(me.start),
                      end: new Date(me.end),
                      byUser: options.byUser,
                      event: options.event
                    };
                    if (frameCallback) {
                      frameCallback(ease, changed, done);
                    }
                    if (changed) {
                      me.body.emitter.emit("rangechange", params2);
                    }
                    if (done) {
                      if (anyChanged) {
                        me.body.emitter.emit("rangechanged", params2);
                        if (callback) {
                          return callback();
                        }
                      }
                    } else {
                      me.animationTimer = setTimeout(next2, 20);
                    }
                  }
                };
                return next();
              } else {
                var changed = this._applyRange(finalStart, finalEnd);
                DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
                if (changed) {
                  var params = {
                    start: new Date(this.start),
                    end: new Date(this.end),
                    byUser: options.byUser,
                    event: options.event
                  };
                  this.body.emitter.emit("rangechange", params);
                  clearTimeout(me.timeoutID);
                  me.timeoutID = setTimeout(function() {
                    me.body.emitter.emit("rangechanged", params);
                  }, 200);
                  if (callback) {
                    return callback();
                  }
                }
              }
            };
            Range.prototype.getMillisecondsPerPixel = function() {
              if (this.millisecondsPerPixelCache === void 0) {
                this.millisecondsPerPixelCache = (this.end - this.start) / this.body.dom.center.clientWidth;
              }
              return this.millisecondsPerPixelCache;
            };
            Range.prototype._cancelAnimation = function() {
              if (this.animationTimer) {
                clearTimeout(this.animationTimer);
                this.animationTimer = null;
              }
            };
            Range.prototype._applyRange = function(start, end) {
              var newStart = start != null ? util.convert(start, "Date").valueOf() : this.start, newEnd = end != null ? util.convert(end, "Date").valueOf() : this.end, max = this.options.max != null ? util.convert(this.options.max, "Date").valueOf() : null, min = this.options.min != null ? util.convert(this.options.min, "Date").valueOf() : null, diff;
              if (isNaN(newStart) || newStart === null) {
                throw new Error('Invalid start "' + start + '"');
              }
              if (isNaN(newEnd) || newEnd === null) {
                throw new Error('Invalid end "' + end + '"');
              }
              if (newEnd < newStart) {
                newEnd = newStart;
              }
              if (min !== null) {
                if (newStart < min) {
                  diff = min - newStart;
                  newStart += diff;
                  newEnd += diff;
                  if (max != null) {
                    if (newEnd > max) {
                      newEnd = max;
                    }
                  }
                }
              }
              if (max !== null) {
                if (newEnd > max) {
                  diff = newEnd - max;
                  newStart -= diff;
                  newEnd -= diff;
                  if (min != null) {
                    if (newStart < min) {
                      newStart = min;
                    }
                  }
                }
              }
              if (this.options.zoomMin !== null) {
                var zoomMin = parseFloat(this.options.zoomMin);
                if (zoomMin < 0) {
                  zoomMin = 0;
                }
                if (newEnd - newStart < zoomMin) {
                  var compensation = 0.5;
                  if (this.end - this.start === zoomMin && newStart >= this.start - compensation && newEnd <= this.end) {
                    newStart = this.start;
                    newEnd = this.end;
                  } else {
                    diff = zoomMin - (newEnd - newStart);
                    newStart -= diff / 2;
                    newEnd += diff / 2;
                  }
                }
              }
              if (this.options.zoomMax !== null) {
                var zoomMax = parseFloat(this.options.zoomMax);
                if (zoomMax < 0) {
                  zoomMax = 0;
                }
                if (newEnd - newStart > zoomMax) {
                  if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
                    newStart = this.start;
                    newEnd = this.end;
                  } else {
                    diff = newEnd - newStart - zoomMax;
                    newStart += diff / 2;
                    newEnd -= diff / 2;
                  }
                }
              }
              var changed = this.start != newStart || this.end != newEnd;
              if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
                this.body.emitter.emit("checkRangedItems");
              }
              this.start = newStart;
              this.end = newEnd;
              return changed;
            };
            Range.prototype.getRange = function() {
              return {
                start: this.start,
                end: this.end
              };
            };
            Range.prototype.conversion = function(width, totalHidden) {
              return Range.conversion(this.start, this.end, width, totalHidden);
            };
            Range.conversion = function(start, end, width, totalHidden) {
              if (totalHidden === void 0) {
                totalHidden = 0;
              }
              if (width != 0 && end - start != 0) {
                return {
                  offset: start,
                  scale: width / (end - start - totalHidden)
                };
              } else {
                return {
                  offset: 0,
                  scale: 1
                };
              }
            };
            Range.prototype._onDragStart = function(event) {
              this.deltaDifference = 0;
              this.previousDelta = 0;
              if (!this.options.moveable) return;
              if (!this._isInsideRange(event)) return;
              if (!this.props.touch.allowDragging) return;
              this.stopRolling();
              this.props.touch.start = this.start;
              this.props.touch.end = this.end;
              this.props.touch.dragging = true;
              if (this.body.dom.root) {
                this.body.dom.root.style.cursor = "move";
              }
            };
            Range.prototype._onDrag = function(event) {
              if (!event) return;
              if (!this.props.touch.dragging) return;
              if (!this.options.moveable) return;
              if (!this.props.touch.allowDragging) return;
              var direction = this.options.direction;
              validateDirection(direction);
              var delta = direction == "horizontal" ? event.deltaX : event.deltaY;
              delta -= this.deltaDifference;
              var interval = this.props.touch.end - this.props.touch.start;
              var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
              interval -= duration;
              var width = direction == "horizontal" ? this.body.domProps.center.width : this.body.domProps.center.height;
              var diffRange;
              if (this.options.rtl) {
                diffRange = delta / width * interval;
              } else {
                diffRange = -delta / width * interval;
              }
              var newStart = this.props.touch.start + diffRange;
              var newEnd = this.props.touch.end + diffRange;
              var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
              var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
              if (safeStart != newStart || safeEnd != newEnd) {
                this.deltaDifference += delta;
                this.props.touch.start = safeStart;
                this.props.touch.end = safeEnd;
                this._onDrag(event);
                return;
              }
              this.previousDelta = delta;
              this._applyRange(newStart, newEnd);
              var startDate = new Date(this.start);
              var endDate = new Date(this.end);
              this.body.emitter.emit("rangechange", {
                start: startDate,
                end: endDate,
                byUser: true,
                event
              });
              this.body.emitter.emit("panmove");
            };
            Range.prototype._onDragEnd = function(event) {
              if (!this.props.touch.dragging) return;
              if (!this.options.moveable) return;
              if (!this.props.touch.allowDragging) return;
              this.props.touch.dragging = false;
              if (this.body.dom.root) {
                this.body.dom.root.style.cursor = "auto";
              }
              this.body.emitter.emit("rangechanged", {
                start: new Date(this.start),
                end: new Date(this.end),
                byUser: true,
                event
              });
            };
            Range.prototype._onMouseWheel = function(event) {
              var delta = 0;
              if (event.wheelDelta) {
                delta = event.wheelDelta / 120;
              } else if (event.detail) {
                delta = -event.detail / 3;
              }
              if (this.options.zoomKey && !event[this.options.zoomKey] && this.options.zoomable || !this.options.zoomable && this.options.moveable) {
                return;
              }
              if (!(this.options.zoomable && this.options.moveable)) return;
              if (!this._isInsideRange(event)) return;
              if (delta) {
                var scale;
                if (delta < 0) {
                  scale = 1 - delta / 5;
                } else {
                  scale = 1 / (1 + delta / 5);
                }
                var pointerDate;
                if (this.rolling) {
                  pointerDate = this.start + (this.end - this.start) * this.options.rollingMode.offset;
                } else {
                  var pointer = this.getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
                  pointerDate = this._pointerToDate(pointer);
                }
                this.zoom(scale, pointerDate, delta, event);
                event.preventDefault();
              }
            };
            Range.prototype._onTouch = function(event) {
              this.props.touch.start = this.start;
              this.props.touch.end = this.end;
              this.props.touch.allowDragging = true;
              this.props.touch.center = null;
              this.scaleOffset = 0;
              this.deltaDifference = 0;
              util.preventDefault(event);
            };
            Range.prototype._onPinch = function(event) {
              if (!(this.options.zoomable && this.options.moveable)) return;
              util.preventDefault(event);
              this.props.touch.allowDragging = false;
              if (!this.props.touch.center) {
                this.props.touch.center = this.getPointer(event.center, this.body.dom.center);
              }
              this.stopRolling();
              var scale = 1 / (event.scale + this.scaleOffset);
              var centerDate = this._pointerToDate(this.props.touch.center);
              var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
              var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
              var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;
              var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
              var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;
              this.startToFront = 1 - scale <= 0;
              this.endToFront = scale - 1 <= 0;
              var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
              var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
              if (safeStart != newStart || safeEnd != newEnd) {
                this.props.touch.start = safeStart;
                this.props.touch.end = safeEnd;
                this.scaleOffset = 1 - event.scale;
                newStart = safeStart;
                newEnd = safeEnd;
              }
              var options = {
                animation: false,
                byUser: true,
                event
              };
              this.setRange(newStart, newEnd, options);
              this.startToFront = false;
              this.endToFront = true;
            };
            Range.prototype._isInsideRange = function(event) {
              var clientX = event.center ? event.center.x : event.clientX;
              var x;
              if (this.options.rtl) {
                x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
              } else {
                x = util.getAbsoluteRight(this.body.dom.centerContainer) - clientX;
              }
              var time = this.body.util.toTime(x);
              return time >= this.start && time <= this.end;
            };
            Range.prototype._pointerToDate = function(pointer) {
              var conversion;
              var direction = this.options.direction;
              validateDirection(direction);
              if (direction == "horizontal") {
                return this.body.util.toTime(pointer.x).valueOf();
              } else {
                var height = this.body.domProps.center.height;
                conversion = this.conversion(height);
                return pointer.y / conversion.scale + conversion.offset;
              }
            };
            Range.prototype.getPointer = function(touch, element) {
              if (this.options.rtl) {
                return {
                  x: util.getAbsoluteRight(element) - touch.x,
                  y: touch.y - util.getAbsoluteTop(element)
                };
              } else {
                return {
                  x: touch.x - util.getAbsoluteLeft(element),
                  y: touch.y - util.getAbsoluteTop(element)
                };
              }
            };
            Range.prototype.zoom = function(scale, center, delta, event) {
              if (center == null) {
                center = (this.start + this.end) / 2;
              }
              var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
              var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
              var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;
              var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
              var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;
              this.startToFront = delta > 0 ? false : true;
              this.endToFront = -delta > 0 ? false : true;
              var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
              var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
              if (safeStart != newStart || safeEnd != newEnd) {
                newStart = safeStart;
                newEnd = safeEnd;
              }
              var options = {
                animation: false,
                byUser: true,
                event
              };
              this.setRange(newStart, newEnd, options);
              this.startToFront = false;
              this.endToFront = true;
            };
            Range.prototype.move = function(delta) {
              var diff = this.end - this.start;
              var newStart = this.start + diff * delta;
              var newEnd = this.end + diff * delta;
              this.start = newStart;
              this.end = newEnd;
            };
            Range.prototype.moveTo = function(moveTo) {
              var center = (this.start + this.end) / 2;
              var diff = center - moveTo;
              var newStart = this.start - diff;
              var newEnd = this.end - diff;
              var options = {
                animation: false,
                byUser: true,
                event: null
              };
              this.setRange(newStart, newEnd, options);
            };
            module2.exports = Range;
          },
          /* 65 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Emitter = __webpack_require__(44);
            var Hammer = __webpack_require__(10);
            var hammerUtil = __webpack_require__(37);
            var util = __webpack_require__(2);
            var TimeAxis = __webpack_require__(45);
            var Activator = __webpack_require__(97);
            var DateUtil = __webpack_require__(36);
            var CustomTime = __webpack_require__(46);
            function Core() {
            }
            Emitter(Core.prototype);
            Core.prototype._create = function(container) {
              this.dom = {};
              this.dom.container = container;
              this.dom.root = document.createElement("div");
              this.dom.background = document.createElement("div");
              this.dom.backgroundVertical = document.createElement("div");
              this.dom.backgroundHorizontal = document.createElement("div");
              this.dom.centerContainer = document.createElement("div");
              this.dom.leftContainer = document.createElement("div");
              this.dom.rightContainer = document.createElement("div");
              this.dom.center = document.createElement("div");
              this.dom.left = document.createElement("div");
              this.dom.right = document.createElement("div");
              this.dom.top = document.createElement("div");
              this.dom.bottom = document.createElement("div");
              this.dom.shadowTop = document.createElement("div");
              this.dom.shadowBottom = document.createElement("div");
              this.dom.shadowTopLeft = document.createElement("div");
              this.dom.shadowBottomLeft = document.createElement("div");
              this.dom.shadowTopRight = document.createElement("div");
              this.dom.shadowBottomRight = document.createElement("div");
              this.dom.rollingModeBtn = document.createElement("div");
              this.dom.root.className = "vis-timeline";
              this.dom.background.className = "vis-panel vis-background";
              this.dom.backgroundVertical.className = "vis-panel vis-background vis-vertical";
              this.dom.backgroundHorizontal.className = "vis-panel vis-background vis-horizontal";
              this.dom.centerContainer.className = "vis-panel vis-center";
              this.dom.leftContainer.className = "vis-panel vis-left";
              this.dom.rightContainer.className = "vis-panel vis-right";
              this.dom.top.className = "vis-panel vis-top";
              this.dom.bottom.className = "vis-panel vis-bottom";
              this.dom.left.className = "vis-content";
              this.dom.center.className = "vis-content";
              this.dom.right.className = "vis-content";
              this.dom.shadowTop.className = "vis-shadow vis-top";
              this.dom.shadowBottom.className = "vis-shadow vis-bottom";
              this.dom.shadowTopLeft.className = "vis-shadow vis-top";
              this.dom.shadowBottomLeft.className = "vis-shadow vis-bottom";
              this.dom.shadowTopRight.className = "vis-shadow vis-top";
              this.dom.shadowBottomRight.className = "vis-shadow vis-bottom";
              this.dom.rollingModeBtn.className = "vis-rolling-mode-btn";
              this.dom.root.appendChild(this.dom.background);
              this.dom.root.appendChild(this.dom.backgroundVertical);
              this.dom.root.appendChild(this.dom.backgroundHorizontal);
              this.dom.root.appendChild(this.dom.centerContainer);
              this.dom.root.appendChild(this.dom.leftContainer);
              this.dom.root.appendChild(this.dom.rightContainer);
              this.dom.root.appendChild(this.dom.top);
              this.dom.root.appendChild(this.dom.bottom);
              this.dom.root.appendChild(this.dom.bottom);
              this.dom.root.appendChild(this.dom.rollingModeBtn);
              this.dom.centerContainer.appendChild(this.dom.center);
              this.dom.leftContainer.appendChild(this.dom.left);
              this.dom.rightContainer.appendChild(this.dom.right);
              this.dom.centerContainer.appendChild(this.dom.shadowTop);
              this.dom.centerContainer.appendChild(this.dom.shadowBottom);
              this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
              this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
              this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
              this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);
              this.props = {
                root: {},
                background: {},
                centerContainer: {},
                leftContainer: {},
                rightContainer: {},
                center: {},
                left: {},
                right: {},
                top: {},
                bottom: {},
                border: {},
                scrollTop: 0,
                scrollTopMin: 0
              };
              this.on("rangechange", (function() {
                if (this.initialDrawDone === true) {
                  this._redraw();
                }
              }).bind(this));
              this.on("rangechanged", (function() {
                if (!this.initialRangeChangeDone) {
                  this.initialRangeChangeDone = true;
                }
              }).bind(this));
              this.on("touch", this._onTouch.bind(this));
              this.on("panmove", this._onDrag.bind(this));
              var me = this;
              this._origRedraw = this._redraw.bind(this);
              this._redraw = util.throttle(this._origRedraw);
              this.on("_change", function(properties) {
                if (me.itemSet && me.itemSet.initialItemSetDrawn && properties && properties.queue == true) {
                  me._redraw();
                } else {
                  me._origRedraw();
                }
              });
              this.hammer = new Hammer(this.dom.root);
              var pinchRecognizer = this.hammer.get("pinch").set({ enable: true });
              hammerUtil.disablePreventDefaultVertically(pinchRecognizer);
              this.hammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
              this.listeners = {};
              var events = [
                "tap",
                "doubletap",
                "press",
                "pinch",
                "pan",
                "panstart",
                "panmove",
                "panend"
                // TODO: cleanup
                //'touch', 'pinch',
                //'tap', 'doubletap', 'hold',
                //'dragstart', 'drag', 'dragend',
                //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
              ];
              events.forEach(function(type) {
                var listener = function listener2(event) {
                  if (me.isActive()) {
                    me.emit(type, event);
                  }
                };
                me.hammer.on(type, listener);
                me.listeners[type] = listener;
              });
              hammerUtil.onTouch(this.hammer, (function(event) {
                me.emit("touch", event);
              }).bind(this));
              hammerUtil.onRelease(this.hammer, (function(event) {
                me.emit("release", event);
              }).bind(this));
              function onMouseWheel(event) {
                if (this.isActive()) {
                  this.emit("mousewheel", event);
                }
                var deltaX = 0;
                var deltaY = 0;
                if ("detail" in event) {
                  deltaY = event.detail * -1;
                }
                if ("wheelDelta" in event) {
                  deltaY = event.wheelDelta;
                }
                if ("wheelDeltaY" in event) {
                  deltaY = event.wheelDeltaY;
                }
                if ("wheelDeltaX" in event) {
                  deltaX = event.wheelDeltaX * -1;
                }
                if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
                  deltaX = deltaY * -1;
                  deltaY = 0;
                }
                if ("deltaY" in event) {
                  deltaY = event.deltaY * -1;
                }
                if ("deltaX" in event) {
                  deltaX = event.deltaX;
                }
                if (!this.options.zoomKey || event[this.options.zoomKey]) return;
                event.preventDefault();
                if (this.options.verticalScroll && Math.abs(deltaY) >= Math.abs(deltaX)) {
                  var current = this.props.scrollTop;
                  var adjusted = current + deltaY;
                  if (this.isActive()) {
                    this._setScrollTop(adjusted);
                    this._redraw();
                    this.emit("scroll", event);
                  }
                } else if (this.options.horizontalScroll) {
                  var delta = Math.abs(deltaX) >= Math.abs(deltaY) ? deltaX : deltaY;
                  var diff = delta / 120 * (this.range.end - this.range.start) / 20;
                  var newStart = this.range.start + diff;
                  var newEnd = this.range.end + diff;
                  var options = {
                    animation: false,
                    byUser: true,
                    event
                  };
                  this.range.setRange(newStart, newEnd, options);
                }
              }
              if (this.dom.centerContainer.addEventListener) {
                this.dom.centerContainer.addEventListener("mousewheel", onMouseWheel.bind(this), false);
                this.dom.centerContainer.addEventListener("DOMMouseScroll", onMouseWheel.bind(this), false);
              } else {
                this.dom.centerContainer.attachEvent("onmousewheel", onMouseWheel.bind(this));
              }
              function onMouseScrollSide(event) {
                if (!me.options.verticalScroll) return;
                event.preventDefault();
                if (me.isActive()) {
                  var adjusted = -event.target.scrollTop;
                  me._setScrollTop(adjusted);
                  me._redraw();
                  me.emit("scrollSide", event);
                }
              }
              this.dom.left.parentNode.addEventListener("scroll", onMouseScrollSide.bind(this));
              this.dom.right.parentNode.addEventListener("scroll", onMouseScrollSide.bind(this));
              var itemAddedToTimeline = false;
              function handleDragOver(event) {
                if (event.preventDefault) {
                  event.preventDefault();
                }
                if (!event.target.className.indexOf("vis") > -1) return;
                if (itemAddedToTimeline) return;
                event.dataTransfer.dropEffect = "move";
                itemAddedToTimeline = true;
                return false;
              }
              function handleDrop(event) {
                if (event.preventDefault) {
                  event.preventDefault();
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                }
                try {
                  var itemData = JSON.parse(event.dataTransfer.getData("text"));
                  if (!itemData || !itemData.content) return;
                } catch (err) {
                  return false;
                }
                itemAddedToTimeline = false;
                event.center = {
                  x: event.clientX,
                  y: event.clientY
                };
                if (itemData.target !== "item") {
                  me.itemSet._onAddItem(event);
                } else {
                  me.itemSet._onDropObjectOnItem(event);
                }
                me.emit("drop", me.getEventProperties(event));
                return false;
              }
              this.dom.center.addEventListener("dragover", handleDragOver.bind(this), false);
              this.dom.center.addEventListener("drop", handleDrop.bind(this), false);
              this.customTimes = [];
              this.touch = {};
              this.redrawCount = 0;
              this.initialDrawDone = false;
              this.initialRangeChangeDone = false;
              if (!container) throw new Error("No container provided");
              container.appendChild(this.dom.root);
            };
            Core.prototype.setOptions = function(options) {
              if (options) {
                var fields = ["width", "height", "minHeight", "maxHeight", "autoResize", "start", "end", "clickToUse", "dataAttributes", "hiddenDates", "locale", "locales", "moment", "rtl", "zoomKey", "horizontalScroll", "verticalScroll"];
                util.selectiveExtend(fields, this.options, options);
                this.dom.rollingModeBtn.style.visibility = "hidden";
                if (this.options.rtl) {
                  this.dom.container.style.direction = "rtl";
                  this.dom.backgroundVertical.className = "vis-panel vis-background vis-vertical-rtl";
                }
                if (this.options.verticalScroll) {
                  if (this.options.rtl) {
                    this.dom.rightContainer.className = "vis-panel vis-right vis-vertical-scroll";
                  } else {
                    this.dom.leftContainer.className = "vis-panel vis-left vis-vertical-scroll";
                  }
                }
                if ((0, _typeof3["default"])(this.options.orientation) !== "object") {
                  this.options.orientation = { item: void 0, axis: void 0 };
                }
                if ("orientation" in options) {
                  if (typeof options.orientation === "string") {
                    this.options.orientation = {
                      item: options.orientation,
                      axis: options.orientation
                    };
                  } else if ((0, _typeof3["default"])(options.orientation) === "object") {
                    if ("item" in options.orientation) {
                      this.options.orientation.item = options.orientation.item;
                    }
                    if ("axis" in options.orientation) {
                      this.options.orientation.axis = options.orientation.axis;
                    }
                  }
                }
                if (this.options.orientation.axis === "both") {
                  if (!this.timeAxis2) {
                    var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
                    timeAxis2.setOptions = function(options2) {
                      var _options = options2 ? util.extend({}, options2) : {};
                      _options.orientation = "top";
                      TimeAxis.prototype.setOptions.call(timeAxis2, _options);
                    };
                    this.components.push(timeAxis2);
                  }
                } else {
                  if (this.timeAxis2) {
                    var index = this.components.indexOf(this.timeAxis2);
                    if (index !== -1) {
                      this.components.splice(index, 1);
                    }
                    this.timeAxis2.destroy();
                    this.timeAxis2 = null;
                  }
                }
                if (typeof options.drawPoints == "function") {
                  options.drawPoints = {
                    onRender: options.drawPoints
                  };
                }
                if ("hiddenDates" in this.options) {
                  DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
                }
                if ("clickToUse" in options) {
                  if (options.clickToUse) {
                    if (!this.activator) {
                      this.activator = new Activator(this.dom.root);
                    }
                  } else {
                    if (this.activator) {
                      this.activator.destroy();
                      delete this.activator;
                    }
                  }
                }
                if ("showCustomTime" in options) {
                  throw new Error("Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])");
                }
                this._initAutoResize();
              }
              this.components.forEach(function(component) {
                return component.setOptions(options);
              });
              if ("configure" in options) {
                if (!this.configurator) {
                  this.configurator = this._createConfigurator();
                }
                this.configurator.setOptions(options.configure);
                var appliedOptions = util.deepExtend({}, this.options);
                this.components.forEach(function(component) {
                  util.deepExtend(appliedOptions, component.options);
                });
                this.configurator.setModuleOptions({ global: appliedOptions });
              }
              this._redraw();
            };
            Core.prototype.isActive = function() {
              return !this.activator || this.activator.active;
            };
            Core.prototype.destroy = function() {
              this.setItems(null);
              this.setGroups(null);
              this.off();
              this._stopAutoResize();
              if (this.dom.root.parentNode) {
                this.dom.root.parentNode.removeChild(this.dom.root);
              }
              this.dom = null;
              if (this.activator) {
                this.activator.destroy();
                delete this.activator;
              }
              for (var event in this.listeners) {
                if (this.listeners.hasOwnProperty(event)) {
                  delete this.listeners[event];
                }
              }
              this.listeners = null;
              this.hammer = null;
              this.components.forEach(function(component) {
                return component.destroy();
              });
              this.body = null;
            };
            Core.prototype.setCustomTime = function(time, id) {
              var customTimes = this.customTimes.filter(function(component) {
                return id === component.options.id;
              });
              if (customTimes.length === 0) {
                throw new Error("No custom time bar found with id " + (0, _stringify2["default"])(id));
              }
              if (customTimes.length > 0) {
                customTimes[0].setCustomTime(time);
              }
            };
            Core.prototype.getCustomTime = function(id) {
              var customTimes = this.customTimes.filter(function(component) {
                return component.options.id === id;
              });
              if (customTimes.length === 0) {
                throw new Error("No custom time bar found with id " + (0, _stringify2["default"])(id));
              }
              return customTimes[0].getCustomTime();
            };
            Core.prototype.setCustomTimeTitle = function(title, id) {
              var customTimes = this.customTimes.filter(function(component) {
                return component.options.id === id;
              });
              if (customTimes.length === 0) {
                throw new Error("No custom time bar found with id " + (0, _stringify2["default"])(id));
              }
              if (customTimes.length > 0) {
                return customTimes[0].setCustomTitle(title);
              }
            };
            Core.prototype.getEventProperties = function(event) {
              return { event };
            };
            Core.prototype.addCustomTime = function(time, id) {
              var timestamp = time !== void 0 ? util.convert(time, "Date").valueOf() : /* @__PURE__ */ new Date();
              var exists = this.customTimes.some(function(customTime2) {
                return customTime2.options.id === id;
              });
              if (exists) {
                throw new Error("A custom time with id " + (0, _stringify2["default"])(id) + " already exists");
              }
              var customTime = new CustomTime(this.body, util.extend({}, this.options, {
                time: timestamp,
                id
              }));
              this.customTimes.push(customTime);
              this.components.push(customTime);
              this._redraw();
              return id;
            };
            Core.prototype.removeCustomTime = function(id) {
              var customTimes = this.customTimes.filter(function(bar) {
                return bar.options.id === id;
              });
              if (customTimes.length === 0) {
                throw new Error("No custom time bar found with id " + (0, _stringify2["default"])(id));
              }
              customTimes.forEach((function(customTime) {
                this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
                this.components.splice(this.components.indexOf(customTime), 1);
                customTime.destroy();
              }).bind(this));
            };
            Core.prototype.getVisibleItems = function() {
              return this.itemSet && this.itemSet.getVisibleItems() || [];
            };
            Core.prototype.fit = function(options, callback) {
              var range = this.getDataRange();
              if (range.min === null && range.max === null) {
                return;
              }
              var interval = range.max - range.min;
              var min = new Date(range.min.valueOf() - interval * 0.01);
              var max = new Date(range.max.valueOf() + interval * 0.01);
              var animation = options && options.animation !== void 0 ? options.animation : true;
              this.range.setRange(min, max, { animation }, callback);
            };
            Core.prototype.getDataRange = function() {
              throw new Error("Cannot invoke abstract method getDataRange");
            };
            Core.prototype.setWindow = function(start, end, options, callback) {
              if (typeof arguments[2] == "function") {
                callback = arguments[2];
                options = {};
              }
              var animation;
              var range;
              if (arguments.length == 1) {
                range = arguments[0];
                animation = range.animation !== void 0 ? range.animation : true;
                this.range.setRange(range.start, range.end, { animation });
              } else if (arguments.length == 2 && typeof arguments[1] == "function") {
                range = arguments[0];
                callback = arguments[1];
                animation = range.animation !== void 0 ? range.animation : true;
                this.range.setRange(range.start, range.end, { animation }, callback);
              } else {
                animation = options && options.animation !== void 0 ? options.animation : true;
                this.range.setRange(start, end, { animation }, callback);
              }
            };
            Core.prototype.moveTo = function(time, options, callback) {
              if (typeof arguments[1] == "function") {
                callback = arguments[1];
                options = {};
              }
              var interval = this.range.end - this.range.start;
              var t = util.convert(time, "Date").valueOf();
              var start = t - interval / 2;
              var end = t + interval / 2;
              var animation = options && options.animation !== void 0 ? options.animation : true;
              this.range.setRange(start, end, { animation }, callback);
            };
            Core.prototype.getWindow = function() {
              var range = this.range.getRange();
              return {
                start: new Date(range.start),
                end: new Date(range.end)
              };
            };
            Core.prototype.zoomIn = function(percentage, options, callback) {
              if (!percentage || percentage < 0 || percentage > 1) return;
              if (typeof arguments[1] == "function") {
                callback = arguments[1];
                options = {};
              }
              var range = this.getWindow();
              var start = range.start.valueOf();
              var end = range.end.valueOf();
              var interval = end - start;
              var newInterval = interval / (1 + percentage);
              var distance = (interval - newInterval) / 2;
              var newStart = start + distance;
              var newEnd = end - distance;
              this.setWindow(newStart, newEnd, options, callback);
            };
            Core.prototype.zoomOut = function(percentage, options, callback) {
              if (!percentage || percentage < 0 || percentage > 1) return;
              if (typeof arguments[1] == "function") {
                callback = arguments[1];
                options = {};
              }
              var range = this.getWindow();
              var start = range.start.valueOf();
              var end = range.end.valueOf();
              var interval = end - start;
              var newStart = start - interval * percentage / 2;
              var newEnd = end + interval * percentage / 2;
              this.setWindow(newStart, newEnd, options, callback);
            };
            Core.prototype.redraw = function() {
              this._redraw();
            };
            Core.prototype._redraw = function() {
              this.redrawCount++;
              var resized = false;
              var options = this.options;
              var props = this.props;
              var dom = this.dom;
              if (!dom || !dom.container || dom.root.offsetWidth == 0) return;
              DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
              if (options.orientation == "top") {
                util.addClassName(dom.root, "vis-top");
                util.removeClassName(dom.root, "vis-bottom");
              } else {
                util.removeClassName(dom.root, "vis-top");
                util.addClassName(dom.root, "vis-bottom");
              }
              dom.root.style.maxHeight = util.option.asSize(options.maxHeight, "");
              dom.root.style.minHeight = util.option.asSize(options.minHeight, "");
              dom.root.style.width = util.option.asSize(options.width, "");
              props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
              props.border.right = props.border.left;
              props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
              props.border.bottom = props.border.top;
              props.borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
              props.borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;
              if (dom.centerContainer.clientHeight === 0) {
                props.border.left = props.border.top;
                props.border.right = props.border.left;
              }
              if (dom.root.clientHeight === 0) {
                props.borderRootWidth = props.borderRootHeight;
              }
              props.center.height = dom.center.offsetHeight;
              props.left.height = dom.left.offsetHeight;
              props.right.height = dom.right.offsetHeight;
              props.top.height = dom.top.clientHeight || -props.border.top;
              props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;
              var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
              var autoHeight = props.top.height + contentHeight + props.bottom.height + props.borderRootHeight + props.border.top + props.border.bottom;
              dom.root.style.height = util.option.asSize(options.height, autoHeight + "px");
              props.root.height = dom.root.offsetHeight;
              props.background.height = props.root.height - props.borderRootHeight;
              var containerHeight = props.root.height - props.top.height - props.bottom.height - props.borderRootHeight;
              props.centerContainer.height = containerHeight;
              props.leftContainer.height = containerHeight;
              props.rightContainer.height = props.leftContainer.height;
              props.root.width = dom.root.offsetWidth;
              props.background.width = props.root.width - props.borderRootWidth;
              if (!this.initialDrawDone) {
                props.scrollbarWidth = util.getScrollBarWidth();
              }
              if (options.verticalScroll) {
                if (options.rtl) {
                  props.left.width = dom.leftContainer.clientWidth || -props.border.left;
                  props.right.width = dom.rightContainer.clientWidth + props.scrollbarWidth || -props.border.right;
                } else {
                  props.left.width = dom.leftContainer.clientWidth + props.scrollbarWidth || -props.border.left;
                  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
                }
              } else {
                props.left.width = dom.leftContainer.clientWidth || -props.border.left;
                props.right.width = dom.rightContainer.clientWidth || -props.border.right;
              }
              this._setDOM();
              var offset = this._updateScrollTop();
              if (options.orientation.item != "top") {
                offset += Math.max(props.centerContainer.height - props.center.height - props.border.top - props.border.bottom, 0);
              }
              dom.center.style.top = offset + "px";
              var visibilityTop = props.scrollTop == 0 ? "hidden" : "";
              var visibilityBottom = props.scrollTop == props.scrollTopMin ? "hidden" : "";
              dom.shadowTop.style.visibility = visibilityTop;
              dom.shadowBottom.style.visibility = visibilityBottom;
              dom.shadowTopLeft.style.visibility = visibilityTop;
              dom.shadowBottomLeft.style.visibility = visibilityBottom;
              dom.shadowTopRight.style.visibility = visibilityTop;
              dom.shadowBottomRight.style.visibility = visibilityBottom;
              if (options.verticalScroll) {
                dom.rightContainer.className = "vis-panel vis-right vis-vertical-scroll";
                dom.leftContainer.className = "vis-panel vis-left vis-vertical-scroll";
                dom.shadowTopRight.style.visibility = "hidden";
                dom.shadowBottomRight.style.visibility = "hidden";
                dom.shadowTopLeft.style.visibility = "hidden";
                dom.shadowBottomLeft.style.visibility = "hidden";
                dom.left.style.top = "0px";
                dom.right.style.top = "0px";
              }
              if (!options.verticalScroll || props.center.height < props.centerContainer.height) {
                dom.left.style.top = offset + "px";
                dom.right.style.top = offset + "px";
                dom.rightContainer.className = dom.rightContainer.className.replace(new RegExp("(?:^|\\s)vis-vertical-scroll(?:\\s|$)"), " ");
                dom.leftContainer.className = dom.leftContainer.className.replace(new RegExp("(?:^|\\s)vis-vertical-scroll(?:\\s|$)"), " ");
                props.left.width = dom.leftContainer.clientWidth || -props.border.left;
                props.right.width = dom.rightContainer.clientWidth || -props.border.right;
                this._setDOM();
              }
              var contentsOverflow = props.center.height > props.centerContainer.height;
              this.hammer.get("pan").set({
                direction: contentsOverflow ? Hammer.DIRECTION_ALL : Hammer.DIRECTION_HORIZONTAL
              });
              this.components.forEach(function(component) {
                resized = component.redraw() || resized;
              });
              var MAX_REDRAW = 5;
              if (resized) {
                if (this.redrawCount < MAX_REDRAW) {
                  this.body.emitter.emit("_change");
                  return;
                } else {
                  console.log("WARNING: infinite loop in redraw?");
                }
              } else {
                this.redrawCount = 0;
              }
              this.body.emitter.emit("changed");
            };
            Core.prototype._setDOM = function() {
              var props = this.props;
              var dom = this.dom;
              props.leftContainer.width = props.left.width;
              props.rightContainer.width = props.right.width;
              var centerWidth = props.root.width - props.left.width - props.right.width - props.borderRootWidth;
              props.center.width = centerWidth;
              props.centerContainer.width = centerWidth;
              props.top.width = centerWidth;
              props.bottom.width = centerWidth;
              dom.background.style.height = props.background.height + "px";
              dom.backgroundVertical.style.height = props.background.height + "px";
              dom.backgroundHorizontal.style.height = props.centerContainer.height + "px";
              dom.centerContainer.style.height = props.centerContainer.height + "px";
              dom.leftContainer.style.height = props.leftContainer.height + "px";
              dom.rightContainer.style.height = props.rightContainer.height + "px";
              dom.background.style.width = props.background.width + "px";
              dom.backgroundVertical.style.width = props.centerContainer.width + "px";
              dom.backgroundHorizontal.style.width = props.background.width + "px";
              dom.centerContainer.style.width = props.center.width + "px";
              dom.top.style.width = props.top.width + "px";
              dom.bottom.style.width = props.bottom.width + "px";
              dom.background.style.left = "0";
              dom.background.style.top = "0";
              dom.backgroundVertical.style.left = props.left.width + props.border.left + "px";
              dom.backgroundVertical.style.top = "0";
              dom.backgroundHorizontal.style.left = "0";
              dom.backgroundHorizontal.style.top = props.top.height + "px";
              dom.centerContainer.style.left = props.left.width + "px";
              dom.centerContainer.style.top = props.top.height + "px";
              dom.leftContainer.style.left = "0";
              dom.leftContainer.style.top = props.top.height + "px";
              dom.rightContainer.style.left = props.left.width + props.center.width + "px";
              dom.rightContainer.style.top = props.top.height + "px";
              dom.top.style.left = props.left.width + "px";
              dom.top.style.top = "0";
              dom.bottom.style.left = props.left.width + "px";
              dom.bottom.style.top = props.top.height + props.centerContainer.height + "px";
              dom.center.style.left = "0";
              dom.left.style.left = "0";
              dom.right.style.left = "0";
            };
            Core.prototype.repaint = function() {
              throw new Error("Function repaint is deprecated. Use redraw instead.");
            };
            Core.prototype.setCurrentTime = function(time) {
              if (!this.currentTime) {
                throw new Error("Option showCurrentTime must be true");
              }
              this.currentTime.setCurrentTime(time);
            };
            Core.prototype.getCurrentTime = function() {
              if (!this.currentTime) {
                throw new Error("Option showCurrentTime must be true");
              }
              return this.currentTime.getCurrentTime();
            };
            Core.prototype._toTime = function(x) {
              return DateUtil.toTime(this, x, this.props.center.width);
            };
            Core.prototype._toGlobalTime = function(x) {
              return DateUtil.toTime(this, x, this.props.root.width);
            };
            Core.prototype._toScreen = function(time) {
              return DateUtil.toScreen(this, time, this.props.center.width);
            };
            Core.prototype._toGlobalScreen = function(time) {
              return DateUtil.toScreen(this, time, this.props.root.width);
            };
            Core.prototype._initAutoResize = function() {
              if (this.options.autoResize == true) {
                this._startAutoResize();
              } else {
                this._stopAutoResize();
              }
            };
            Core.prototype._startAutoResize = function() {
              var me = this;
              this._stopAutoResize();
              this._onResize = function() {
                if (me.options.autoResize != true) {
                  me._stopAutoResize();
                  return;
                }
                if (me.dom.root) {
                  if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
                    me.props.lastWidth = me.dom.root.offsetWidth;
                    me.props.lastHeight = me.dom.root.offsetHeight;
                    me.props.scrollbarWidth = util.getScrollBarWidth();
                    me.body.emitter.emit("_change");
                  }
                }
              };
              util.addEventListener(window, "resize", this._onResize);
              if (me.dom.root) {
                me.props.lastWidth = me.dom.root.offsetWidth;
                me.props.lastHeight = me.dom.root.offsetHeight;
              }
              this.watchTimer = setInterval(this._onResize, 1e3);
            };
            Core.prototype._stopAutoResize = function() {
              if (this.watchTimer) {
                clearInterval(this.watchTimer);
                this.watchTimer = void 0;
              }
              if (this._onResize) {
                util.removeEventListener(window, "resize", this._onResize);
                this._onResize = null;
              }
            };
            Core.prototype._onTouch = function(event) {
              this.touch.allowDragging = true;
              this.touch.initialScrollTop = this.props.scrollTop;
            };
            Core.prototype._onPinch = function(event) {
              this.touch.allowDragging = false;
            };
            Core.prototype._onDrag = function(event) {
              if (!event) return;
              if (!this.touch.allowDragging) return;
              var delta = event.deltaY;
              var oldScrollTop = this._getScrollTop();
              var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);
              if (this.options.verticalScroll) {
                this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
                this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
              }
              if (newScrollTop != oldScrollTop) {
                this.emit("verticalDrag");
              }
            };
            Core.prototype._setScrollTop = function(scrollTop) {
              this.props.scrollTop = scrollTop;
              this._updateScrollTop();
              return this.props.scrollTop;
            };
            Core.prototype._updateScrollTop = function() {
              var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0);
              if (scrollTopMin != this.props.scrollTopMin) {
                if (this.options.orientation.item != "top") {
                  this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
                }
                this.props.scrollTopMin = scrollTopMin;
              }
              if (this.props.scrollTop > 0) this.props.scrollTop = 0;
              if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;
              if (this.options.verticalScroll) {
                this.dom.left.parentNode.scrollTop = -this.props.scrollTop;
                this.dom.right.parentNode.scrollTop = -this.props.scrollTop;
              }
              return this.props.scrollTop;
            };
            Core.prototype._getScrollTop = function() {
              return this.props.scrollTop;
            };
            Core.prototype._createConfigurator = function() {
              throw new Error("Cannot invoke abstract method _createConfigurator");
            };
            module2.exports = Core;
          },
          /* 66 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var moment = __webpack_require__(9);
            var DateUtil = __webpack_require__(36);
            var util = __webpack_require__(2);
            function TimeStep(start, end, minimumStep, hiddenDates, options) {
              this.moment = moment;
              this.current = this.moment();
              this._start = this.moment();
              this._end = this.moment();
              this.autoScale = true;
              this.scale = "day";
              this.step = 1;
              this.setRange(start, end, minimumStep);
              this.switchedDay = false;
              this.switchedMonth = false;
              this.switchedYear = false;
              if (Array.isArray(hiddenDates)) {
                this.hiddenDates = hiddenDates;
              } else if (hiddenDates != void 0) {
                this.hiddenDates = [hiddenDates];
              } else {
                this.hiddenDates = [];
              }
              this.format = TimeStep.FORMAT;
              this.options = options ? options : {};
            }
            TimeStep.FORMAT = {
              minorLabels: {
                millisecond: "SSS",
                second: "s",
                minute: "HH:mm",
                hour: "HH:mm",
                weekday: "ddd D",
                day: "D",
                week: "w",
                month: "MMM",
                year: "YYYY"
              },
              majorLabels: {
                millisecond: "HH:mm:ss",
                second: "D MMMM HH:mm",
                minute: "ddd D MMMM",
                hour: "ddd D MMMM",
                weekday: "MMMM YYYY",
                day: "MMMM YYYY",
                week: "MMMM YYYY",
                month: "YYYY",
                year: ""
              }
            };
            TimeStep.prototype.setMoment = function(moment2) {
              this.moment = moment2;
              this.current = this.moment(this.current.valueOf());
              this._start = this.moment(this._start.valueOf());
              this._end = this.moment(this._end.valueOf());
            };
            TimeStep.prototype.setFormat = function(format) {
              var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
              this.format = util.deepExtend(defaultFormat, format);
            };
            TimeStep.prototype.setRange = function(start, end, minimumStep) {
              if (!(start instanceof Date) || !(end instanceof Date)) {
                throw "No legal start or end date in method setRange";
              }
              this._start = start != void 0 ? this.moment(start.valueOf()) : /* @__PURE__ */ new Date();
              this._end = end != void 0 ? this.moment(end.valueOf()) : /* @__PURE__ */ new Date();
              if (this.autoScale) {
                this.setMinimumStep(minimumStep);
              }
            };
            TimeStep.prototype.start = function() {
              this.current = this._start.clone();
              this.roundToMinor();
            };
            TimeStep.prototype.roundToMinor = function() {
              if (this.scale == "week") {
                this.current.weekday(0);
              }
              switch (this.scale) {
                case "year":
                  this.current.year(this.step * Math.floor(this.current.year() / this.step));
                  this.current.month(0);
                case "month":
                  this.current.date(1);
                // eslint-disable-line no-fallthrough
                case "week":
                // eslint-disable-line no-fallthrough
                case "day":
                // eslint-disable-line no-fallthrough
                case "weekday":
                  this.current.hours(0);
                // eslint-disable-line no-fallthrough
                case "hour":
                  this.current.minutes(0);
                // eslint-disable-line no-fallthrough
                case "minute":
                  this.current.seconds(0);
                // eslint-disable-line no-fallthrough
                case "second":
                  this.current.milliseconds(0);
              }
              if (this.step != 1) {
                switch (this.scale) {
                  case "millisecond":
                    this.current.subtract(this.current.milliseconds() % this.step, "milliseconds");
                    break;
                  case "second":
                    this.current.subtract(this.current.seconds() % this.step, "seconds");
                    break;
                  case "minute":
                    this.current.subtract(this.current.minutes() % this.step, "minutes");
                    break;
                  case "hour":
                    this.current.subtract(this.current.hours() % this.step, "hours");
                    break;
                  case "weekday":
                  // intentional fall through
                  case "day":
                    this.current.subtract((this.current.date() - 1) % this.step, "day");
                    break;
                  case "week":
                    this.current.subtract(this.current.week() % this.step, "week");
                    break;
                  case "month":
                    this.current.subtract(this.current.month() % this.step, "month");
                    break;
                  case "year":
                    this.current.subtract(this.current.year() % this.step, "year");
                    break;
                  default:
                    break;
                }
              }
            };
            TimeStep.prototype.hasNext = function() {
              return this.current.valueOf() <= this._end.valueOf();
            };
            TimeStep.prototype.next = function() {
              var prev = this.current.valueOf();
              switch (this.scale) {
                case "millisecond":
                  this.current.add(this.step, "millisecond");
                  break;
                case "second":
                  this.current.add(this.step, "second");
                  break;
                case "minute":
                  this.current.add(this.step, "minute");
                  break;
                case "hour":
                  this.current.add(this.step, "hour");
                  if (this.current.month() < 6) {
                    this.current.subtract(this.current.hours() % this.step, "hour");
                  } else {
                    if (this.current.hours() % this.step !== 0) {
                      this.current.add(this.step - this.current.hours() % this.step, "hour");
                    }
                  }
                  break;
                case "weekday":
                // intentional fall through
                case "day":
                  this.current.add(this.step, "day");
                  break;
                case "week":
                  if (this.current.weekday() !== 0) {
                    this.current.weekday(0);
                    this.current.add(this.step, "week");
                  } else if (this.options.showMajorLabels === false) {
                    this.current.add(this.step, "week");
                  } else {
                    var nextWeek = this.current.clone();
                    nextWeek.add(1, "week");
                    if (nextWeek.isSame(this.current, "month")) {
                      this.current.add(this.step, "week");
                    } else {
                      this.current.add(this.step, "week");
                      this.current.date(1);
                    }
                  }
                  break;
                case "month":
                  this.current.add(this.step, "month");
                  break;
                case "year":
                  this.current.add(this.step, "year");
                  break;
                default:
                  break;
              }
              if (this.step != 1) {
                switch (this.scale) {
                  case "millisecond":
                    if (this.current.milliseconds() > 0 && this.current.milliseconds() < this.step) this.current.milliseconds(0);
                    break;
                  case "second":
                    if (this.current.seconds() > 0 && this.current.seconds() < this.step) this.current.seconds(0);
                    break;
                  case "minute":
                    if (this.current.minutes() > 0 && this.current.minutes() < this.step) this.current.minutes(0);
                    break;
                  case "hour":
                    if (this.current.hours() > 0 && this.current.hours() < this.step) this.current.hours(0);
                    break;
                  case "weekday":
                  // intentional fall through
                  case "day":
                    if (this.current.date() < this.step + 1) this.current.date(1);
                    break;
                  case "week":
                    if (this.current.week() < this.step) this.current.week(1);
                    break;
                  // week numbering starts at 1, not 0
                  case "month":
                    if (this.current.month() < this.step) this.current.month(0);
                    break;
                  case "year":
                    break;
                  // nothing to do for year
                  default:
                    break;
                }
              }
              if (this.current.valueOf() == prev) {
                this.current = this._end.clone();
              }
              this.switchedDay = false;
              this.switchedMonth = false;
              this.switchedYear = false;
              DateUtil.stepOverHiddenDates(this.moment, this, prev);
            };
            TimeStep.prototype.getCurrent = function() {
              return this.current;
            };
            TimeStep.prototype.setScale = function(params) {
              if (params && typeof params.scale == "string") {
                this.scale = params.scale;
                this.step = params.step > 0 ? params.step : 1;
                this.autoScale = false;
              }
            };
            TimeStep.prototype.setAutoScale = function(enable) {
              this.autoScale = enable;
            };
            TimeStep.prototype.setMinimumStep = function(minimumStep) {
              if (minimumStep == void 0) {
                return;
              }
              var stepYear = 1e3 * 60 * 60 * 24 * 30 * 12;
              var stepMonth = 1e3 * 60 * 60 * 24 * 30;
              var stepDay = 1e3 * 60 * 60 * 24;
              var stepHour = 1e3 * 60 * 60;
              var stepMinute = 1e3 * 60;
              var stepSecond = 1e3;
              var stepMillisecond = 1;
              if (stepYear * 1e3 > minimumStep) {
                this.scale = "year";
                this.step = 1e3;
              }
              if (stepYear * 500 > minimumStep) {
                this.scale = "year";
                this.step = 500;
              }
              if (stepYear * 100 > minimumStep) {
                this.scale = "year";
                this.step = 100;
              }
              if (stepYear * 50 > minimumStep) {
                this.scale = "year";
                this.step = 50;
              }
              if (stepYear * 10 > minimumStep) {
                this.scale = "year";
                this.step = 10;
              }
              if (stepYear * 5 > minimumStep) {
                this.scale = "year";
                this.step = 5;
              }
              if (stepYear > minimumStep) {
                this.scale = "year";
                this.step = 1;
              }
              if (stepMonth * 3 > minimumStep) {
                this.scale = "month";
                this.step = 3;
              }
              if (stepMonth > minimumStep) {
                this.scale = "month";
                this.step = 1;
              }
              if (stepDay * 5 > minimumStep) {
                this.scale = "day";
                this.step = 5;
              }
              if (stepDay * 2 > minimumStep) {
                this.scale = "day";
                this.step = 2;
              }
              if (stepDay > minimumStep) {
                this.scale = "day";
                this.step = 1;
              }
              if (stepDay / 2 > minimumStep) {
                this.scale = "weekday";
                this.step = 1;
              }
              if (stepHour * 4 > minimumStep) {
                this.scale = "hour";
                this.step = 4;
              }
              if (stepHour > minimumStep) {
                this.scale = "hour";
                this.step = 1;
              }
              if (stepMinute * 15 > minimumStep) {
                this.scale = "minute";
                this.step = 15;
              }
              if (stepMinute * 10 > minimumStep) {
                this.scale = "minute";
                this.step = 10;
              }
              if (stepMinute * 5 > minimumStep) {
                this.scale = "minute";
                this.step = 5;
              }
              if (stepMinute > minimumStep) {
                this.scale = "minute";
                this.step = 1;
              }
              if (stepSecond * 15 > minimumStep) {
                this.scale = "second";
                this.step = 15;
              }
              if (stepSecond * 10 > minimumStep) {
                this.scale = "second";
                this.step = 10;
              }
              if (stepSecond * 5 > minimumStep) {
                this.scale = "second";
                this.step = 5;
              }
              if (stepSecond > minimumStep) {
                this.scale = "second";
                this.step = 1;
              }
              if (stepMillisecond * 200 > minimumStep) {
                this.scale = "millisecond";
                this.step = 200;
              }
              if (stepMillisecond * 100 > minimumStep) {
                this.scale = "millisecond";
                this.step = 100;
              }
              if (stepMillisecond * 50 > minimumStep) {
                this.scale = "millisecond";
                this.step = 50;
              }
              if (stepMillisecond * 10 > minimumStep) {
                this.scale = "millisecond";
                this.step = 10;
              }
              if (stepMillisecond * 5 > minimumStep) {
                this.scale = "millisecond";
                this.step = 5;
              }
              if (stepMillisecond > minimumStep) {
                this.scale = "millisecond";
                this.step = 1;
              }
            };
            TimeStep.snap = function(date, scale, step) {
              var clone = moment(date);
              if (scale == "year") {
                var year = clone.year() + Math.round(clone.month() / 12);
                clone.year(Math.round(year / step) * step);
                clone.month(0);
                clone.date(0);
                clone.hours(0);
                clone.minutes(0);
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "month") {
                if (clone.date() > 15) {
                  clone.date(1);
                  clone.add(1, "month");
                } else {
                  clone.date(1);
                }
                clone.hours(0);
                clone.minutes(0);
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "week") {
                if (clone.weekday() > 2) {
                  clone.weekday(0);
                  clone.add(1, "week");
                } else {
                  clone.weekday(0);
                }
                clone.hours(0);
                clone.minutes(0);
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "day") {
                switch (step) {
                  case 5:
                  case 2:
                    clone.hours(Math.round(clone.hours() / 24) * 24);
                    break;
                  default:
                    clone.hours(Math.round(clone.hours() / 12) * 12);
                    break;
                }
                clone.minutes(0);
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "weekday") {
                switch (step) {
                  case 5:
                  case 2:
                    clone.hours(Math.round(clone.hours() / 12) * 12);
                    break;
                  default:
                    clone.hours(Math.round(clone.hours() / 6) * 6);
                    break;
                }
                clone.minutes(0);
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "hour") {
                switch (step) {
                  case 4:
                    clone.minutes(Math.round(clone.minutes() / 60) * 60);
                    break;
                  default:
                    clone.minutes(Math.round(clone.minutes() / 30) * 30);
                    break;
                }
                clone.seconds(0);
                clone.milliseconds(0);
              } else if (scale == "minute") {
                switch (step) {
                  case 15:
                  case 10:
                    clone.minutes(Math.round(clone.minutes() / 5) * 5);
                    clone.seconds(0);
                    break;
                  case 5:
                    clone.seconds(Math.round(clone.seconds() / 60) * 60);
                    break;
                  default:
                    clone.seconds(Math.round(clone.seconds() / 30) * 30);
                    break;
                }
                clone.milliseconds(0);
              } else if (scale == "second") {
                switch (step) {
                  case 15:
                  case 10:
                    clone.seconds(Math.round(clone.seconds() / 5) * 5);
                    clone.milliseconds(0);
                    break;
                  case 5:
                    clone.milliseconds(Math.round(clone.milliseconds() / 1e3) * 1e3);
                    break;
                  default:
                    clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);
                    break;
                }
              } else if (scale == "millisecond") {
                var _step = step > 5 ? step / 2 : 1;
                clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
              }
              return clone;
            };
            TimeStep.prototype.isMajor = function() {
              if (this.switchedYear == true) {
                switch (this.scale) {
                  case "year":
                  case "month":
                  case "week":
                  case "weekday":
                  case "day":
                  case "hour":
                  case "minute":
                  case "second":
                  case "millisecond":
                    return true;
                  default:
                    return false;
                }
              } else if (this.switchedMonth == true) {
                switch (this.scale) {
                  case "week":
                  case "weekday":
                  case "day":
                  case "hour":
                  case "minute":
                  case "second":
                  case "millisecond":
                    return true;
                  default:
                    return false;
                }
              } else if (this.switchedDay == true) {
                switch (this.scale) {
                  case "millisecond":
                  case "second":
                  case "minute":
                  case "hour":
                    return true;
                  default:
                    return false;
                }
              }
              var date = this.moment(this.current);
              switch (this.scale) {
                case "millisecond":
                  return date.milliseconds() == 0;
                case "second":
                  return date.seconds() == 0;
                case "minute":
                  return date.hours() == 0 && date.minutes() == 0;
                case "hour":
                  return date.hours() == 0;
                case "weekday":
                // intentional fall through
                case "day":
                  return date.date() == 1;
                case "week":
                  return date.date() == 1;
                case "month":
                  return date.month() == 0;
                case "year":
                  return false;
                default:
                  return false;
              }
            };
            TimeStep.prototype.getLabelMinor = function(date) {
              if (date == void 0) {
                date = this.current;
              }
              if (date instanceof Date) {
                date = this.moment(date);
              }
              if (typeof this.format.minorLabels === "function") {
                return this.format.minorLabels(date, this.scale, this.step);
              }
              var format = this.format.minorLabels[this.scale];
              switch (this.scale) {
                case "week":
                  if (this.isMajor() && date.weekday() !== 0) {
                    return "";
                  }
                default:
                  return format && format.length > 0 ? this.moment(date).format(format) : "";
              }
            };
            TimeStep.prototype.getLabelMajor = function(date) {
              if (date == void 0) {
                date = this.current;
              }
              if (date instanceof Date) {
                date = this.moment(date);
              }
              if (typeof this.format.majorLabels === "function") {
                return this.format.majorLabels(date, this.scale, this.step);
              }
              var format = this.format.majorLabels[this.scale];
              return format && format.length > 0 ? this.moment(date).format(format) : "";
            };
            TimeStep.prototype.getClassName = function() {
              var _moment = this.moment;
              var m = this.moment(this.current);
              var current = m.locale ? m.locale("en") : m.lang("en");
              var step = this.step;
              var classNames = [];
              function even(value) {
                return value / step % 2 == 0 ? " vis-even" : " vis-odd";
              }
              function today(date) {
                if (date.isSame(/* @__PURE__ */ new Date(), "day")) {
                  return " vis-today";
                }
                if (date.isSame(_moment().add(1, "day"), "day")) {
                  return " vis-tomorrow";
                }
                if (date.isSame(_moment().add(-1, "day"), "day")) {
                  return " vis-yesterday";
                }
                return "";
              }
              function currentWeek(date) {
                return date.isSame(/* @__PURE__ */ new Date(), "week") ? " vis-current-week" : "";
              }
              function currentMonth(date) {
                return date.isSame(/* @__PURE__ */ new Date(), "month") ? " vis-current-month" : "";
              }
              function currentYear(date) {
                return date.isSame(/* @__PURE__ */ new Date(), "year") ? " vis-current-year" : "";
              }
              switch (this.scale) {
                case "millisecond":
                  classNames.push(today(current));
                  classNames.push(even(current.milliseconds()));
                  break;
                case "second":
                  classNames.push(today(current));
                  classNames.push(even(current.seconds()));
                  break;
                case "minute":
                  classNames.push(today(current));
                  classNames.push(even(current.minutes()));
                  break;
                case "hour":
                  classNames.push("vis-h" + current.hours() + (this.step == 4 ? "-h" + (current.hours() + 4) : ""));
                  classNames.push(today(current));
                  classNames.push(even(current.hours()));
                  break;
                case "weekday":
                  classNames.push("vis-" + current.format("dddd").toLowerCase());
                  classNames.push(today(current));
                  classNames.push(currentWeek(current));
                  classNames.push(even(current.date()));
                  break;
                case "day":
                  classNames.push("vis-day" + current.date());
                  classNames.push("vis-" + current.format("MMMM").toLowerCase());
                  classNames.push(today(current));
                  classNames.push(currentMonth(current));
                  classNames.push(this.step <= 2 ? today(current) : "");
                  classNames.push(this.step <= 2 ? "vis-" + current.format("dddd").toLowerCase() : "");
                  classNames.push(even(current.date() - 1));
                  break;
                case "week":
                  classNames.push("vis-week" + current.format("w"));
                  classNames.push(currentWeek(current));
                  classNames.push(even(current.week()));
                  break;
                case "month":
                  classNames.push("vis-" + current.format("MMMM").toLowerCase());
                  classNames.push(currentMonth(current));
                  classNames.push(even(current.month()));
                  break;
                case "year":
                  classNames.push("vis-year" + current.year());
                  classNames.push(currentYear(current));
                  classNames.push(even(current.year()));
                  break;
              }
              return classNames.filter(String).join(" ");
            };
            module2.exports = TimeStep;
          },
          /* 67 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(2);
            var Component = __webpack_require__(16);
            var moment = __webpack_require__(9);
            var locales = __webpack_require__(98);
            function CurrentTime(body, options) {
              this.body = body;
              this.defaultOptions = {
                rtl: false,
                showCurrentTime: true,
                moment,
                locales,
                locale: "en"
              };
              this.options = util.extend({}, this.defaultOptions);
              this.offset = 0;
              this._create();
              this.setOptions(options);
            }
            CurrentTime.prototype = new Component();
            CurrentTime.prototype._create = function() {
              var bar = document.createElement("div");
              bar.className = "vis-current-time";
              bar.style.position = "absolute";
              bar.style.top = "0px";
              bar.style.height = "100%";
              this.bar = bar;
            };
            CurrentTime.prototype.destroy = function() {
              this.options.showCurrentTime = false;
              this.redraw();
              this.body = null;
            };
            CurrentTime.prototype.setOptions = function(options) {
              if (options) {
                util.selectiveExtend(["rtl", "showCurrentTime", "moment", "locale", "locales"], this.options, options);
              }
            };
            CurrentTime.prototype.redraw = function() {
              if (this.options.showCurrentTime) {
                var parent = this.body.dom.backgroundVertical;
                if (this.bar.parentNode != parent) {
                  if (this.bar.parentNode) {
                    this.bar.parentNode.removeChild(this.bar);
                  }
                  parent.appendChild(this.bar);
                  this.start();
                }
                var now = this.options.moment((/* @__PURE__ */ new Date()).valueOf() + this.offset);
                var x = this.body.util.toScreen(now);
                var locale = this.options.locales[this.options.locale];
                if (!locale) {
                  if (!this.warned) {
                    console.log("WARNING: options.locales['" + this.options.locale + "'] not found. See http://visjs.org/docs/timeline/#Localization");
                    this.warned = true;
                  }
                  locale = this.options.locales["en"];
                }
                var title = locale.current + " " + locale.time + ": " + now.format("dddd, MMMM Do YYYY, H:mm:ss");
                title = title.charAt(0).toUpperCase() + title.substring(1);
                if (this.options.rtl) {
                  this.bar.style.right = x + "px";
                } else {
                  this.bar.style.left = x + "px";
                }
                this.bar.title = title;
              } else {
                if (this.bar.parentNode) {
                  this.bar.parentNode.removeChild(this.bar);
                }
                this.stop();
              }
              return false;
            };
            CurrentTime.prototype.start = function() {
              var me = this;
              function update() {
                me.stop();
                var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
                var interval = 1 / scale / 10;
                if (interval < 30) interval = 30;
                if (interval > 1e3) interval = 1e3;
                me.redraw();
                me.body.emitter.emit("currentTimeTick");
                me.currentTimeTimer = setTimeout(update, interval);
              }
              update();
            };
            CurrentTime.prototype.stop = function() {
              if (this.currentTimeTimer !== void 0) {
                clearTimeout(this.currentTimeTimer);
                delete this.currentTimeTimer;
              }
            };
            CurrentTime.prototype.setCurrentTime = function(time) {
              var t = util.convert(time, "Date").valueOf();
              var now = (/* @__PURE__ */ new Date()).valueOf();
              this.offset = t - now;
              this.redraw();
            };
            CurrentTime.prototype.getCurrentTime = function() {
              return new Date((/* @__PURE__ */ new Date()).valueOf() + this.offset);
            };
            module2.exports = CurrentTime;
          },
          /* 68 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var stack = __webpack_require__(100);
            function Group(groupId, data, itemSet) {
              this.groupId = groupId;
              this.subgroups = {};
              this.subgroupStack = {};
              this.subgroupStackAll = false;
              this.doInnerStack = false;
              this.subgroupIndex = 0;
              this.subgroupOrderer = data && data.subgroupOrder;
              this.itemSet = itemSet;
              this.isVisible = null;
              this.stackDirty = true;
              if (data && data.nestedGroups) {
                this.nestedGroups = data.nestedGroups;
                if (data.showNested == false) {
                  this.showNested = false;
                } else {
                  this.showNested = true;
                }
              }
              if (data && data.subgroupStack) {
                if (typeof data.subgroupStack === "boolean") {
                  this.doInnerStack = data.subgroupStack;
                  this.subgroupStackAll = data.subgroupStack;
                } else {
                  for (var key in data.subgroupStack) {
                    this.subgroupStack[key] = data.subgroupStack[key];
                    this.doInnerStack = this.doInnerStack || data.subgroupStack[key];
                  }
                }
              }
              this.nestedInGroup = null;
              this.dom = {};
              this.props = {
                label: {
                  width: 0,
                  height: 0
                }
              };
              this.className = null;
              this.items = {};
              this.visibleItems = [];
              this.itemsInRange = [];
              this.orderedItems = {
                byStart: [],
                byEnd: []
              };
              this.checkRangedItems = false;
              var me = this;
              this.itemSet.body.emitter.on("checkRangedItems", function() {
                me.checkRangedItems = true;
              });
              this._create();
              this.setData(data);
            }
            Group.prototype._create = function() {
              var label = document.createElement("div");
              if (this.itemSet.options.groupEditable.order) {
                label.className = "vis-label draggable";
              } else {
                label.className = "vis-label";
              }
              this.dom.label = label;
              var inner = document.createElement("div");
              inner.className = "vis-inner";
              label.appendChild(inner);
              this.dom.inner = inner;
              var foreground = document.createElement("div");
              foreground.className = "vis-group";
              foreground["timeline-group"] = this;
              this.dom.foreground = foreground;
              this.dom.background = document.createElement("div");
              this.dom.background.className = "vis-group";
              this.dom.axis = document.createElement("div");
              this.dom.axis.className = "vis-group";
              this.dom.marker = document.createElement("div");
              this.dom.marker.style.visibility = "hidden";
              this.dom.marker.style.position = "absolute";
              this.dom.marker.innerHTML = "";
              this.dom.background.appendChild(this.dom.marker);
            };
            Group.prototype.setData = function(data) {
              var content;
              var templateFunction;
              if (this.itemSet.options && this.itemSet.options.groupTemplate) {
                templateFunction = this.itemSet.options.groupTemplate.bind(this);
                content = templateFunction(data, this.dom.inner);
              } else {
                content = data && data.content;
              }
              if (content instanceof Element) {
                this.dom.inner.appendChild(content);
                while (this.dom.inner.firstChild) {
                  this.dom.inner.removeChild(this.dom.inner.firstChild);
                }
                this.dom.inner.appendChild(content);
              } else if (content instanceof Object) {
                templateFunction(data, this.dom.inner);
              } else if (content !== void 0 && content !== null) {
                this.dom.inner.innerHTML = content;
              } else {
                this.dom.inner.innerHTML = this.groupId || "";
              }
              this.dom.label.title = data && data.title || "";
              if (!this.dom.inner.firstChild) {
                util.addClassName(this.dom.inner, "vis-hidden");
              } else {
                util.removeClassName(this.dom.inner, "vis-hidden");
              }
              if (data && data.nestedGroups) {
                if (!this.nestedGroups || this.nestedGroups != data.nestedGroups) {
                  this.nestedGroups = data.nestedGroups;
                }
                if (data.showNested !== void 0 || this.showNested === void 0) {
                  if (data.showNested == false) {
                    this.showNested = false;
                  } else {
                    this.showNested = true;
                  }
                }
                util.addClassName(this.dom.label, "vis-nesting-group");
                var collapsedDirClassName = this.itemSet.options.rtl ? "collapsed-rtl" : "collapsed";
                if (this.showNested) {
                  util.removeClassName(this.dom.label, collapsedDirClassName);
                  util.addClassName(this.dom.label, "expanded");
                } else {
                  util.removeClassName(this.dom.label, "expanded");
                  util.addClassName(this.dom.label, collapsedDirClassName);
                }
              } else if (this.nestedGroups) {
                this.nestedGroups = null;
                collapsedDirClassName = this.itemSet.options.rtl ? "collapsed-rtl" : "collapsed";
                util.removeClassName(this.dom.label, collapsedDirClassName);
                util.removeClassName(this.dom.label, "expanded");
                util.removeClassName(this.dom.label, "vis-nesting-group");
              }
              if (data && data.nestedInGroup) {
                util.addClassName(this.dom.label, "vis-nested-group");
                if (this.itemSet.options && this.itemSet.options.rtl) {
                  this.dom.inner.style.paddingRight = "30px";
                } else {
                  this.dom.inner.style.paddingLeft = "30px";
                }
              }
              var className = data && data.className || null;
              if (className != this.className) {
                if (this.className) {
                  util.removeClassName(this.dom.label, this.className);
                  util.removeClassName(this.dom.foreground, this.className);
                  util.removeClassName(this.dom.background, this.className);
                  util.removeClassName(this.dom.axis, this.className);
                }
                util.addClassName(this.dom.label, className);
                util.addClassName(this.dom.foreground, className);
                util.addClassName(this.dom.background, className);
                util.addClassName(this.dom.axis, className);
                this.className = className;
              }
              if (this.style) {
                util.removeCssText(this.dom.label, this.style);
                this.style = null;
              }
              if (data && data.style) {
                util.addCssText(this.dom.label, data.style);
                this.style = data.style;
              }
            };
            Group.prototype.getLabelWidth = function() {
              return this.props.label.width;
            };
            Group.prototype._didMarkerHeightChange = function() {
              var markerHeight = this.dom.marker.clientHeight;
              if (markerHeight != this.lastMarkerHeight) {
                this.lastMarkerHeight = markerHeight;
                var redrawQueue = {};
                var redrawQueueLength = 0;
                util.forEach(this.items, function(item, key) {
                  item.dirty = true;
                  if (item.displayed) {
                    var returnQueue = true;
                    redrawQueue[key] = item.redraw(returnQueue);
                    redrawQueueLength = redrawQueue[key].length;
                  }
                });
                var needRedraw = redrawQueueLength > 0;
                if (needRedraw) {
                  for (var i = 0; i < redrawQueueLength; i++) {
                    util.forEach(redrawQueue, function(fns) {
                      fns[i]();
                    });
                  }
                }
                return true;
              }
            };
            Group.prototype._calculateGroupSizeAndPosition = function() {
              var offsetTop = this.dom.foreground.offsetTop;
              var offsetLeft = this.dom.foreground.offsetLeft;
              var offsetWidth = this.dom.foreground.offsetWidth;
              this.top = offsetTop;
              this.right = offsetLeft;
              this.width = offsetWidth;
            };
            Group.prototype._redrawItems = function(forceRestack, lastIsVisible, margin, range) {
              var restack = forceRestack || this.stackDirty || this.isVisible && !lastIsVisible;
              if (restack) {
                var visibleSubgroups = {};
                var subgroup = null;
                if (typeof this.itemSet.options.order === "function") {
                  var me = this;
                  var limitSize = false;
                  var redrawQueue = {};
                  var redrawQueueLength = 0;
                  util.forEach(this.items, function(item, key) {
                    if (!item.displayed) {
                      var returnQueue = true;
                      redrawQueue[key] = item.redraw(returnQueue);
                      redrawQueueLength = redrawQueue[key].length;
                      me.visibleItems.push(item);
                    }
                  });
                  var needRedraw = redrawQueueLength > 0;
                  if (needRedraw) {
                    for (var i = 0; i < redrawQueueLength; i++) {
                      util.forEach(redrawQueue, function(fns) {
                        fns[i]();
                      });
                    }
                  }
                  util.forEach(this.items, function(item) {
                    item.repositionX(limitSize);
                  });
                  if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
                    for (subgroup in this.subgroups) {
                      visibleSubgroups[subgroup] = this.subgroups[subgroup].items.slice().sort(function(a, b) {
                        return me.itemSet.options.order(a.data, b.data);
                      });
                    }
                    stack.stackSubgroupsWithInnerStack(visibleSubgroups, margin, this.subgroups);
                  } else {
                    var customOrderedItems = this.orderedItems.byStart.slice().sort(function(a, b) {
                      return me.itemSet.options.order(a.data, b.data);
                    });
                    stack.stack(
                      customOrderedItems,
                      margin,
                      true
                      /* restack=true */
                    );
                  }
                  this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, range);
                } else {
                  this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, range);
                  if (this.itemSet.options.stack) {
                    if (this.doInnerStack && this.itemSet.options.stackSubgroups) {
                      for (subgroup in this.subgroups) {
                        visibleSubgroups[subgroup] = this.subgroups[subgroup].items;
                      }
                      stack.stackSubgroupsWithInnerStack(visibleSubgroups, margin, this.subgroups);
                    } else {
                      stack.stack(
                        this.visibleItems,
                        margin,
                        true
                        /* restack=true */
                      );
                    }
                  } else {
                    stack.nostack(this.visibleItems, margin, this.subgroups, this.itemSet.options.stackSubgroups);
                  }
                }
                this.stackDirty = false;
              }
            };
            Group.prototype._didResize = function(resized, height) {
              resized = util.updateProperty(this, "height", height) || resized;
              var labelWidth = this.dom.inner.clientWidth;
              var labelHeight = this.dom.inner.clientHeight;
              resized = util.updateProperty(this.props.label, "width", labelWidth) || resized;
              resized = util.updateProperty(this.props.label, "height", labelHeight) || resized;
              return resized;
            };
            Group.prototype._applyGroupHeight = function(height) {
              this.dom.background.style.height = height + "px";
              this.dom.foreground.style.height = height + "px";
              this.dom.label.style.height = height + "px";
            };
            Group.prototype._updateItemsVerticalPosition = function(margin) {
              for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
                var item = this.visibleItems[i];
                item.repositionY(margin);
                if (!this.isVisible && this.groupId != "__background__") {
                  if (item.displayed) item.hide();
                }
              }
            };
            Group.prototype.redraw = function(range, margin, forceRestack, returnQueue) {
              var resized = false;
              var lastIsVisible = this.isVisible;
              var height;
              var queue = [
                // force recalculation of the height of the items when the marker height changed
                // (due to the Timeline being attached to the DOM or changed from display:none to visible)
                (function() {
                  forceRestack = this._didMarkerHeightChange.bind(this);
                }).bind(this),
                // recalculate the height of the subgroups
                this._updateSubGroupHeights.bind(this, margin),
                // calculate actual size and position
                this._calculateGroupSizeAndPosition.bind(this),
                // check if group is visible
                (function() {
                  this.isVisible = this._isGroupVisible.bind(this)(range, margin);
                }).bind(this),
                // redraw Items if needed
                (function() {
                  this._redrawItems.bind(this)(forceRestack, lastIsVisible, margin, range);
                }).bind(this),
                // update subgroups
                this._updateSubgroupsSizes.bind(this),
                // recalculate the height of the group
                (function() {
                  height = this._calculateHeight.bind(this)(margin);
                }).bind(this),
                // calculate actual size and position again
                this._calculateGroupSizeAndPosition.bind(this),
                // check if resized
                (function() {
                  resized = this._didResize.bind(this)(resized, height);
                }).bind(this),
                // apply group height
                (function() {
                  this._applyGroupHeight.bind(this)(height);
                }).bind(this),
                // update vertical position of items after they are re-stacked and the height of the group is calculated
                (function() {
                  this._updateItemsVerticalPosition.bind(this)(margin);
                }).bind(this),
                function() {
                  if (!this.isVisible && this.height) {
                    resized = false;
                  }
                  return resized;
                }
              ];
              if (returnQueue) {
                return queue;
              } else {
                var result;
                queue.forEach(function(fn) {
                  result = fn();
                });
                return result;
              }
            };
            Group.prototype._updateSubGroupHeights = function(margin) {
              if ((0, _keys2["default"])(this.subgroups).length > 0) {
                var me = this;
                this.resetSubgroups();
                util.forEach(this.visibleItems, function(item) {
                  if (item.data.subgroup !== void 0) {
                    me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height + margin.item.vertical);
                    me.subgroups[item.data.subgroup].visible = true;
                  }
                });
              }
            };
            Group.prototype._isGroupVisible = function(range, margin) {
              return this.top <= range.body.domProps.centerContainer.height - range.body.domProps.scrollTop + margin.axis && this.top + this.height + margin.axis >= -range.body.domProps.scrollTop;
            };
            Group.prototype._calculateHeight = function(margin) {
              var height;
              var itemsInRange = this.visibleItems;
              if (itemsInRange.length > 0) {
                var min = itemsInRange[0].top;
                var max = itemsInRange[0].top + itemsInRange[0].height;
                util.forEach(itemsInRange, function(item) {
                  min = Math.min(min, item.top);
                  max = Math.max(max, item.top + item.height);
                });
                if (min > margin.axis) {
                  var offset = min - margin.axis;
                  max -= offset;
                  util.forEach(itemsInRange, function(item) {
                    item.top -= offset;
                  });
                }
                height = max + margin.item.vertical / 2;
              } else {
                height = 0;
              }
              height = Math.max(height, this.props.label.height);
              return height;
            };
            Group.prototype.show = function() {
              if (!this.dom.label.parentNode) {
                this.itemSet.dom.labelSet.appendChild(this.dom.label);
              }
              if (!this.dom.foreground.parentNode) {
                this.itemSet.dom.foreground.appendChild(this.dom.foreground);
              }
              if (!this.dom.background.parentNode) {
                this.itemSet.dom.background.appendChild(this.dom.background);
              }
              if (!this.dom.axis.parentNode) {
                this.itemSet.dom.axis.appendChild(this.dom.axis);
              }
            };
            Group.prototype.hide = function() {
              var label = this.dom.label;
              if (label.parentNode) {
                label.parentNode.removeChild(label);
              }
              var foreground = this.dom.foreground;
              if (foreground.parentNode) {
                foreground.parentNode.removeChild(foreground);
              }
              var background = this.dom.background;
              if (background.parentNode) {
                background.parentNode.removeChild(background);
              }
              var axis = this.dom.axis;
              if (axis.parentNode) {
                axis.parentNode.removeChild(axis);
              }
            };
            Group.prototype.add = function(item) {
              this.items[item.id] = item;
              item.setParent(this);
              this.stackDirty = true;
              if (item.data.subgroup !== void 0) {
                this._addToSubgroup(item);
                this.orderSubgroups();
              }
              if (this.visibleItems.indexOf(item) == -1) {
                var range = this.itemSet.body.range;
                this._checkIfVisible(item, this.visibleItems, range);
              }
            };
            Group.prototype._addToSubgroup = function(item, subgroupId) {
              subgroupId = subgroupId || item.data.subgroup;
              if (subgroupId != void 0 && this.subgroups[subgroupId] === void 0) {
                this.subgroups[subgroupId] = {
                  height: 0,
                  top: 0,
                  start: item.data.start,
                  end: item.data.end || item.data.start,
                  visible: false,
                  index: this.subgroupIndex,
                  items: [],
                  stack: this.subgroupStackAll || this.subgroupStack[subgroupId] || false
                };
                this.subgroupIndex++;
              }
              if (new Date(item.data.start) < new Date(this.subgroups[subgroupId].start)) {
                this.subgroups[subgroupId].start = item.data.start;
              }
              var itemEnd = item.data.end || item.data.start;
              if (new Date(itemEnd) > new Date(this.subgroups[subgroupId].end)) {
                this.subgroups[subgroupId].end = itemEnd;
              }
              this.subgroups[subgroupId].items.push(item);
            };
            Group.prototype._updateSubgroupsSizes = function() {
              var me = this;
              if (me.subgroups) {
                for (var subgroup in me.subgroups) {
                  var initialEnd = me.subgroups[subgroup].items[0].data.end || me.subgroups[subgroup].items[0].data.start;
                  var newStart = me.subgroups[subgroup].items[0].data.start;
                  var newEnd = initialEnd - 1;
                  me.subgroups[subgroup].items.forEach(function(item) {
                    if (new Date(item.data.start) < new Date(newStart)) {
                      newStart = item.data.start;
                    }
                    var itemEnd = item.data.end || item.data.start;
                    if (new Date(itemEnd) > new Date(newEnd)) {
                      newEnd = itemEnd;
                    }
                  });
                  me.subgroups[subgroup].start = newStart;
                  me.subgroups[subgroup].end = new Date(newEnd - 1);
                }
              }
            };
            Group.prototype.orderSubgroups = function() {
              if (this.subgroupOrderer !== void 0) {
                var sortArray = [];
                var subgroup;
                if (typeof this.subgroupOrderer == "string") {
                  for (subgroup in this.subgroups) {
                    sortArray.push({ subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
                  }
                  sortArray.sort(function(a, b) {
                    return a.sortField - b.sortField;
                  });
                } else if (typeof this.subgroupOrderer == "function") {
                  for (subgroup in this.subgroups) {
                    sortArray.push(this.subgroups[subgroup].items[0].data);
                  }
                  sortArray.sort(this.subgroupOrderer);
                }
                if (sortArray.length > 0) {
                  for (var i = 0; i < sortArray.length; i++) {
                    this.subgroups[sortArray[i].subgroup].index = i;
                  }
                }
              }
            };
            Group.prototype.resetSubgroups = function() {
              for (var subgroup in this.subgroups) {
                if (this.subgroups.hasOwnProperty(subgroup)) {
                  this.subgroups[subgroup].visible = false;
                  this.subgroups[subgroup].height = 0;
                }
              }
            };
            Group.prototype.remove = function(item) {
              delete this.items[item.id];
              item.setParent(null);
              this.stackDirty = true;
              var index = this.visibleItems.indexOf(item);
              if (index != -1) this.visibleItems.splice(index, 1);
              if (item.data.subgroup !== void 0) {
                this._removeFromSubgroup(item);
                this.orderSubgroups();
              }
            };
            Group.prototype._removeFromSubgroup = function(item, subgroupId) {
              subgroupId = subgroupId || item.data.subgroup;
              if (subgroupId != void 0) {
                var subgroup = this.subgroups[subgroupId];
                if (subgroup) {
                  var itemIndex = subgroup.items.indexOf(item);
                  if (itemIndex >= 0) {
                    subgroup.items.splice(itemIndex, 1);
                    if (!subgroup.items.length) {
                      delete this.subgroups[subgroupId];
                    } else {
                      this._updateSubgroupsSizes();
                    }
                  }
                }
              }
            };
            Group.prototype.removeFromDataSet = function(item) {
              this.itemSet.removeItem(item.id);
            };
            Group.prototype.order = function() {
              var array = util.toArray(this.items);
              var startArray = [];
              var endArray = [];
              for (var i = 0; i < array.length; i++) {
                if (array[i].data.end !== void 0) {
                  endArray.push(array[i]);
                }
                startArray.push(array[i]);
              }
              this.orderedItems = {
                byStart: startArray,
                byEnd: endArray
              };
              stack.orderByStart(this.orderedItems.byStart);
              stack.orderByEnd(this.orderedItems.byEnd);
            };
            Group.prototype._updateItemsInRange = function(orderedItems, oldVisibleItems, range) {
              var visibleItems = [];
              var visibleItemsLookup = {};
              var interval = (range.end - range.start) / 4;
              var lowerBound = range.start - interval;
              var upperBound = range.end + interval;
              var searchFunction = function searchFunction2(value) {
                if (value < lowerBound) {
                  return -1;
                } else if (value <= upperBound) {
                  return 0;
                } else {
                  return 1;
                }
              };
              if (oldVisibleItems.length > 0) {
                for (var i = 0; i < oldVisibleItems.length; i++) {
                  this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
                }
              }
              var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, "data", "start");
              this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function(item2) {
                return item2.data.start < lowerBound || item2.data.start > upperBound;
              });
              if (this.checkRangedItems == true) {
                this.checkRangedItems = false;
                for (i = 0; i < orderedItems.byEnd.length; i++) {
                  this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
                }
              } else {
                var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, "data", "end");
                this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function(item2) {
                  return item2.data.end < lowerBound || item2.data.end > upperBound;
                });
              }
              var redrawQueue = {};
              var redrawQueueLength = 0;
              for (i = 0; i < visibleItems.length; i++) {
                var item = visibleItems[i];
                if (!item.displayed) {
                  var returnQueue = true;
                  redrawQueue[i] = item.redraw(returnQueue);
                  redrawQueueLength = redrawQueue[i].length;
                }
              }
              var needRedraw = redrawQueueLength > 0;
              if (needRedraw) {
                for (var j = 0; j < redrawQueueLength; j++) {
                  util.forEach(redrawQueue, function(fns) {
                    fns[j]();
                  });
                }
              }
              for (i = 0; i < visibleItems.length; i++) {
                visibleItems[i].repositionX();
              }
              return visibleItems;
            };
            Group.prototype._traceVisible = function(initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
              if (initialPos != -1) {
                var i, item;
                for (i = initialPos; i >= 0; i--) {
                  item = items[i];
                  if (breakCondition(item)) {
                    break;
                  } else {
                    if (visibleItemsLookup[item.id] === void 0) {
                      visibleItemsLookup[item.id] = true;
                      visibleItems.push(item);
                    }
                  }
                }
                for (i = initialPos + 1; i < items.length; i++) {
                  item = items[i];
                  if (breakCondition(item)) {
                    break;
                  } else {
                    if (visibleItemsLookup[item.id] === void 0) {
                      visibleItemsLookup[item.id] = true;
                      visibleItems.push(item);
                    }
                  }
                }
              }
            };
            Group.prototype._checkIfVisible = function(item, visibleItems, range) {
              if (item.isVisible(range)) {
                if (!item.displayed) item.show();
                item.repositionX();
                visibleItems.push(item);
              } else {
                if (item.displayed) item.hide();
              }
            };
            Group.prototype._checkIfVisibleWithReference = function(item, visibleItems, visibleItemsLookup, range) {
              if (item.isVisible(range)) {
                if (visibleItemsLookup[item.id] === void 0) {
                  visibleItemsLookup[item.id] = true;
                  visibleItems.push(item);
                }
              } else {
                if (item.displayed) item.hide();
              }
            };
            Group.prototype.changeSubgroup = function(item, oldSubgroup, newSubgroup) {
              this._removeFromSubgroup(item, oldSubgroup);
              this._addToSubgroup(item, newSubgroup);
              this.orderSubgroups();
            };
            module2.exports = Group;
          },
          /* 69 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Group = __webpack_require__(68);
            function BackgroundGroup(groupId, data, itemSet) {
              Group.call(this, groupId, data, itemSet);
              this.width = 0;
              this.height = 0;
              this.top = 0;
              this.left = 0;
            }
            BackgroundGroup.prototype = (0, _create2["default"])(Group.prototype);
            BackgroundGroup.prototype.redraw = function(range, margin, forceRestack) {
              var resized = false;
              this.visibleItems = this._updateItemsInRange(this.orderedItems, this.visibleItems, range);
              this.width = this.dom.background.offsetWidth;
              this.dom.background.style.height = "0";
              for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
                var item = this.visibleItems[i];
                item.repositionY(margin);
              }
              return resized;
            };
            BackgroundGroup.prototype.show = function() {
              if (!this.dom.background.parentNode) {
                this.itemSet.dom.background.appendChild(this.dom.background);
              }
            };
            module2.exports = BackgroundGroup;
          },
          /* 70 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Item = __webpack_require__(38);
            function RangeItem(data, conversion, options) {
              this.props = {
                content: {
                  width: 0
                }
              };
              this.overflow = false;
              this.options = options;
              if (data) {
                if (data.start == void 0) {
                  throw new Error('Property "start" missing in item ' + data.id);
                }
                if (data.end == void 0) {
                  throw new Error('Property "end" missing in item ' + data.id);
                }
              }
              Item.call(this, data, conversion, options);
            }
            RangeItem.prototype = new Item(null, null, null);
            RangeItem.prototype.baseClassName = "vis-item vis-range";
            RangeItem.prototype.isVisible = function(range) {
              return this.data.start < range.end && this.data.end > range.start;
            };
            RangeItem.prototype._createDomElement = function() {
              if (!this.dom) {
                this.dom = {};
                this.dom.box = document.createElement("div");
                this.dom.frame = document.createElement("div");
                this.dom.frame.className = "vis-item-overflow";
                this.dom.box.appendChild(this.dom.frame);
                this.dom.visibleFrame = document.createElement("div");
                this.dom.visibleFrame.className = "vis-item-visible-frame";
                this.dom.box.appendChild(this.dom.visibleFrame);
                this.dom.content = document.createElement("div");
                this.dom.content.className = "vis-item-content";
                this.dom.frame.appendChild(this.dom.content);
                this.dom.box["timeline-item"] = this;
                this.dirty = true;
              }
            };
            RangeItem.prototype._appendDomElement = function() {
              if (!this.parent) {
                throw new Error("Cannot redraw item: no parent attached");
              }
              if (!this.dom.box.parentNode) {
                var foreground = this.parent.dom.foreground;
                if (!foreground) {
                  throw new Error("Cannot redraw item: parent has no foreground container element");
                }
                foreground.appendChild(this.dom.box);
              }
              this.displayed = true;
            };
            RangeItem.prototype._updateDirtyDomComponents = function() {
              if (this.dirty) {
                this._updateContents(this.dom.content);
                this._updateDataAttributes(this.dom.box);
                this._updateStyle(this.dom.box);
                var editable = this.editable.updateTime || this.editable.updateGroup;
                var className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
                this.dom.box.className = this.baseClassName + className;
                this.dom.content.style.maxWidth = "none";
              }
            };
            RangeItem.prototype._getDomComponentsSizes = function() {
              this.overflow = window.getComputedStyle(this.dom.frame).overflow !== "hidden";
              return {
                content: {
                  width: this.dom.content.offsetWidth
                },
                box: {
                  height: this.dom.box.offsetHeight
                }
              };
            };
            RangeItem.prototype._updateDomComponentsSizes = function(sizes) {
              this.props.content.width = sizes.content.width;
              this.height = sizes.box.height;
              this.dom.content.style.maxWidth = "";
              this.dirty = false;
            };
            RangeItem.prototype._repaintDomAdditionals = function() {
              this._repaintOnItemUpdateTimeTooltip(this.dom.box);
              this._repaintDeleteButton(this.dom.box);
              this._repaintDragCenter();
              this._repaintDragLeft();
              this._repaintDragRight();
            };
            RangeItem.prototype.redraw = function(returnQueue) {
              var sizes;
              var queue = [
                // create item DOM
                this._createDomElement.bind(this),
                // append DOM to parent DOM
                this._appendDomElement.bind(this),
                // update dirty DOM 
                this._updateDirtyDomComponents.bind(this),
                (function() {
                  if (this.dirty) {
                    sizes = this._getDomComponentsSizes.bind(this)();
                  }
                }).bind(this),
                (function() {
                  if (this.dirty) {
                    this._updateDomComponentsSizes.bind(this)(sizes);
                  }
                }).bind(this),
                // repaint DOM additionals
                this._repaintDomAdditionals.bind(this)
              ];
              if (returnQueue) {
                return queue;
              } else {
                var result;
                queue.forEach(function(fn) {
                  result = fn();
                });
                return result;
              }
            };
            RangeItem.prototype.show = function() {
              if (!this.displayed) {
                this.redraw();
              }
            };
            RangeItem.prototype.hide = function() {
              if (this.displayed) {
                var box = this.dom.box;
                if (box.parentNode) {
                  box.parentNode.removeChild(box);
                }
                this.displayed = false;
              }
            };
            RangeItem.prototype.repositionX = function(limitSize) {
              var parentWidth = this.parent.width;
              var start = this.conversion.toScreen(this.data.start);
              var end = this.conversion.toScreen(this.data.end);
              var align = this.data.align === void 0 ? this.options.align : this.data.align;
              var contentStartPosition;
              var contentWidth;
              if (this.data.limitSize !== false && (limitSize === void 0 || limitSize === true)) {
                if (start < -parentWidth) {
                  start = -parentWidth;
                }
                if (end > 2 * parentWidth) {
                  end = 2 * parentWidth;
                }
              }
              var boxWidth = Math.max(end - start + 0.5, 1);
              if (this.overflow) {
                if (this.options.rtl) {
                  this.right = start;
                } else {
                  this.left = start;
                }
                this.width = boxWidth + this.props.content.width;
                contentWidth = this.props.content.width;
              } else {
                if (this.options.rtl) {
                  this.right = start;
                } else {
                  this.left = start;
                }
                this.width = boxWidth;
                contentWidth = Math.min(end - start, this.props.content.width);
              }
              if (this.options.rtl) {
                this.dom.box.style.right = this.right + "px";
              } else {
                this.dom.box.style.left = this.left + "px";
              }
              this.dom.box.style.width = boxWidth + "px";
              switch (align) {
                case "left":
                  if (this.options.rtl) {
                    this.dom.content.style.right = "0";
                  } else {
                    this.dom.content.style.left = "0";
                  }
                  break;
                case "right":
                  if (this.options.rtl) {
                    this.dom.content.style.right = Math.max(boxWidth - contentWidth, 0) + "px";
                  } else {
                    this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + "px";
                  }
                  break;
                case "center":
                  if (this.options.rtl) {
                    this.dom.content.style.right = Math.max((boxWidth - contentWidth) / 2, 0) + "px";
                  } else {
                    this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + "px";
                  }
                  break;
                default:
                  if (this.overflow) {
                    if (end > 0) {
                      contentStartPosition = Math.max(-start, 0);
                    } else {
                      contentStartPosition = -contentWidth;
                    }
                  } else {
                    if (start < 0) {
                      contentStartPosition = -start;
                    } else {
                      contentStartPosition = 0;
                    }
                  }
                  if (this.options.rtl) {
                    this.dom.content.style.right = contentStartPosition + "px";
                  } else {
                    this.dom.content.style.left = contentStartPosition + "px";
                    this.dom.content.style.width = "calc(100% - " + contentStartPosition + "px)";
                  }
              }
            };
            RangeItem.prototype.repositionY = function() {
              var orientation = this.options.orientation.item;
              var box = this.dom.box;
              if (orientation == "top") {
                box.style.top = this.top + "px";
              } else {
                box.style.top = this.parent.height - this.top - this.height + "px";
              }
            };
            RangeItem.prototype._repaintDragLeft = function() {
              if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragLeft) {
                var dragLeft = document.createElement("div");
                dragLeft.className = "vis-drag-left";
                dragLeft.dragLeftItem = this;
                this.dom.box.appendChild(dragLeft);
                this.dom.dragLeft = dragLeft;
              } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragLeft) {
                if (this.dom.dragLeft.parentNode) {
                  this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
                }
                this.dom.dragLeft = null;
              }
            };
            RangeItem.prototype._repaintDragRight = function() {
              if ((this.selected || this.options.itemsAlwaysDraggable.range) && this.options.editable.updateTime && !this.dom.dragRight) {
                var dragRight = document.createElement("div");
                dragRight.className = "vis-drag-right";
                dragRight.dragRightItem = this;
                this.dom.box.appendChild(dragRight);
                this.dom.dragRight = dragRight;
              } else if (!this.selected && !this.options.itemsAlwaysDraggable.range && this.dom.dragRight) {
                if (this.dom.dragRight.parentNode) {
                  this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
                }
                this.dom.dragRight = null;
              }
            };
            module2.exports = RangeItem;
          },
          /* 71 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ColorPicker = __webpack_require__(179)["default"];
            var Configurator = function() {
              function Configurator2(parentModule, defaultContainer, configureOptions) {
                var pixelRatio = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
                (0, _classCallCheck3["default"])(this, Configurator2);
                this.parent = parentModule;
                this.changedOptions = [];
                this.container = defaultContainer;
                this.allowCreation = false;
                this.options = {};
                this.initialized = false;
                this.popupCounter = 0;
                this.defaultOptions = {
                  enabled: false,
                  filter: true,
                  container: void 0,
                  showButton: true
                };
                util.extend(this.options, this.defaultOptions);
                this.configureOptions = configureOptions;
                this.moduleOptions = {};
                this.domElements = [];
                this.popupDiv = {};
                this.popupLimit = 5;
                this.popupHistory = {};
                this.colorPicker = new ColorPicker(pixelRatio);
                this.wrapper = void 0;
              }
              (0, _createClass3["default"])(Configurator2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    this.popupHistory = {};
                    this._removePopup();
                    var enabled = true;
                    if (typeof options === "string") {
                      this.options.filter = options;
                    } else if (options instanceof Array) {
                      this.options.filter = options.join();
                    } else if ((typeof options === "undefined" ? "undefined" : (0, _typeof3["default"])(options)) === "object") {
                      if (options.container !== void 0) {
                        this.options.container = options.container;
                      }
                      if (options.filter !== void 0) {
                        this.options.filter = options.filter;
                      }
                      if (options.showButton !== void 0) {
                        this.options.showButton = options.showButton;
                      }
                      if (options.enabled !== void 0) {
                        enabled = options.enabled;
                      }
                    } else if (typeof options === "boolean") {
                      this.options.filter = true;
                      enabled = options;
                    } else if (typeof options === "function") {
                      this.options.filter = options;
                      enabled = true;
                    }
                    if (this.options.filter === false) {
                      enabled = false;
                    }
                    this.options.enabled = enabled;
                  }
                  this._clean();
                }
                /**
                 *
                 * @param {Object} moduleOptions
                 */
              }, {
                key: "setModuleOptions",
                value: function setModuleOptions(moduleOptions) {
                  this.moduleOptions = moduleOptions;
                  if (this.options.enabled === true) {
                    this._clean();
                    if (this.options.container !== void 0) {
                      this.container = this.options.container;
                    }
                    this._create();
                  }
                }
                /**
                 * Create all DOM elements
                 * @private
                 */
              }, {
                key: "_create",
                value: function _create() {
                  var _this = this;
                  this._clean();
                  this.changedOptions = [];
                  var filter = this.options.filter;
                  var counter = 0;
                  var show = false;
                  for (var option in this.configureOptions) {
                    if (this.configureOptions.hasOwnProperty(option)) {
                      this.allowCreation = false;
                      show = false;
                      if (typeof filter === "function") {
                        show = filter(option, []);
                        show = show || this._handleObject(this.configureOptions[option], [option], true);
                      } else if (filter === true || filter.indexOf(option) !== -1) {
                        show = true;
                      }
                      if (show !== false) {
                        this.allowCreation = true;
                        if (counter > 0) {
                          this._makeItem([]);
                        }
                        this._makeHeader(option);
                        this._handleObject(this.configureOptions[option], [option]);
                      }
                      counter++;
                    }
                  }
                  if (this.options.showButton === true) {
                    var generateButton = document.createElement("div");
                    generateButton.className = "vis-configuration vis-config-button";
                    generateButton.innerHTML = "generate options";
                    generateButton.onclick = function() {
                      _this._printOptions();
                    };
                    generateButton.onmouseover = function() {
                      generateButton.className = "vis-configuration vis-config-button hover";
                    };
                    generateButton.onmouseout = function() {
                      generateButton.className = "vis-configuration vis-config-button";
                    };
                    this.optionsContainer = document.createElement("div");
                    this.optionsContainer.className = "vis-configuration vis-config-option-container";
                    this.domElements.push(this.optionsContainer);
                    this.domElements.push(generateButton);
                  }
                  this._push();
                }
                /**
                 * draw all DOM elements on the screen
                 * @private
                 */
              }, {
                key: "_push",
                value: function _push() {
                  this.wrapper = document.createElement("div");
                  this.wrapper.className = "vis-configuration-wrapper";
                  this.container.appendChild(this.wrapper);
                  for (var i = 0; i < this.domElements.length; i++) {
                    this.wrapper.appendChild(this.domElements[i]);
                  }
                  this._showPopupIfNeeded();
                }
                /**
                 * delete all DOM elements
                 * @private
                 */
              }, {
                key: "_clean",
                value: function _clean() {
                  for (var i = 0; i < this.domElements.length; i++) {
                    this.wrapper.removeChild(this.domElements[i]);
                  }
                  if (this.wrapper !== void 0) {
                    this.container.removeChild(this.wrapper);
                    this.wrapper = void 0;
                  }
                  this.domElements = [];
                  this._removePopup();
                }
                /**
                 * get the value from the actualOptions if it exists
                 * @param {array} path    | where to look for the actual option
                 * @returns {*}
                 * @private
                 */
              }, {
                key: "_getValue",
                value: function _getValue(path) {
                  var base = this.moduleOptions;
                  for (var i = 0; i < path.length; i++) {
                    if (base[path[i]] !== void 0) {
                      base = base[path[i]];
                    } else {
                      base = void 0;
                      break;
                    }
                  }
                  return base;
                }
                /**
                 * all option elements are wrapped in an item
                 * @param {Array} path    | where to look for the actual option
                 * @param {Array.<Element>} domElements
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_makeItem",
                value: function _makeItem(path) {
                  if (this.allowCreation === true) {
                    var item = document.createElement("div");
                    item.className = "vis-configuration vis-config-item vis-config-s" + path.length;
                    for (var _len = arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      domElements[_key - 1] = arguments[_key];
                    }
                    domElements.forEach(function(element) {
                      item.appendChild(element);
                    });
                    this.domElements.push(item);
                    return this.domElements.length;
                  }
                  return 0;
                }
                /**
                 * header for major subjects
                 * @param {string} name
                 * @private
                 */
              }, {
                key: "_makeHeader",
                value: function _makeHeader(name) {
                  var div = document.createElement("div");
                  div.className = "vis-configuration vis-config-header";
                  div.innerHTML = name;
                  this._makeItem([], div);
                }
                /**
                 * make a label, if it is an object label, it gets different styling.
                 * @param {string} name
                 * @param {array} path    | where to look for the actual option
                 * @param {string} objectLabel
                 * @returns {HTMLElement}
                 * @private
                 */
              }, {
                key: "_makeLabel",
                value: function _makeLabel(name, path) {
                  var objectLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var div = document.createElement("div");
                  div.className = "vis-configuration vis-config-label vis-config-s" + path.length;
                  if (objectLabel === true) {
                    div.innerHTML = "<i><b>" + name + ":</b></i>";
                  } else {
                    div.innerHTML = name + ":";
                  }
                  return div;
                }
                /**
                 * make a dropdown list for multiple possible string optoins
                 * @param {Array.<number>} arr
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_makeDropdown",
                value: function _makeDropdown(arr, value, path) {
                  var select = document.createElement("select");
                  select.className = "vis-configuration vis-config-select";
                  var selectedValue = 0;
                  if (value !== void 0) {
                    if (arr.indexOf(value) !== -1) {
                      selectedValue = arr.indexOf(value);
                    }
                  }
                  for (var i = 0; i < arr.length; i++) {
                    var option = document.createElement("option");
                    option.value = arr[i];
                    if (i === selectedValue) {
                      option.selected = "selected";
                    }
                    option.innerHTML = arr[i];
                    select.appendChild(option);
                  }
                  var me = this;
                  select.onchange = function() {
                    me._update(this.value, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, select);
                }
                /**
                 * make a range object for numeric options
                 * @param {Array.<number>} arr
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_makeRange",
                value: function _makeRange(arr, value, path) {
                  var defaultValue = arr[0];
                  var min = arr[1];
                  var max = arr[2];
                  var step = arr[3];
                  var range = document.createElement("input");
                  range.className = "vis-configuration vis-config-range";
                  try {
                    range.type = "range";
                    range.min = min;
                    range.max = max;
                  } catch (err) {
                  }
                  range.step = step;
                  var popupString = "";
                  var popupValue = 0;
                  if (value !== void 0) {
                    var factor = 1.2;
                    if (value < 0 && value * factor < min) {
                      range.min = Math.ceil(value * factor);
                      popupValue = range.min;
                      popupString = "range increased";
                    } else if (value / factor < min) {
                      range.min = Math.ceil(value / factor);
                      popupValue = range.min;
                      popupString = "range increased";
                    }
                    if (value * factor > max && max !== 1) {
                      range.max = Math.ceil(value * factor);
                      popupValue = range.max;
                      popupString = "range increased";
                    }
                    range.value = value;
                  } else {
                    range.value = defaultValue;
                  }
                  var input = document.createElement("input");
                  input.className = "vis-configuration vis-config-rangeinput";
                  input.value = range.value;
                  var me = this;
                  range.onchange = function() {
                    input.value = this.value;
                    me._update(Number(this.value), path);
                  };
                  range.oninput = function() {
                    input.value = this.value;
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  var itemIndex = this._makeItem(path, label, range, input);
                  if (popupString !== "" && this.popupHistory[itemIndex] !== popupValue) {
                    this.popupHistory[itemIndex] = popupValue;
                    this._setupPopup(popupString, itemIndex);
                  }
                }
                /**
                 * prepare the popup
                 * @param {string} string
                 * @param {number} index
                 * @private
                 */
              }, {
                key: "_setupPopup",
                value: function _setupPopup(string, index) {
                  var _this2 = this;
                  if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
                    var div = document.createElement("div");
                    div.id = "vis-configuration-popup";
                    div.className = "vis-configuration-popup";
                    div.innerHTML = string;
                    div.onclick = function() {
                      _this2._removePopup();
                    };
                    this.popupCounter += 1;
                    this.popupDiv = { html: div, index };
                  }
                }
                /**
                 * remove the popup from the dom
                 * @private
                 */
              }, {
                key: "_removePopup",
                value: function _removePopup() {
                  if (this.popupDiv.html !== void 0) {
                    this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
                    clearTimeout(this.popupDiv.hideTimeout);
                    clearTimeout(this.popupDiv.deleteTimeout);
                    this.popupDiv = {};
                  }
                }
                /**
                 * Show the popup if it is needed.
                 * @private
                 */
              }, {
                key: "_showPopupIfNeeded",
                value: function _showPopupIfNeeded() {
                  var _this3 = this;
                  if (this.popupDiv.html !== void 0) {
                    var correspondingElement = this.domElements[this.popupDiv.index];
                    var rect = correspondingElement.getBoundingClientRect();
                    this.popupDiv.html.style.left = rect.left + "px";
                    this.popupDiv.html.style.top = rect.top - 30 + "px";
                    document.body.appendChild(this.popupDiv.html);
                    this.popupDiv.hideTimeout = setTimeout(function() {
                      _this3.popupDiv.html.style.opacity = 0;
                    }, 1500);
                    this.popupDiv.deleteTimeout = setTimeout(function() {
                      _this3._removePopup();
                    }, 1800);
                  }
                }
                /**
                 * make a checkbox for boolean options.
                 * @param {number} defaultValue
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_makeCheckbox",
                value: function _makeCheckbox(defaultValue, value, path) {
                  var checkbox = document.createElement("input");
                  checkbox.type = "checkbox";
                  checkbox.className = "vis-configuration vis-config-checkbox";
                  checkbox.checked = defaultValue;
                  if (value !== void 0) {
                    checkbox.checked = value;
                    if (value !== defaultValue) {
                      if ((typeof defaultValue === "undefined" ? "undefined" : (0, _typeof3["default"])(defaultValue)) === "object") {
                        if (value !== defaultValue.enabled) {
                          this.changedOptions.push({ path, value });
                        }
                      } else {
                        this.changedOptions.push({ path, value });
                      }
                    }
                  }
                  var me = this;
                  checkbox.onchange = function() {
                    me._update(this.checked, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, checkbox);
                }
                /**
                 * make a text input field for string options.
                 * @param {number} defaultValue
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_makeTextInput",
                value: function _makeTextInput(defaultValue, value, path) {
                  var checkbox = document.createElement("input");
                  checkbox.type = "text";
                  checkbox.className = "vis-configuration vis-config-text";
                  checkbox.value = value;
                  if (value !== defaultValue) {
                    this.changedOptions.push({ path, value });
                  }
                  var me = this;
                  checkbox.onchange = function() {
                    me._update(this.value, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, checkbox);
                }
                /**
                 * make a color field with a color picker for color fields
                 * @param {Array.<number>} arr
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_makeColorField",
                value: function _makeColorField(arr, value, path) {
                  var _this4 = this;
                  var defaultColor = arr[1];
                  var div = document.createElement("div");
                  value = value === void 0 ? defaultColor : value;
                  if (value !== "none") {
                    div.className = "vis-configuration vis-config-colorBlock";
                    div.style.backgroundColor = value;
                  } else {
                    div.className = "vis-configuration vis-config-colorBlock none";
                  }
                  value = value === void 0 ? defaultColor : value;
                  div.onclick = function() {
                    _this4._showColorPicker(value, div, path);
                  };
                  var label = this._makeLabel(path[path.length - 1], path);
                  this._makeItem(path, label, div);
                }
                /**
                 * used by the color buttons to call the color picker.
                 * @param {number} value
                 * @param {HTMLElement} div
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_showColorPicker",
                value: function _showColorPicker(value, div, path) {
                  var _this5 = this;
                  div.onclick = function() {
                  };
                  this.colorPicker.insertTo(div);
                  this.colorPicker.show();
                  this.colorPicker.setColor(value);
                  this.colorPicker.setUpdateCallback(function(color) {
                    var colorString = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
                    div.style.backgroundColor = colorString;
                    _this5._update(colorString, path);
                  });
                  this.colorPicker.setCloseCallback(function() {
                    div.onclick = function() {
                      _this5._showColorPicker(value, div, path);
                    };
                  });
                }
                /**
                 * parse an object and draw the correct items
                 * @param {Object} obj
                 * @param {array} [path=[]]    | where to look for the actual option
                 * @param {boolean} [checkOnly=false]
                 * @returns {boolean}
                 * @private
                 */
              }, {
                key: "_handleObject",
                value: function _handleObject(obj) {
                  var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var checkOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var show = false;
                  var filter = this.options.filter;
                  var visibleInSet = false;
                  for (var subObj in obj) {
                    if (obj.hasOwnProperty(subObj)) {
                      show = true;
                      var item = obj[subObj];
                      var newPath = util.copyAndExtendArray(path, subObj);
                      if (typeof filter === "function") {
                        show = filter(subObj, path);
                        if (show === false) {
                          if (!(item instanceof Array) && typeof item !== "string" && typeof item !== "boolean" && item instanceof Object) {
                            this.allowCreation = false;
                            show = this._handleObject(item, newPath, true);
                            this.allowCreation = checkOnly === false;
                          }
                        }
                      }
                      if (show !== false) {
                        visibleInSet = true;
                        var value = this._getValue(newPath);
                        if (item instanceof Array) {
                          this._handleArray(item, value, newPath);
                        } else if (typeof item === "string") {
                          this._makeTextInput(item, value, newPath);
                        } else if (typeof item === "boolean") {
                          this._makeCheckbox(item, value, newPath);
                        } else if (item instanceof Object) {
                          var draw = true;
                          if (path.indexOf("physics") !== -1) {
                            if (this.moduleOptions.physics.solver !== subObj) {
                              draw = false;
                            }
                          }
                          if (draw === true) {
                            if (item.enabled !== void 0) {
                              var enabledPath = util.copyAndExtendArray(newPath, "enabled");
                              var enabledValue = this._getValue(enabledPath);
                              if (enabledValue === true) {
                                var label = this._makeLabel(subObj, newPath, true);
                                this._makeItem(newPath, label);
                                visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                              } else {
                                this._makeCheckbox(item, enabledValue, newPath);
                              }
                            } else {
                              var _label = this._makeLabel(subObj, newPath, true);
                              this._makeItem(newPath, _label);
                              visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                            }
                          }
                        } else {
                          console.error("dont know how to handle", item, subObj, newPath);
                        }
                      }
                    }
                  }
                  return visibleInSet;
                }
                /**
                 * handle the array type of option
                 * @param {Array.<number>} arr
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_handleArray",
                value: function _handleArray(arr, value, path) {
                  if (typeof arr[0] === "string" && arr[0] === "color") {
                    this._makeColorField(arr, value, path);
                    if (arr[1] !== value) {
                      this.changedOptions.push({ path, value });
                    }
                  } else if (typeof arr[0] === "string") {
                    this._makeDropdown(arr, value, path);
                    if (arr[0] !== value) {
                      this.changedOptions.push({ path, value });
                    }
                  } else if (typeof arr[0] === "number") {
                    this._makeRange(arr, value, path);
                    if (arr[0] !== value) {
                      this.changedOptions.push({ path, value: Number(value) });
                    }
                  }
                }
                /**
                 * called to update the network with the new settings.
                 * @param {number} value
                 * @param {array} path    | where to look for the actual option
                 * @private
                 */
              }, {
                key: "_update",
                value: function _update(value, path) {
                  var options = this._constructOptions(value, path);
                  if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
                    this.parent.body.emitter.emit("configChange", options);
                  }
                  this.initialized = true;
                  this.parent.setOptions(options);
                }
                /**
                 *
                 * @param {string|Boolean} value
                 * @param {Array.<string>} path
                 * @param {{}} optionsObj
                 * @returns {{}}
                 * @private
                 */
              }, {
                key: "_constructOptions",
                value: function _constructOptions(value, path) {
                  var optionsObj = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  var pointer = optionsObj;
                  value = value === "true" ? true : value;
                  value = value === "false" ? false : value;
                  for (var i = 0; i < path.length; i++) {
                    if (path[i] !== "global") {
                      if (pointer[path[i]] === void 0) {
                        pointer[path[i]] = {};
                      }
                      if (i !== path.length - 1) {
                        pointer = pointer[path[i]];
                      } else {
                        pointer[path[i]] = value;
                      }
                    }
                  }
                  return optionsObj;
                }
                /**
                 * @private
                 */
              }, {
                key: "_printOptions",
                value: function _printOptions() {
                  var options = this.getOptions();
                  this.optionsContainer.innerHTML = "<pre>var options = " + (0, _stringify2["default"])(options, null, 2) + "</pre>";
                }
                /**
                 *
                 * @returns {{}} options
                 */
              }, {
                key: "getOptions",
                value: function getOptions() {
                  var options = {};
                  for (var i = 0; i < this.changedOptions.length; i++) {
                    this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
                  }
                  return options;
                }
              }]);
              return Configurator2;
            }();
            exports2["default"] = Configurator;
          },
          /* 72 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var DOMutil = __webpack_require__(14);
            function Points(groupId, options) {
            }
            Points.draw = function(dataset, group, framework, offset) {
              offset = offset || 0;
              var callback = getCallback(framework, group);
              for (var i = 0; i < dataset.length; i++) {
                if (!callback) {
                  DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group), framework.svgElements, framework.svg, dataset[i].label);
                } else {
                  var callbackResult = callback(dataset[i], group);
                  if (callbackResult === true || (typeof callbackResult === "undefined" ? "undefined" : (0, _typeof3["default"])(callbackResult)) === "object") {
                    DOMutil.drawPoint(dataset[i].screen_x + offset, dataset[i].screen_y, getGroupTemplate(group, callbackResult), framework.svgElements, framework.svg, dataset[i].label);
                  }
                }
              }
            };
            Points.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
              var fillHeight = iconHeight * 0.5;
              var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
              outline.setAttributeNS(null, "x", x);
              outline.setAttributeNS(null, "y", y - fillHeight);
              outline.setAttributeNS(null, "width", iconWidth);
              outline.setAttributeNS(null, "height", 2 * fillHeight);
              outline.setAttributeNS(null, "class", "vis-outline");
              DOMutil.drawPoint(x + 0.5 * iconWidth, y, getGroupTemplate(group), framework.svgElements, framework.svg);
            };
            function getGroupTemplate(group, callbackResult) {
              callbackResult = typeof callbackResult === "undefined" ? {} : callbackResult;
              return {
                style: callbackResult.style || group.options.drawPoints.style,
                styles: callbackResult.styles || group.options.drawPoints.styles,
                size: callbackResult.size || group.options.drawPoints.size,
                className: callbackResult.className || group.className
              };
            }
            function getCallback(framework, group) {
              var callback = void 0;
              if (framework.options && framework.options.drawPoints && framework.options.drawPoints.onRender && typeof framework.options.drawPoints.onRender == "function") {
                callback = framework.options.drawPoints.onRender;
              }
              if (group.group.options && group.group.options.drawPoints && group.group.options.drawPoints.onRender && typeof group.group.options.drawPoints.onRender == "function") {
                callback = group.group.options.drawPoints.onRender;
              }
              return callback;
            }
            module2.exports = Points;
          },
          /* 73 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CircleImageBase = function(_NodeBase) {
              (0, _inherits3["default"])(CircleImageBase2, _NodeBase);
              function CircleImageBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CircleImageBase2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (CircleImageBase2.__proto__ || (0, _getPrototypeOf2["default"])(CircleImageBase2)).call(this, options, body, labelModule));
                _this.labelOffset = 0;
                _this.selected = false;
                return _this;
              }
              (0, _createClass3["default"])(CircleImageBase2, [{
                key: "setOptions",
                value: function setOptions(options, imageObj, imageObjAlt) {
                  this.options = options;
                  if (!(imageObj === void 0 && imageObjAlt === void 0)) {
                    this.setImages(imageObj, imageObjAlt);
                  }
                }
                /**
                 * Set the images for this node.
                 *
                 * The images can be updated after the initial setting of options;
                 * therefore, this method needs to be reentrant. 
                 *
                 * For correct working in error cases, it is necessary to properly set
                 * field 'nodes.brokenImage' in the options.
                 *
                 * @param {Image} imageObj  required; main image to show for this node
                 * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
                 */
              }, {
                key: "setImages",
                value: function setImages(imageObj, imageObjAlt) {
                  if (imageObjAlt && this.selected) {
                    this.imageObj = imageObjAlt;
                    this.imageObjAlt = imageObj;
                  } else {
                    this.imageObj = imageObj;
                    this.imageObjAlt = imageObjAlt;
                  }
                }
                /**
                 * Set selection and switch between the base and the selected image.
                 *
                 * Do the switch only if imageObjAlt exists.
                 *
                 * @param {boolean} selected value of new selected state for current node
                 */
              }, {
                key: "switchImages",
                value: function switchImages(selected) {
                  var selection_changed = selected && !this.selected || !selected && this.selected;
                  this.selected = selected;
                  if (this.imageObjAlt !== void 0 && selection_changed) {
                    var imageTmp = this.imageObj;
                    this.imageObj = this.imageObjAlt;
                    this.imageObjAlt = imageTmp;
                  }
                }
                /**
                 * Adjust the node dimensions for a loaded image.
                 *
                 * Pre: this.imageObj is valid
                 */
              }, {
                key: "_resizeImage",
                value: function _resizeImage() {
                  var width, height;
                  if (this.options.shapeProperties.useImageSize === false) {
                    var ratio_width = 1;
                    var ratio_height = 1;
                    if (this.imageObj.width && this.imageObj.height) {
                      if (this.imageObj.width > this.imageObj.height) {
                        ratio_width = this.imageObj.width / this.imageObj.height;
                      } else {
                        ratio_height = this.imageObj.height / this.imageObj.width;
                      }
                    }
                    width = this.options.size * 2 * ratio_width;
                    height = this.options.size * 2 * ratio_height;
                  } else {
                    width = this.imageObj.width;
                    height = this.imageObj.height;
                  }
                  this.width = width;
                  this.height = height;
                  this.radius = 0.5 * this.width;
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @private
                 */
              }, {
                key: "_drawRawCircle",
                value: function _drawRawCircle(ctx, x, y, values) {
                  this.initContextForDraw(ctx, values);
                  ctx.circle(x, y, values.size);
                  this.performFill(ctx, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @private
                 */
              }, {
                key: "_drawImageAtPosition",
                value: function _drawImageAtPosition(ctx, values) {
                  if (this.imageObj.width != 0) {
                    ctx.globalAlpha = 1;
                    this.enableShadow(ctx, values);
                    var factor = 1;
                    if (this.options.shapeProperties.interpolation === true) {
                      factor = this.imageObj.width / this.width / this.body.view.scale;
                    }
                    this.imageObj.drawImageAtPosition(ctx, factor, this.left, this.top, this.width, this.height);
                    this.disableShadow(ctx, values);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @private
                 */
              }, {
                key: "_drawImageLabel",
                value: function _drawImageLabel(ctx, x, y, selected, hover) {
                  var yLabel;
                  var offset = 0;
                  if (this.height !== void 0) {
                    offset = this.height * 0.5;
                    var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);
                    if (labelDimensions.lineCount >= 1) {
                      offset += labelDimensions.height / 2;
                    }
                  }
                  yLabel = y + offset;
                  if (this.options.label) {
                    this.labelOffset = offset;
                  }
                  this.labelModule.draw(ctx, x, yLabel, selected, hover, "hanging");
                }
              }]);
              return CircleImageBase2;
            }(_NodeBase3["default"]);
            exports2["default"] = CircleImageBase;
          },
          /* 74 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Label = __webpack_require__(117)["default"];
            var ComponentUtil = __webpack_require__(48)["default"];
            var CubicBezierEdge = __webpack_require__(215)["default"];
            var BezierEdgeDynamic = __webpack_require__(217)["default"];
            var BezierEdgeStatic = __webpack_require__(218)["default"];
            var StraightEdge = __webpack_require__(219)["default"];
            var Edge = function() {
              function Edge2(options, body, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Edge2);
                if (body === void 0) {
                  throw new Error("No body provided");
                }
                this.options = util.bridgeObject(globalOptions);
                this.globalOptions = globalOptions;
                this.defaultOptions = defaultOptions;
                this.body = body;
                this.id = void 0;
                this.fromId = void 0;
                this.toId = void 0;
                this.selected = false;
                this.hover = false;
                this.labelDirty = true;
                this.baseWidth = this.options.width;
                this.baseFontSize = this.options.font.size;
                this.from = void 0;
                this.to = void 0;
                this.edgeType = void 0;
                this.connected = false;
                this.labelModule = new Label(
                  this.body,
                  this.options,
                  true
                  /* It's an edge label */
                );
                this.setOptions(options);
              }
              (0, _createClass3["default"])(Edge2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (!options) {
                    return;
                  }
                  Edge2.parseOptions(this.options, options, true, this.globalOptions);
                  if (options.id !== void 0) {
                    this.id = options.id;
                  }
                  if (options.from !== void 0) {
                    this.fromId = options.from;
                  }
                  if (options.to !== void 0) {
                    this.toId = options.to;
                  }
                  if (options.title !== void 0) {
                    this.title = options.title;
                  }
                  if (options.value !== void 0) {
                    options.value = parseFloat(options.value);
                  }
                  var pile = [options, this.options, this.defaultOptions];
                  this.chooser = ComponentUtil.choosify("edge", pile);
                  this.updateLabelModule(options);
                  var dataChanged = this.updateEdgeType();
                  this._setInteractionWidths();
                  this.connect();
                  if (options.hidden !== void 0 || options.physics !== void 0) {
                    dataChanged = true;
                  }
                  return dataChanged;
                }
                /**
                 *
                 * @param {Object} parentOptions
                 * @param {Object} newOptions
                 * @param {boolean} [allowDeletion=false]
                 * @param {Object} [globalOptions={}]
                 * @param {boolean} [copyFromGlobals=false]
                 */
              }, {
                key: "getFormattingValues",
                /**
                 *
                 * @returns {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}}
                 */
                value: function getFormattingValues() {
                  var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;
                  var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;
                  var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;
                  var inheritsColor = this.options.color.inherit;
                  var values = {
                    toArrow,
                    toArrowScale: this.options.arrows.to.scaleFactor,
                    toArrowType: this.options.arrows.to.type,
                    middleArrow,
                    middleArrowScale: this.options.arrows.middle.scaleFactor,
                    middleArrowType: this.options.arrows.middle.type,
                    fromArrow,
                    fromArrowScale: this.options.arrows.from.scaleFactor,
                    fromArrowType: this.options.arrows.from.type,
                    arrowStrikethrough: this.options.arrowStrikethrough,
                    color: inheritsColor ? void 0 : this.options.color.color,
                    inheritsColor,
                    opacity: this.options.color.opacity,
                    hidden: this.options.hidden,
                    length: this.options.length,
                    shadow: this.options.shadow.enabled,
                    shadowColor: this.options.shadow.color,
                    shadowSize: this.options.shadow.size,
                    shadowX: this.options.shadow.x,
                    shadowY: this.options.shadow.y,
                    dashes: this.options.dashes,
                    width: this.options.width
                  };
                  if (this.selected || this.hover) {
                    if (this.chooser === true) {
                      if (this.selected) {
                        var selectedWidth = this.options.selectionWidth;
                        if (typeof selectedWidth === "function") {
                          values.width = selectedWidth(values.width);
                        } else if (typeof selectedWidth === "number") {
                          values.width += selectedWidth;
                        }
                        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                        values.color = this.options.color.highlight;
                        values.shadow = this.options.shadow.enabled;
                      } else if (this.hover) {
                        var hoverWidth = this.options.hoverWidth;
                        if (typeof hoverWidth === "function") {
                          values.width = hoverWidth(values.width);
                        } else if (typeof hoverWidth === "number") {
                          values.width += hoverWidth;
                        }
                        values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                        values.color = this.options.color.hover;
                        values.shadow = this.options.shadow.enabled;
                      }
                    } else if (typeof this.chooser === "function") {
                      this.chooser(values, this.options.id, this.selected, this.hover);
                      if (values.color !== void 0) {
                        values.inheritsColor = false;
                      }
                      if (values.shadow === false) {
                        if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {
                          values.shadow = true;
                        }
                      }
                    }
                  } else {
                    values.shadow = this.options.shadow.enabled;
                    values.width = Math.max(values.width, 0.3 / this.body.view.scale);
                  }
                  return values;
                }
                /**
                 * update the options in the label module
                 *
                 * @param {Object} options
                 */
              }, {
                key: "updateLabelModule",
                value: function updateLabelModule(options) {
                  var pile = [
                    options,
                    this.options,
                    this.globalOptions,
                    // Currently set global edge options
                    this.defaultOptions
                  ];
                  this.labelModule.update(this.options, pile);
                  if (this.labelModule.baseSize !== void 0) {
                    this.baseFontSize = this.labelModule.baseSize;
                  }
                }
                /**
                 * update the edge type, set the options
                 * @returns {boolean}
                 */
              }, {
                key: "updateEdgeType",
                value: function updateEdgeType() {
                  var smooth = this.options.smooth;
                  var dataChanged = false;
                  var changeInType = true;
                  if (this.edgeType !== void 0) {
                    if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === "dynamic" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === "cubicBezier" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== "dynamic" && smooth.type !== "cubicBezier" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {
                      changeInType = false;
                    }
                    if (changeInType === true) {
                      dataChanged = this.cleanup();
                    }
                  }
                  if (changeInType === true) {
                    if (smooth.enabled === true) {
                      if (smooth.type === "dynamic") {
                        dataChanged = true;
                        this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);
                      } else if (smooth.type === "cubicBezier") {
                        this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);
                      } else {
                        this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);
                      }
                    } else {
                      this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);
                    }
                  } else {
                    this.edgeType.setOptions(this.options);
                  }
                  return dataChanged;
                }
                /**
                 * Connect an edge to its nodes
                 */
              }, {
                key: "connect",
                value: function connect() {
                  this.disconnect();
                  this.from = this.body.nodes[this.fromId] || void 0;
                  this.to = this.body.nodes[this.toId] || void 0;
                  this.connected = this.from !== void 0 && this.to !== void 0;
                  if (this.connected === true) {
                    this.from.attachEdge(this);
                    this.to.attachEdge(this);
                  } else {
                    if (this.from) {
                      this.from.detachEdge(this);
                    }
                    if (this.to) {
                      this.to.detachEdge(this);
                    }
                  }
                  this.edgeType.connect();
                }
                /**
                 * Disconnect an edge from its nodes
                 */
              }, {
                key: "disconnect",
                value: function disconnect() {
                  if (this.from) {
                    this.from.detachEdge(this);
                    this.from = void 0;
                  }
                  if (this.to) {
                    this.to.detachEdge(this);
                    this.to = void 0;
                  }
                  this.connected = false;
                }
                /**
                 * get the title of this edge.
                 * @return {string} title    The title of the edge, or undefined when no title
                 *                           has been set.
                 */
              }, {
                key: "getTitle",
                value: function getTitle() {
                  return this.title;
                }
                /**
                 * check if this node is selecte
                 * @return {boolean} selected   True if node is selected, else false
                 */
              }, {
                key: "isSelected",
                value: function isSelected() {
                  return this.selected;
                }
                /**
                 * Retrieve the value of the edge. Can be undefined
                 * @return {number} value
                 */
              }, {
                key: "getValue",
                value: function getValue() {
                  return this.options.value;
                }
                /**
                 * Adjust the value range of the edge. The edge will adjust it's width
                 * based on its value.
                 * @param {number} min
                 * @param {number} max
                 * @param {number} total
                 */
              }, {
                key: "setValueRange",
                value: function setValueRange(min, max, total) {
                  if (this.options.value !== void 0) {
                    var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);
                    var widthDiff = this.options.scaling.max - this.options.scaling.min;
                    if (this.options.scaling.label.enabled === true) {
                      var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;
                      this.options.font.size = this.options.scaling.label.min + scale * fontDiff;
                    }
                    this.options.width = this.options.scaling.min + scale * widthDiff;
                  } else {
                    this.options.width = this.baseWidth;
                    this.options.font.size = this.baseFontSize;
                  }
                  this._setInteractionWidths();
                  this.updateLabelModule();
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_setInteractionWidths",
                value: function _setInteractionWidths() {
                  if (typeof this.options.hoverWidth === "function") {
                    this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);
                  } else {
                    this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;
                  }
                  if (typeof this.options.selectionWidth === "function") {
                    this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);
                  } else {
                    this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;
                  }
                }
                /**
                 * Redraw a edge
                 * Draw this edge in the given canvas
                 * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
                 * @param {CanvasRenderingContext2D}   ctx
                 */
              }, {
                key: "draw",
                value: function draw(ctx) {
                  var values = this.getFormattingValues();
                  if (values.hidden) {
                    return;
                  }
                  var viaNode = this.edgeType.getViaNode();
                  var arrowData = {};
                  this.edgeType.fromPoint = this.edgeType.from;
                  this.edgeType.toPoint = this.edgeType.to;
                  if (values.fromArrow) {
                    arrowData.from = this.edgeType.getArrowData(ctx, "from", viaNode, this.selected, this.hover, values);
                    if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;
                  }
                  if (values.toArrow) {
                    arrowData.to = this.edgeType.getArrowData(ctx, "to", viaNode, this.selected, this.hover, values);
                    if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;
                  }
                  if (values.middleArrow) {
                    arrowData.middle = this.edgeType.getArrowData(ctx, "middle", viaNode, this.selected, this.hover, values);
                  }
                  this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);
                  this.drawArrows(ctx, arrowData, values);
                  this.drawLabel(ctx, viaNode);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Object} arrowData
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "drawArrows",
                value: function drawArrows(ctx, arrowData, values) {
                  if (values.fromArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);
                  }
                  if (values.middleArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);
                  }
                  if (values.toArrow) {
                    this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Node} viaNode
                 */
              }, {
                key: "drawLabel",
                value: function drawLabel(ctx, viaNode) {
                  if (this.options.label !== void 0) {
                    var node1 = this.from;
                    var node2 = this.to;
                    if (this.labelModule.differentState(this.selected, this.hover)) {
                      this.labelModule.getTextSize(ctx, this.selected, this.hover);
                    }
                    if (node1.id != node2.id) {
                      this.labelModule.pointToSelf = false;
                      var point = this.edgeType.getPoint(0.5, viaNode);
                      ctx.save();
                      var rotationPoint = this._getRotation(ctx);
                      if (rotationPoint.angle != 0) {
                        ctx.translate(rotationPoint.x, rotationPoint.y);
                        ctx.rotate(rotationPoint.angle);
                      }
                      this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
                      ctx.restore();
                    } else {
                      this.labelModule.pointToSelf = true;
                      var x, y;
                      var radius = this.options.selfReferenceSize;
                      if (node1.shape.width > node1.shape.height) {
                        x = node1.x + node1.shape.width * 0.5;
                        y = node1.y - radius;
                      } else {
                        x = node1.x + radius;
                        y = node1.y - node1.shape.height * 0.5;
                      }
                      point = this._pointOnCircle(x, y, radius, 0.125);
                      this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);
                    }
                  }
                }
                /**
                 * Determine all visual elements of this edge instance, in which the given
                 * point falls within the bounding shape.
                 *
                 * @param {point} point
                 * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
                 */
              }, {
                key: "getItemsOnPoint",
                value: function getItemsOnPoint(point) {
                  var ret = [];
                  if (this.labelModule.visible()) {
                    var rotationPoint = this._getRotation();
                    if (ComponentUtil.pointInRect(this.labelModule.getSize(), point, rotationPoint)) {
                      ret.push({ edgeId: this.id, labelId: 0 });
                    }
                  }
                  var obj = {
                    left: point.x,
                    top: point.y
                  };
                  if (this.isOverlappingWith(obj)) {
                    ret.push({ edgeId: this.id });
                  }
                  return ret;
                }
                /**
                 * Check if this object is overlapping with the provided object
                 * @param {Object} obj   an object with parameters left, top
                 * @return {boolean}     True if location is located on the edge
                 */
              }, {
                key: "isOverlappingWith",
                value: function isOverlappingWith(obj) {
                  if (this.connected) {
                    var distMax = 10;
                    var xFrom = this.from.x;
                    var yFrom = this.from.y;
                    var xTo = this.to.x;
                    var yTo = this.to.y;
                    var xObj = obj.left;
                    var yObj = obj.top;
                    var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);
                    return dist < distMax;
                  } else {
                    return false;
                  }
                }
                /** 
                 * Determine the rotation point, if any.
                 *
                 * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
                 * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
                 * @private
                 */
              }, {
                key: "_getRotation",
                value: function _getRotation(ctx) {
                  var viaNode = this.edgeType.getViaNode();
                  var point = this.edgeType.getPoint(0.5, viaNode);
                  if (ctx !== void 0) {
                    this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);
                  }
                  var ret = {
                    x: point.x,
                    y: this.labelModule.size.yLine,
                    angle: 0
                  };
                  if (!this.labelModule.visible()) {
                    return ret;
                  }
                  if (this.options.font.align === "horizontal") {
                    return ret;
                  }
                  var dy = this.from.y - this.to.y;
                  var dx = this.from.x - this.to.x;
                  var angle = Math.atan2(dy, dx);
                  if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {
                    angle += Math.PI;
                  }
                  ret.angle = angle;
                  return ret;
                }
                /**
                 * Get a point on a circle
                 * @param {number} x
                 * @param {number} y
                 * @param {number} radius
                 * @param {number} percentage Value between 0 (line start) and 1 (line end)
                 * @return {Object} point
                 * @private
                 */
              }, {
                key: "_pointOnCircle",
                value: function _pointOnCircle(x, y, radius, percentage) {
                  var angle = percentage * 2 * Math.PI;
                  return {
                    x: x + radius * Math.cos(angle),
                    y: y - radius * Math.sin(angle)
                  };
                }
                /**
                 * Sets selected state to true
                 */
              }, {
                key: "select",
                value: function select() {
                  this.selected = true;
                }
                /**
                 * Sets selected state to false
                 */
              }, {
                key: "unselect",
                value: function unselect() {
                  this.selected = false;
                }
                /**
                 * cleans all required things on delete
                 * @returns {*}
                 */
              }, {
                key: "cleanup",
                value: function cleanup() {
                  return this.edgeType.cleanup();
                }
                /**
                 * Remove edge from the list and perform necessary cleanup.
                 */
              }, {
                key: "remove",
                value: function remove() {
                  this.cleanup();
                  this.disconnect();
                  delete this.body.edges[this.id];
                }
                /**
                 * Check if both connecting nodes exist
                 * @returns {boolean}
                 */
              }, {
                key: "endPointsValid",
                value: function endPointsValid() {
                  return this.body.nodes[this.fromId] !== void 0 && this.body.nodes[this.toId] !== void 0;
                }
              }], [{
                key: "parseOptions",
                value: function parseOptions(parentOptions, newOptions) {
                  var allowDeletion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var globalOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  var copyFromGlobals = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  var fields = ["arrowStrikethrough", "id", "from", "hidden", "hoverWidth", "labelHighlightBold", "length", "line", "opacity", "physics", "scaling", "selectionWidth", "selfReferenceSize", "to", "title", "value", "width", "font", "chosen", "widthConstraint"];
                  util.selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);
                  if (ComponentUtil.isValidLabel(newOptions.label)) {
                    parentOptions.label = newOptions.label;
                  } else {
                    parentOptions.label = void 0;
                  }
                  util.mergeOptions(parentOptions, newOptions, "smooth", globalOptions);
                  util.mergeOptions(parentOptions, newOptions, "shadow", globalOptions);
                  if (newOptions.dashes !== void 0 && newOptions.dashes !== null) {
                    parentOptions.dashes = newOptions.dashes;
                  } else if (allowDeletion === true && newOptions.dashes === null) {
                    parentOptions.dashes = (0, _create2["default"])(globalOptions.dashes);
                  }
                  if (newOptions.scaling !== void 0 && newOptions.scaling !== null) {
                    if (newOptions.scaling.min !== void 0) {
                      parentOptions.scaling.min = newOptions.scaling.min;
                    }
                    if (newOptions.scaling.max !== void 0) {
                      parentOptions.scaling.max = newOptions.scaling.max;
                    }
                    util.mergeOptions(parentOptions.scaling, newOptions.scaling, "label", globalOptions.scaling);
                  } else if (allowDeletion === true && newOptions.scaling === null) {
                    parentOptions.scaling = (0, _create2["default"])(globalOptions.scaling);
                  }
                  if (newOptions.arrows !== void 0 && newOptions.arrows !== null) {
                    if (typeof newOptions.arrows === "string") {
                      var arrows = newOptions.arrows.toLowerCase();
                      parentOptions.arrows.to.enabled = arrows.indexOf("to") != -1;
                      parentOptions.arrows.middle.enabled = arrows.indexOf("middle") != -1;
                      parentOptions.arrows.from.enabled = arrows.indexOf("from") != -1;
                    } else if ((0, _typeof3["default"])(newOptions.arrows) === "object") {
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "to", globalOptions.arrows);
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "middle", globalOptions.arrows);
                      util.mergeOptions(parentOptions.arrows, newOptions.arrows, "from", globalOptions.arrows);
                    } else {
                      throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:" + (0, _stringify2["default"])(newOptions.arrows));
                    }
                  } else if (allowDeletion === true && newOptions.arrows === null) {
                    parentOptions.arrows = (0, _create2["default"])(globalOptions.arrows);
                  }
                  if (newOptions.color !== void 0 && newOptions.color !== null) {
                    var fromColor = newOptions.color;
                    var toColor = parentOptions.color;
                    if (copyFromGlobals) {
                      util.deepExtend(toColor, globalOptions.color, false, allowDeletion);
                    } else {
                      for (var i in toColor) {
                        if (toColor.hasOwnProperty(i)) {
                          delete toColor[i];
                        }
                      }
                    }
                    if (util.isString(toColor)) {
                      toColor.color = toColor;
                      toColor.highlight = toColor;
                      toColor.hover = toColor;
                      toColor.inherit = false;
                      if (fromColor.opacity === void 0) {
                        toColor.opacity = 1;
                      }
                    } else {
                      var colorsDefined = false;
                      if (fromColor.color !== void 0) {
                        toColor.color = fromColor.color;
                        colorsDefined = true;
                      }
                      if (fromColor.highlight !== void 0) {
                        toColor.highlight = fromColor.highlight;
                        colorsDefined = true;
                      }
                      if (fromColor.hover !== void 0) {
                        toColor.hover = fromColor.hover;
                        colorsDefined = true;
                      }
                      if (fromColor.inherit !== void 0) {
                        toColor.inherit = fromColor.inherit;
                      }
                      if (fromColor.opacity !== void 0) {
                        toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));
                      }
                      if (colorsDefined === true) {
                        toColor.inherit = false;
                      } else {
                        if (toColor.inherit === void 0) {
                          toColor.inherit = "from";
                        }
                      }
                    }
                  } else if (allowDeletion === true && newOptions.color === null) {
                    parentOptions.color = util.bridgeObject(globalOptions.color);
                  }
                  if (allowDeletion === true && newOptions.font === null) {
                    parentOptions.font = util.bridgeObject(globalOptions.font);
                  }
                }
              }]);
              return Edge2;
            }();
            exports2["default"] = Edge;
          },
          /* 75 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _EdgeBase2 = __webpack_require__(118);
            var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeBase = function(_EdgeBase) {
              (0, _inherits3["default"])(BezierEdgeBase2, _EdgeBase);
              function BezierEdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeBase2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(BezierEdgeBase2, [{
                key: "_findBorderPositionBezier",
                value: function _findBorderPositionBezier(nearNode, ctx) {
                  var viaNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._getViaCoordinates();
                  var maxIterations = 10;
                  var iteration = 0;
                  var low = 0;
                  var high = 1;
                  var pos, angle, distanceToBorder, distanceToPoint, difference;
                  var threshold = 0.2;
                  var node = this.to;
                  var from = false;
                  if (nearNode.id === this.from.id) {
                    node = this.from;
                    from = true;
                  }
                  while (low <= high && iteration < maxIterations) {
                    var middle = (low + high) * 0.5;
                    pos = this.getPoint(middle, viaNode);
                    angle = Math.atan2(node.y - pos.y, node.x - pos.x);
                    distanceToBorder = node.distanceToBorder(ctx, angle);
                    distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
                    difference = distanceToBorder - distanceToPoint;
                    if (Math.abs(difference) < threshold) {
                      break;
                    } else if (difference < 0) {
                      if (from === false) {
                        low = middle;
                      } else {
                        high = middle;
                      }
                    } else {
                      if (from === false) {
                        high = middle;
                      } else {
                        low = middle;
                      }
                    }
                    iteration++;
                  }
                  pos.t = middle;
                  return pos;
                }
                /**
                 * Calculate the distance between a point (x3,y3) and a line segment from
                 * (x1,y1) to (x2,y2).
                 * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
                 * @param {number} x1 from x
                 * @param {number} y1 from y
                 * @param {number} x2 to x
                 * @param {number} y2 to y
                 * @param {number} x3 point to check x
                 * @param {number} y3 point to check y
                 * @param {Node} via
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToBezierEdge",
                value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {
                  var minDistance = 1e9;
                  var distance = void 0;
                  var i = void 0, t = void 0, x = void 0, y = void 0;
                  var lastX = x1;
                  var lastY = y1;
                  for (i = 1; i < 10; i++) {
                    t = 0.1 * i;
                    x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;
                    y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;
                    if (i > 0) {
                      distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
                      minDistance = distance < minDistance ? distance : minDistance;
                    }
                    lastX = x;
                    lastY = y;
                  }
                  return minDistance;
                }
                /**
                 * Draw a bezier curve between two nodes
                 *
                 * The method accepts zero, one or two control points.
                 * Passing zero control points just draws a straight line
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Object}           values   | options for shadow drawing
                 * @param {Object|undefined} viaNode1 | first control point for curve drawing
                 * @param {Object|undefined} viaNode2 | second control point for curve drawing
                 *
                 * @protected
                 */
              }, {
                key: "_bezierCurve",
                value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {
                  var hasNode1 = viaNode1 !== void 0 && viaNode1.x !== void 0;
                  var hasNode2 = viaNode2 !== void 0 && viaNode2.x !== void 0;
                  ctx.beginPath();
                  ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
                  if (hasNode1 && hasNode2) {
                    ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);
                  } else if (hasNode1) {
                    ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);
                  } else {
                    ctx.lineTo(this.toPoint.x, this.toPoint.y);
                  }
                  this.enableShadow(ctx, values);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
                /**
                 *
                 * @returns {*|{x, y}|{x: undefined, y: undefined}}
                 */
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
              }]);
              return BezierEdgeBase2;
            }(_EdgeBase3["default"]);
            exports2["default"] = BezierEdgeBase;
          },
          /* 76 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = function() {
              function NetworkUtil2() {
                (0, _classCallCheck3["default"])(this, NetworkUtil2);
              }
              (0, _createClass3["default"])(NetworkUtil2, null, [{
                key: "getRange",
                value: function getRange(allNodes) {
                  var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
                  if (specificNodes.length > 0) {
                    for (var i = 0; i < specificNodes.length; i++) {
                      node = allNodes[specificNodes[i]];
                      if (minX > node.shape.boundingBox.left) {
                        minX = node.shape.boundingBox.left;
                      }
                      if (maxX < node.shape.boundingBox.right) {
                        maxX = node.shape.boundingBox.right;
                      }
                      if (minY > node.shape.boundingBox.top) {
                        minY = node.shape.boundingBox.top;
                      }
                      if (maxY < node.shape.boundingBox.bottom) {
                        maxY = node.shape.boundingBox.bottom;
                      }
                    }
                  }
                  if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
                    minY = 0, maxY = 0, minX = 0, maxX = 0;
                  }
                  return { minX, maxX, minY, maxY };
                }
                /**
                 * Find the center position of the network
                 *
                 * @param {Array.<Node>} allNodes
                 * @param {Array.<Node>} [specificNodes=[]]
                 * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
                 * @static
                 */
              }, {
                key: "getRangeCore",
                value: function getRangeCore(allNodes) {
                  var specificNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                  var minY = 1e9, maxY = -1e9, minX = 1e9, maxX = -1e9, node;
                  if (specificNodes.length > 0) {
                    for (var i = 0; i < specificNodes.length; i++) {
                      node = allNodes[specificNodes[i]];
                      if (minX > node.x) {
                        minX = node.x;
                      }
                      if (maxX < node.x) {
                        maxX = node.x;
                      }
                      if (minY > node.y) {
                        minY = node.y;
                      }
                      if (maxY < node.y) {
                        maxY = node.y;
                      }
                    }
                  }
                  if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {
                    minY = 0, maxY = 0, minX = 0, maxX = 0;
                  }
                  return { minX, maxX, minY, maxY };
                }
                /**
                 * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
                 * @returns {{x: number, y: number}}
                 * @static
                 */
              }, {
                key: "findCenter",
                value: function findCenter(range) {
                  return {
                    x: 0.5 * (range.maxX + range.minX),
                    y: 0.5 * (range.maxY + range.minY)
                  };
                }
                /**
                 * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
                 * @param {vis.Item} item
                 * @param {'node'|undefined} type
                 * @returns {{}}
                 * @static
                 */
              }, {
                key: "cloneOptions",
                value: function cloneOptions(item, type) {
                  var clonedOptions = {};
                  if (type === void 0 || type === "node") {
                    util.deepExtend(clonedOptions, item.options, true);
                    clonedOptions.x = item.x;
                    clonedOptions.y = item.y;
                    clonedOptions.amountOfConnections = item.edges.length;
                  } else {
                    util.deepExtend(clonedOptions, item.options, true);
                  }
                  return clonedOptions;
                }
              }]);
              return NetworkUtil2;
            }();
            exports2["default"] = NetworkUtil;
          },
          /* 77 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(124), __esModule: true };
          },
          /* 78 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(50);
            module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          /* 79 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var LIBRARY = __webpack_require__(52);
            var $export = __webpack_require__(17);
            var redefine = __webpack_require__(83);
            var hide = __webpack_require__(26);
            var has = __webpack_require__(22);
            var Iterators = __webpack_require__(31);
            var $iterCreate = __webpack_require__(129);
            var setToStringTag = __webpack_require__(59);
            var getPrototypeOf = __webpack_require__(85);
            var ITERATOR = __webpack_require__(13)("iterator");
            var BUGGY = !([].keys && "next" in [].keys());
            var FF_ITERATOR = "@@iterator";
            var KEYS = "keys";
            var VALUES = "values";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator";
              var DEF_VALUES = DEFAULT == VALUES;
              var VALUES_BUG = false;
              var proto = Base.prototype;
              var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
              var $default = $native || getMethod(DEFAULT);
              var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
              var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
              var methods, key, IteratorPrototype;
              if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                  setToStringTag(IteratorPrototype, TAG, true);
                  if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
                }
              }
              if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                  return $native.call(this);
                };
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: $entries
                };
                if (FORCED) for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key]);
                }
                else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          },
          /* 80 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var aFunction = __webpack_require__(128);
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          /* 81 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = !__webpack_require__(21) && !__webpack_require__(28)(function() {
              return Object.defineProperty(__webpack_require__(82)("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          },
          /* 82 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject = __webpack_require__(32);
            var document2 = __webpack_require__(18).document;
            var is = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          /* 83 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(26);
          },
          /* 84 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(22);
            var toIObject = __webpack_require__(25);
            var arrayIndexOf = __webpack_require__(131)(false);
            var IE_PROTO = __webpack_require__(56)("IE_PROTO");
            module2.exports = function(object, names) {
              var O = toIObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
              while (names.length > i) if (has(O, key = names[i++])) {
                ~arrayIndexOf(result, key) || result.push(key);
              }
              return result;
            };
          },
          /* 85 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(22);
            var toObject = __webpack_require__(41);
            var IE_PROTO = __webpack_require__(56)("IE_PROTO");
            var ObjectProto = Object.prototype;
            module2.exports = Object.getPrototypeOf || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO)) return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            };
          },
          /* 86 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(50);
            var TAG = __webpack_require__(13)("toStringTag");
            var ARG = cof(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module2.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          /* 87 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            var core = __webpack_require__(7);
            var fails = __webpack_require__(28);
            module2.exports = function(KEY, exec) {
              var fn = (core.Object || {})[KEY] || Object[KEY];
              var exp = {};
              exp[KEY] = exec(fn);
              $export($export.S + $export.F * fails(function() {
                fn(1);
              }), "Object", exp);
            };
          },
          /* 88 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $keys = __webpack_require__(84);
            var hiddenKeys = __webpack_require__(58).concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return $keys(O, hiddenKeys);
            };
          },
          /* 89 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var pIE = __webpack_require__(42);
            var createDesc = __webpack_require__(39);
            var toIObject = __webpack_require__(25);
            var toPrimitive = __webpack_require__(53);
            var has = __webpack_require__(22);
            var IE8_DOM_DEFINE = __webpack_require__(81);
            var gOPD = Object.getOwnPropertyDescriptor;
            exports2.f = __webpack_require__(21) ? gOPD : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE) try {
                return gOPD(O, P);
              } catch (e) {
              }
              if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
            };
          },
          /* 90 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(162), __esModule: true };
          },
          /* 91 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function Point2d(x, y) {
              this.x = x !== void 0 ? x : 0;
              this.y = y !== void 0 ? y : 0;
            }
            module2.exports = Point2d;
          },
          /* 92 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(2);
            function Slider(container, options) {
              if (container === void 0) {
                throw new Error("No container element defined");
              }
              this.container = container;
              this.visible = options && options.visible != void 0 ? options.visible : true;
              if (this.visible) {
                this.frame = document.createElement("DIV");
                this.frame.style.width = "100%";
                this.frame.style.position = "relative";
                this.container.appendChild(this.frame);
                this.frame.prev = document.createElement("INPUT");
                this.frame.prev.type = "BUTTON";
                this.frame.prev.value = "Prev";
                this.frame.appendChild(this.frame.prev);
                this.frame.play = document.createElement("INPUT");
                this.frame.play.type = "BUTTON";
                this.frame.play.value = "Play";
                this.frame.appendChild(this.frame.play);
                this.frame.next = document.createElement("INPUT");
                this.frame.next.type = "BUTTON";
                this.frame.next.value = "Next";
                this.frame.appendChild(this.frame.next);
                this.frame.bar = document.createElement("INPUT");
                this.frame.bar.type = "BUTTON";
                this.frame.bar.style.position = "absolute";
                this.frame.bar.style.border = "1px solid red";
                this.frame.bar.style.width = "100px";
                this.frame.bar.style.height = "6px";
                this.frame.bar.style.borderRadius = "2px";
                this.frame.bar.style.MozBorderRadius = "2px";
                this.frame.bar.style.border = "1px solid #7F7F7F";
                this.frame.bar.style.backgroundColor = "#E5E5E5";
                this.frame.appendChild(this.frame.bar);
                this.frame.slide = document.createElement("INPUT");
                this.frame.slide.type = "BUTTON";
                this.frame.slide.style.margin = "0px";
                this.frame.slide.value = " ";
                this.frame.slide.style.position = "relative";
                this.frame.slide.style.left = "-100px";
                this.frame.appendChild(this.frame.slide);
                var me = this;
                this.frame.slide.onmousedown = function(event) {
                  me._onMouseDown(event);
                };
                this.frame.prev.onclick = function(event) {
                  me.prev(event);
                };
                this.frame.play.onclick = function(event) {
                  me.togglePlay(event);
                };
                this.frame.next.onclick = function(event) {
                  me.next(event);
                };
              }
              this.onChangeCallback = void 0;
              this.values = [];
              this.index = void 0;
              this.playTimeout = void 0;
              this.playInterval = 1e3;
              this.playLoop = true;
            }
            Slider.prototype.prev = function() {
              var index = this.getIndex();
              if (index > 0) {
                index--;
                this.setIndex(index);
              }
            };
            Slider.prototype.next = function() {
              var index = this.getIndex();
              if (index < this.values.length - 1) {
                index++;
                this.setIndex(index);
              }
            };
            Slider.prototype.playNext = function() {
              var start = /* @__PURE__ */ new Date();
              var index = this.getIndex();
              if (index < this.values.length - 1) {
                index++;
                this.setIndex(index);
              } else if (this.playLoop) {
                index = 0;
                this.setIndex(index);
              }
              var end = /* @__PURE__ */ new Date();
              var diff = end - start;
              var interval = Math.max(this.playInterval - diff, 0);
              var me = this;
              this.playTimeout = setTimeout(function() {
                me.playNext();
              }, interval);
            };
            Slider.prototype.togglePlay = function() {
              if (this.playTimeout === void 0) {
                this.play();
              } else {
                this.stop();
              }
            };
            Slider.prototype.play = function() {
              if (this.playTimeout) return;
              this.playNext();
              if (this.frame) {
                this.frame.play.value = "Stop";
              }
            };
            Slider.prototype.stop = function() {
              clearInterval(this.playTimeout);
              this.playTimeout = void 0;
              if (this.frame) {
                this.frame.play.value = "Play";
              }
            };
            Slider.prototype.setOnChangeCallback = function(callback) {
              this.onChangeCallback = callback;
            };
            Slider.prototype.setPlayInterval = function(interval) {
              this.playInterval = interval;
            };
            Slider.prototype.getPlayInterval = function() {
              return this.playInterval;
            };
            Slider.prototype.setPlayLoop = function(doLoop) {
              this.playLoop = doLoop;
            };
            Slider.prototype.onChange = function() {
              if (this.onChangeCallback !== void 0) {
                this.onChangeCallback();
              }
            };
            Slider.prototype.redraw = function() {
              if (this.frame) {
                this.frame.bar.style.top = this.frame.clientHeight / 2 - this.frame.bar.offsetHeight / 2 + "px";
                this.frame.bar.style.width = this.frame.clientWidth - this.frame.prev.clientWidth - this.frame.play.clientWidth - this.frame.next.clientWidth - 30 + "px";
                var left = this.indexToLeft(this.index);
                this.frame.slide.style.left = left + "px";
              }
            };
            Slider.prototype.setValues = function(values) {
              this.values = values;
              if (this.values.length > 0) this.setIndex(0);
              else this.index = void 0;
            };
            Slider.prototype.setIndex = function(index) {
              if (index < this.values.length) {
                this.index = index;
                this.redraw();
                this.onChange();
              } else {
                throw new Error("Index out of range");
              }
            };
            Slider.prototype.getIndex = function() {
              return this.index;
            };
            Slider.prototype.get = function() {
              return this.values[this.index];
            };
            Slider.prototype._onMouseDown = function(event) {
              var leftButtonDown = event.which ? event.which === 1 : event.button === 1;
              if (!leftButtonDown) return;
              this.startClientX = event.clientX;
              this.startSlideX = parseFloat(this.frame.slide.style.left);
              this.frame.style.cursor = "move";
              var me = this;
              this.onmousemove = function(event2) {
                me._onMouseMove(event2);
              };
              this.onmouseup = function(event2) {
                me._onMouseUp(event2);
              };
              util.addEventListener(document, "mousemove", this.onmousemove);
              util.addEventListener(document, "mouseup", this.onmouseup);
              util.preventDefault(event);
            };
            Slider.prototype.leftToIndex = function(left) {
              var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;
              var x = left - 3;
              var index = Math.round(x / width * (this.values.length - 1));
              if (index < 0) index = 0;
              if (index > this.values.length - 1) index = this.values.length - 1;
              return index;
            };
            Slider.prototype.indexToLeft = function(index) {
              var width = parseFloat(this.frame.bar.style.width) - this.frame.slide.clientWidth - 10;
              var x = index / (this.values.length - 1) * width;
              var left = x + 3;
              return left;
            };
            Slider.prototype._onMouseMove = function(event) {
              var diff = event.clientX - this.startClientX;
              var x = this.startSlideX + diff;
              var index = this.leftToIndex(x);
              this.setIndex(index);
              util.preventDefault();
            };
            Slider.prototype._onMouseUp = function(event) {
              this.frame.style.cursor = "auto";
              util.removeEventListener(document, "mousemove", this.onmousemove);
              util.removeEventListener(document, "mouseup", this.onmouseup);
              util.preventDefault();
            };
            module2.exports = Slider;
          },
          /* 93 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function StepNumber(start, end, step, prettyStep) {
              this._start = 0;
              this._end = 0;
              this._step = 1;
              this.prettyStep = true;
              this.precision = 5;
              this._current = 0;
              this.setRange(start, end, step, prettyStep);
            }
            StepNumber.prototype.isNumeric = function(n) {
              return !isNaN(parseFloat(n)) && isFinite(n);
            };
            StepNumber.prototype.setRange = function(start, end, step, prettyStep) {
              if (!this.isNumeric(start)) {
                throw new Error("Parameter 'start' is not numeric; value: " + start);
              }
              if (!this.isNumeric(end)) {
                throw new Error("Parameter 'end' is not numeric; value: " + start);
              }
              if (!this.isNumeric(step)) {
                throw new Error("Parameter 'step' is not numeric; value: " + start);
              }
              this._start = start ? start : 0;
              this._end = end ? end : 0;
              this.setStep(step, prettyStep);
            };
            StepNumber.prototype.setStep = function(step, prettyStep) {
              if (step === void 0 || step <= 0) return;
              if (prettyStep !== void 0) this.prettyStep = prettyStep;
              if (this.prettyStep === true) this._step = StepNumber.calculatePrettyStep(step);
              else this._step = step;
            };
            StepNumber.calculatePrettyStep = function(step) {
              var log10 = function log102(x) {
                return Math.log(x) / Math.LN10;
              };
              var step1 = Math.pow(10, Math.round(log10(step))), step2 = 2 * Math.pow(10, Math.round(log10(step / 2))), step5 = 5 * Math.pow(10, Math.round(log10(step / 5)));
              var prettyStep = step1;
              if (Math.abs(step2 - step) <= Math.abs(prettyStep - step)) prettyStep = step2;
              if (Math.abs(step5 - step) <= Math.abs(prettyStep - step)) prettyStep = step5;
              if (prettyStep <= 0) {
                prettyStep = 1;
              }
              return prettyStep;
            };
            StepNumber.prototype.getCurrent = function() {
              return parseFloat(this._current.toPrecision(this.precision));
            };
            StepNumber.prototype.getStep = function() {
              return this._step;
            };
            StepNumber.prototype.start = function(checkFirst) {
              if (checkFirst === void 0) {
                checkFirst = false;
              }
              this._current = this._start - this._start % this._step;
              if (checkFirst) {
                if (this.getCurrent() < this._start) {
                  this.next();
                }
              }
            };
            StepNumber.prototype.next = function() {
              this._current += this._step;
            };
            StepNumber.prototype.end = function() {
              return this._current > this._end;
            };
            module2.exports = StepNumber;
          },
          /* 94 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Camera = __webpack_require__(95);
            var Point3d = __webpack_require__(34);
            var STYLE = {
              BAR: 0,
              BARCOLOR: 1,
              BARSIZE: 2,
              DOT: 3,
              DOTLINE: 4,
              DOTCOLOR: 5,
              DOTSIZE: 6,
              GRID: 7,
              LINE: 8,
              SURFACE: 9
            };
            var STYLENAME = {
              "dot": STYLE.DOT,
              "dot-line": STYLE.DOTLINE,
              "dot-color": STYLE.DOTCOLOR,
              "dot-size": STYLE.DOTSIZE,
              "line": STYLE.LINE,
              "grid": STYLE.GRID,
              "surface": STYLE.SURFACE,
              "bar": STYLE.BAR,
              "bar-color": STYLE.BARCOLOR,
              "bar-size": STYLE.BARSIZE
            };
            var OPTIONKEYS = ["width", "height", "filterLabel", "legendLabel", "xLabel", "yLabel", "zLabel", "xValueLabel", "yValueLabel", "zValueLabel", "showXAxis", "showYAxis", "showZAxis", "showGrid", "showPerspective", "showShadow", "keepAspectRatio", "verticalRatio", "dotSizeRatio", "dotSizeMinFraction", "dotSizeMaxFraction", "showAnimationControls", "animationInterval", "animationPreload", "animationAutoStart", "axisColor", "gridColor", "xCenter", "yCenter"];
            var PREFIXEDOPTIONKEYS = ["xBarWidth", "yBarWidth", "valueMin", "valueMax", "xMin", "xMax", "xStep", "yMin", "yMax", "yStep", "zMin", "zMax", "zStep"];
            var DEFAULTS = void 0;
            function isEmpty(obj) {
              for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) return false;
              }
              return true;
            }
            function capitalize(str) {
              if (str === void 0 || str === "" || typeof str != "string") {
                return str;
              }
              return str.charAt(0).toUpperCase() + str.slice(1);
            }
            function prefixFieldName(prefix, fieldName) {
              if (prefix === void 0 || prefix === "") {
                return fieldName;
              }
              return prefix + capitalize(fieldName);
            }
            function forceCopy(src, dst, fields, prefix) {
              var srcKey;
              var dstKey;
              for (var i = 0; i < fields.length; ++i) {
                srcKey = fields[i];
                dstKey = prefixFieldName(prefix, srcKey);
                dst[dstKey] = src[srcKey];
              }
            }
            function safeCopy(src, dst, fields, prefix) {
              var srcKey;
              var dstKey;
              for (var i = 0; i < fields.length; ++i) {
                srcKey = fields[i];
                if (src[srcKey] === void 0) continue;
                dstKey = prefixFieldName(prefix, srcKey);
                dst[dstKey] = src[srcKey];
              }
            }
            function setDefaults(src, dst) {
              if (src === void 0 || isEmpty(src)) {
                throw new Error("No DEFAULTS passed");
              }
              if (dst === void 0) {
                throw new Error("No dst passed");
              }
              DEFAULTS = src;
              forceCopy(src, dst, OPTIONKEYS);
              forceCopy(src, dst, PREFIXEDOPTIONKEYS, "default");
              setSpecialSettings(src, dst);
              dst.margin = 10;
              dst.showGrayBottom = false;
              dst.showTooltip = false;
              dst.onclick_callback = null;
              dst.eye = new Point3d(0, 0, -1);
            }
            function setOptions(options, dst) {
              if (options === void 0) {
                return;
              }
              if (dst === void 0) {
                throw new Error("No dst passed");
              }
              if (DEFAULTS === void 0 || isEmpty(DEFAULTS)) {
                throw new Error("DEFAULTS not set for module Settings");
              }
              safeCopy(options, dst, OPTIONKEYS);
              safeCopy(options, dst, PREFIXEDOPTIONKEYS, "default");
              setSpecialSettings(options, dst);
            }
            function setSpecialSettings(src, dst) {
              if (src.backgroundColor !== void 0) {
                setBackgroundColor(src.backgroundColor, dst);
              }
              setDataColor(src.dataColor, dst);
              setStyle(src.style, dst);
              setShowLegend(src.showLegend, dst);
              setCameraPosition(src.cameraPosition, dst);
              if (src.tooltip !== void 0) {
                dst.showTooltip = src.tooltip;
              }
              if (src.onclick != void 0) {
                dst.onclick_callback = src.onclick;
              }
              if (src.tooltipStyle !== void 0) {
                util.selectiveDeepExtend(["tooltipStyle"], dst, src);
              }
            }
            function setShowLegend(showLegend, dst) {
              if (showLegend === void 0) {
                var isAutoByDefault = DEFAULTS.showLegend === void 0;
                if (isAutoByDefault) {
                  var isLegendGraphStyle = dst.style === STYLE.DOTCOLOR || dst.style === STYLE.DOTSIZE;
                  dst.showLegend = isLegendGraphStyle;
                } else {
                }
              } else {
                dst.showLegend = showLegend;
              }
            }
            function getStyleNumberByName(styleName) {
              var number = STYLENAME[styleName];
              if (number === void 0) {
                return -1;
              }
              return number;
            }
            function checkStyleNumber(style) {
              var valid = false;
              for (var n in STYLE) {
                if (STYLE[n] === style) {
                  valid = true;
                  break;
                }
              }
              return valid;
            }
            function setStyle(style, dst) {
              if (style === void 0) {
                return;
              }
              var styleNumber;
              if (typeof style === "string") {
                styleNumber = getStyleNumberByName(style);
                if (styleNumber === -1) {
                  throw new Error("Style '" + style + "' is invalid");
                }
              } else {
                if (!checkStyleNumber(style)) {
                  throw new Error("Style '" + style + "' is invalid");
                }
                styleNumber = style;
              }
              dst.style = styleNumber;
            }
            function setBackgroundColor(backgroundColor, dst) {
              var fill = "white";
              var stroke = "gray";
              var strokeWidth = 1;
              if (typeof backgroundColor === "string") {
                fill = backgroundColor;
                stroke = "none";
                strokeWidth = 0;
              } else if ((typeof backgroundColor === "undefined" ? "undefined" : (0, _typeof3["default"])(backgroundColor)) === "object") {
                if (backgroundColor.fill !== void 0) fill = backgroundColor.fill;
                if (backgroundColor.stroke !== void 0) stroke = backgroundColor.stroke;
                if (backgroundColor.strokeWidth !== void 0) strokeWidth = backgroundColor.strokeWidth;
              } else {
                throw new Error("Unsupported type of backgroundColor");
              }
              dst.frame.style.backgroundColor = fill;
              dst.frame.style.borderColor = stroke;
              dst.frame.style.borderWidth = strokeWidth + "px";
              dst.frame.style.borderStyle = "solid";
            }
            function setDataColor(dataColor, dst) {
              if (dataColor === void 0) {
                return;
              }
              if (dst.dataColor === void 0) {
                dst.dataColor = {};
              }
              if (typeof dataColor === "string") {
                dst.dataColor.fill = dataColor;
                dst.dataColor.stroke = dataColor;
              } else {
                if (dataColor.fill) {
                  dst.dataColor.fill = dataColor.fill;
                }
                if (dataColor.stroke) {
                  dst.dataColor.stroke = dataColor.stroke;
                }
                if (dataColor.strokeWidth !== void 0) {
                  dst.dataColor.strokeWidth = dataColor.strokeWidth;
                }
              }
            }
            function setCameraPosition(cameraPosition, dst) {
              var camPos = cameraPosition;
              if (camPos === void 0) {
                return;
              }
              if (dst.camera === void 0) {
                dst.camera = new Camera();
              }
              dst.camera.setArmRotation(camPos.horizontal, camPos.vertical);
              dst.camera.setArmLength(camPos.distance);
            }
            module2.exports.STYLE = STYLE;
            module2.exports.setDefaults = setDefaults;
            module2.exports.setOptions = setOptions;
            module2.exports.setCameraPosition = setCameraPosition;
          },
          /* 95 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _sign = __webpack_require__(165);
            var _sign2 = _interopRequireDefault(_sign);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Point3d = __webpack_require__(34);
            function Camera() {
              this.armLocation = new Point3d();
              this.armRotation = {};
              this.armRotation.horizontal = 0;
              this.armRotation.vertical = 0;
              this.armLength = 1.7;
              this.cameraOffset = new Point3d();
              this.offsetMultiplier = 0.6;
              this.cameraLocation = new Point3d();
              this.cameraRotation = new Point3d(0.5 * Math.PI, 0, 0);
              this.calculateCameraOrientation();
            }
            Camera.prototype.setOffset = function(x, y) {
              var abs = Math.abs, sign = _sign2["default"], mul = this.offsetMultiplier, border = this.armLength * mul;
              if (abs(x) > border) {
                x = sign(x) * border;
              }
              if (abs(y) > border) {
                y = sign(y) * border;
              }
              this.cameraOffset.x = x;
              this.cameraOffset.y = y;
              this.calculateCameraOrientation();
            };
            Camera.prototype.getOffset = function() {
              return this.cameraOffset;
            };
            Camera.prototype.setArmLocation = function(x, y, z) {
              this.armLocation.x = x;
              this.armLocation.y = y;
              this.armLocation.z = z;
              this.calculateCameraOrientation();
            };
            Camera.prototype.setArmRotation = function(horizontal, vertical) {
              if (horizontal !== void 0) {
                this.armRotation.horizontal = horizontal;
              }
              if (vertical !== void 0) {
                this.armRotation.vertical = vertical;
                if (this.armRotation.vertical < 0) this.armRotation.vertical = 0;
                if (this.armRotation.vertical > 0.5 * Math.PI) this.armRotation.vertical = 0.5 * Math.PI;
              }
              if (horizontal !== void 0 || vertical !== void 0) {
                this.calculateCameraOrientation();
              }
            };
            Camera.prototype.getArmRotation = function() {
              var rot = {};
              rot.horizontal = this.armRotation.horizontal;
              rot.vertical = this.armRotation.vertical;
              return rot;
            };
            Camera.prototype.setArmLength = function(length) {
              if (length === void 0) return;
              this.armLength = length;
              if (this.armLength < 0.71) this.armLength = 0.71;
              if (this.armLength > 5) this.armLength = 5;
              this.setOffset(this.cameraOffset.x, this.cameraOffset.y);
              this.calculateCameraOrientation();
            };
            Camera.prototype.getArmLength = function() {
              return this.armLength;
            };
            Camera.prototype.getCameraLocation = function() {
              return this.cameraLocation;
            };
            Camera.prototype.getCameraRotation = function() {
              return this.cameraRotation;
            };
            Camera.prototype.calculateCameraOrientation = function() {
              this.cameraLocation.x = this.armLocation.x - this.armLength * Math.sin(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
              this.cameraLocation.y = this.armLocation.y - this.armLength * Math.cos(this.armRotation.horizontal) * Math.cos(this.armRotation.vertical);
              this.cameraLocation.z = this.armLocation.z + this.armLength * Math.sin(this.armRotation.vertical);
              this.cameraRotation.x = Math.PI / 2 - this.armRotation.vertical;
              this.cameraRotation.y = 0;
              this.cameraRotation.z = -this.armRotation.horizontal;
              var xa = this.cameraRotation.x;
              var za = this.cameraRotation.z;
              var dx = this.cameraOffset.x;
              var dy = this.cameraOffset.y;
              var sin = Math.sin, cos = Math.cos;
              this.cameraLocation.x = this.cameraLocation.x + dx * cos(za) + dy * -sin(za) * cos(xa);
              this.cameraLocation.y = this.cameraLocation.y + dx * sin(za) + dy * cos(za) * cos(xa);
              this.cameraLocation.z = this.cameraLocation.z + dy * sin(xa);
            };
            module2.exports = Camera;
          },
          /* 96 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var DataView = __webpack_require__(12);
            function Filter(dataGroup, column, graph) {
              this.dataGroup = dataGroup;
              this.column = column;
              this.graph = graph;
              this.index = void 0;
              this.value = void 0;
              this.values = dataGroup.getDistinctValues(this.column);
              if (this.values.length > 0) {
                this.selectValue(0);
              }
              this.dataPoints = [];
              this.loaded = false;
              this.onLoadCallback = void 0;
              if (graph.animationPreload) {
                this.loaded = false;
                this.loadInBackground();
              } else {
                this.loaded = true;
              }
            }
            Filter.prototype.isLoaded = function() {
              return this.loaded;
            };
            Filter.prototype.getLoadedProgress = function() {
              var len = this.values.length;
              var i = 0;
              while (this.dataPoints[i]) {
                i++;
              }
              return Math.round(i / len * 100);
            };
            Filter.prototype.getLabel = function() {
              return this.graph.filterLabel;
            };
            Filter.prototype.getColumn = function() {
              return this.column;
            };
            Filter.prototype.getSelectedValue = function() {
              if (this.index === void 0) return void 0;
              return this.values[this.index];
            };
            Filter.prototype.getValues = function() {
              return this.values;
            };
            Filter.prototype.getValue = function(index) {
              if (index >= this.values.length) throw new Error("Index out of range");
              return this.values[index];
            };
            Filter.prototype._getDataPoints = function(index) {
              if (index === void 0) index = this.index;
              if (index === void 0) return [];
              var dataPoints;
              if (this.dataPoints[index]) {
                dataPoints = this.dataPoints[index];
              } else {
                var f = {};
                f.column = this.column;
                f.value = this.values[index];
                var dataView = new DataView(this.dataGroup.getDataSet(), { filter: function filter(item) {
                  return item[f.column] == f.value;
                } }).get();
                dataPoints = this.dataGroup._getDataPoints(dataView);
                this.dataPoints[index] = dataPoints;
              }
              return dataPoints;
            };
            Filter.prototype.setOnLoadCallback = function(callback) {
              this.onLoadCallback = callback;
            };
            Filter.prototype.selectValue = function(index) {
              if (index >= this.values.length) throw new Error("Index out of range");
              this.index = index;
              this.value = this.values[index];
            };
            Filter.prototype.loadInBackground = function(index) {
              if (index === void 0) index = 0;
              var frame = this.graph.frame;
              if (index < this.values.length) {
                if (frame.progress === void 0) {
                  frame.progress = document.createElement("DIV");
                  frame.progress.style.position = "absolute";
                  frame.progress.style.color = "gray";
                  frame.appendChild(frame.progress);
                }
                var progress = this.getLoadedProgress();
                frame.progress.innerHTML = "Loading animation... " + progress + "%";
                frame.progress.style.bottom = "60px";
                frame.progress.style.left = "10px";
                var me = this;
                setTimeout(function() {
                  me.loadInBackground(index + 1);
                }, 10);
                this.loaded = false;
              } else {
                this.loaded = true;
                if (frame.progress !== void 0) {
                  frame.removeChild(frame.progress);
                  frame.progress = void 0;
                }
                if (this.onLoadCallback) this.onLoadCallback();
              }
            };
            module2.exports = Filter;
          },
          /* 97 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var keycharm = __webpack_require__(35);
            var Emitter = __webpack_require__(44);
            var Hammer = __webpack_require__(10);
            var util = __webpack_require__(2);
            function Activator(container) {
              this.active = false;
              this.dom = {
                container
              };
              this.dom.overlay = document.createElement("div");
              this.dom.overlay.className = "vis-overlay";
              this.dom.container.appendChild(this.dom.overlay);
              this.hammer = Hammer(this.dom.overlay);
              this.hammer.on("tap", this._onTapOverlay.bind(this));
              var me = this;
              var events = ["tap", "doubletap", "press", "pinch", "pan", "panstart", "panmove", "panend"];
              events.forEach(function(event) {
                me.hammer.on(event, function(event2) {
                  event2.stopPropagation();
                });
              });
              if (document && document.body) {
                this.onClick = function(event) {
                  if (!_hasParent(event.target, container)) {
                    me.deactivate();
                  }
                };
                document.body.addEventListener("click", this.onClick);
              }
              if (this.keycharm !== void 0) {
                this.keycharm.destroy();
              }
              this.keycharm = keycharm();
              this.escListener = this.deactivate.bind(this);
            }
            Emitter(Activator.prototype);
            Activator.current = null;
            Activator.prototype.destroy = function() {
              this.deactivate();
              this.dom.overlay.parentNode.removeChild(this.dom.overlay);
              if (this.onClick) {
                document.body.removeEventListener("click", this.onClick);
              }
              this.hammer.destroy();
              this.hammer = null;
            };
            Activator.prototype.activate = function() {
              if (Activator.current) {
                Activator.current.deactivate();
              }
              Activator.current = this;
              this.active = true;
              this.dom.overlay.style.display = "none";
              util.addClassName(this.dom.container, "vis-active");
              this.emit("change");
              this.emit("activate");
              this.keycharm.bind("esc", this.escListener);
            };
            Activator.prototype.deactivate = function() {
              this.active = false;
              this.dom.overlay.style.display = "";
              util.removeClassName(this.dom.container, "vis-active");
              this.keycharm.unbind("esc", this.escListener);
              this.emit("change");
              this.emit("deactivate");
            };
            Activator.prototype._onTapOverlay = function(event) {
              this.activate();
              event.stopPropagation();
            };
            function _hasParent(element, parent) {
              while (element) {
                if (element === parent) {
                  return true;
                }
                element = element.parentNode;
              }
              return false;
            }
            module2.exports = Activator;
          },
          /* 98 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2["en"] = {
              current: "current",
              time: "time"
            };
            exports2["en_EN"] = exports2["en"];
            exports2["en_US"] = exports2["en"];
            exports2["it"] = {
              current: "attuale",
              time: "tempo"
            };
            exports2["it_IT"] = exports2["it"];
            exports2["it_CH"] = exports2["it"];
            exports2["nl"] = {
              current: "huidige",
              time: "tijd"
            };
            exports2["nl_NL"] = exports2["nl"];
            exports2["nl_BE"] = exports2["nl"];
            exports2["de"] = {
              current: "Aktuelle",
              time: "Zeit"
            };
            exports2["de_DE"] = exports2["de"];
            exports2["fr"] = {
              current: "actuel",
              time: "heure"
            };
            exports2["fr_FR"] = exports2["fr"];
            exports2["fr_CA"] = exports2["fr"];
            exports2["fr_BE"] = exports2["fr"];
            exports2["es"] = {
              current: "corriente",
              time: "hora"
            };
            exports2["es_ES"] = exports2["es"];
          },
          /* 99 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(10);
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var TimeStep = __webpack_require__(66);
            var Component = __webpack_require__(16);
            var Group = __webpack_require__(68);
            var BackgroundGroup = __webpack_require__(69);
            var BoxItem = __webpack_require__(101);
            var PointItem = __webpack_require__(102);
            var RangeItem = __webpack_require__(70);
            var BackgroundItem = __webpack_require__(103);
            var Popup = __webpack_require__(104)["default"];
            var UNGROUPED = "__ungrouped__";
            var BACKGROUND = "__background__";
            function ItemSet(body, options) {
              this.body = body;
              this.defaultOptions = {
                type: null,
                // 'box', 'point', 'range', 'background'
                orientation: {
                  item: "bottom"
                  // item orientation: 'top' or 'bottom'
                },
                align: "auto",
                // alignment of box items
                stack: true,
                stackSubgroups: true,
                groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
                  var targetOrder = toGroup.order;
                  toGroup.order = fromGroup.order;
                  fromGroup.order = targetOrder;
                },
                groupOrder: "order",
                selectable: true,
                multiselect: false,
                itemsAlwaysDraggable: {
                  item: false,
                  range: false
                },
                editable: {
                  updateTime: false,
                  updateGroup: false,
                  add: false,
                  remove: false,
                  overrideItems: false
                },
                groupEditable: {
                  order: false,
                  add: false,
                  remove: false
                },
                snap: TimeStep.snap,
                // Only called when `objectData.target === 'item'.
                onDropObjectOnItem: function onDropObjectOnItem(objectData, item, callback) {
                  callback(item);
                },
                onAdd: function onAdd(item, callback) {
                  callback(item);
                },
                onUpdate: function onUpdate(item, callback) {
                  callback(item);
                },
                onMove: function onMove(item, callback) {
                  callback(item);
                },
                onRemove: function onRemove(item, callback) {
                  callback(item);
                },
                onMoving: function onMoving(item, callback) {
                  callback(item);
                },
                onAddGroup: function onAddGroup(item, callback) {
                  callback(item);
                },
                onMoveGroup: function onMoveGroup(item, callback) {
                  callback(item);
                },
                onRemoveGroup: function onRemoveGroup(item, callback) {
                  callback(item);
                },
                margin: {
                  item: {
                    horizontal: 10,
                    vertical: 10
                  },
                  axis: 20
                },
                showTooltips: true,
                tooltip: {
                  followMouse: false,
                  overflowMethod: "flip"
                },
                tooltipOnItemUpdateTime: false
              };
              this.options = util.extend({}, this.defaultOptions);
              this.options.rtl = options.rtl;
              this.itemOptions = {
                type: { start: "Date", end: "Date" }
              };
              this.conversion = {
                toScreen: body.util.toScreen,
                toTime: body.util.toTime
              };
              this.dom = {};
              this.props = {};
              this.hammer = null;
              var me = this;
              this.itemsData = null;
              this.groupsData = null;
              this.itemListeners = {
                "add": function add(event, params, senderId) {
                  me._onAdd(params.items);
                },
                "update": function update(event, params, senderId) {
                  me._onUpdate(params.items);
                },
                "remove": function remove(event, params, senderId) {
                  me._onRemove(params.items);
                }
              };
              this.groupListeners = {
                "add": function add(event, params, senderId) {
                  me._onAddGroups(params.items);
                  if (me.groupsData && me.groupsData.length > 0) {
                    var groupsData = me.groupsData.getDataSet();
                    groupsData.get().forEach(function(groupData) {
                      if (groupData.nestedGroups) {
                        if (groupData.showNested != false) {
                          groupData.showNested = true;
                        }
                        var updatedGroups = [];
                        groupData.nestedGroups.forEach(function(nestedGroupId) {
                          var updatedNestedGroup = groupsData.get(nestedGroupId);
                          if (!updatedNestedGroup) {
                            return;
                          }
                          updatedNestedGroup.nestedInGroup = groupData.id;
                          if (groupData.showNested == false) {
                            updatedNestedGroup.visible = false;
                          }
                          updatedGroups = updatedGroups.concat(updatedNestedGroup);
                        });
                        groupsData.update(updatedGroups, senderId);
                      }
                    });
                  }
                },
                "update": function update(event, params, senderId) {
                  me._onUpdateGroups(params.items);
                },
                "remove": function remove(event, params, senderId) {
                  me._onRemoveGroups(params.items);
                }
              };
              this.items = {};
              this.groups = {};
              this.groupIds = [];
              this.selection = [];
              this.popup = null;
              this.touchParams = {};
              this.groupTouchParams = {};
              this._create();
              this.setOptions(options);
            }
            ItemSet.prototype = new Component();
            ItemSet.types = {
              background: BackgroundItem,
              box: BoxItem,
              range: RangeItem,
              point: PointItem
            };
            ItemSet.prototype._create = function() {
              var frame = document.createElement("div");
              frame.className = "vis-itemset";
              frame["timeline-itemset"] = this;
              this.dom.frame = frame;
              var background = document.createElement("div");
              background.className = "vis-background";
              frame.appendChild(background);
              this.dom.background = background;
              var foreground = document.createElement("div");
              foreground.className = "vis-foreground";
              frame.appendChild(foreground);
              this.dom.foreground = foreground;
              var axis = document.createElement("div");
              axis.className = "vis-axis";
              this.dom.axis = axis;
              var labelSet = document.createElement("div");
              labelSet.className = "vis-labelset";
              this.dom.labelSet = labelSet;
              this._updateUngrouped();
              var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
              backgroundGroup.show();
              this.groups[BACKGROUND] = backgroundGroup;
              this.hammer = new Hammer(this.body.dom.centerContainer);
              this.hammer.on("hammer.input", (function(event) {
                if (event.isFirst) {
                  this._onTouch(event);
                }
              }).bind(this));
              this.hammer.on("panstart", this._onDragStart.bind(this));
              this.hammer.on("panmove", this._onDrag.bind(this));
              this.hammer.on("panend", this._onDragEnd.bind(this));
              this.hammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_HORIZONTAL });
              this.hammer.on("tap", this._onSelectItem.bind(this));
              this.hammer.on("press", this._onMultiSelectItem.bind(this));
              this.hammer.on("doubletap", this._onAddItem.bind(this));
              if (this.options.rtl) {
                this.groupHammer = new Hammer(this.body.dom.rightContainer);
              } else {
                this.groupHammer = new Hammer(this.body.dom.leftContainer);
              }
              this.groupHammer.on("tap", this._onGroupClick.bind(this));
              this.groupHammer.on("panstart", this._onGroupDragStart.bind(this));
              this.groupHammer.on("panmove", this._onGroupDrag.bind(this));
              this.groupHammer.on("panend", this._onGroupDragEnd.bind(this));
              this.groupHammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_VERTICAL });
              this.body.dom.centerContainer.addEventListener("mouseover", this._onMouseOver.bind(this));
              this.body.dom.centerContainer.addEventListener("mouseout", this._onMouseOut.bind(this));
              this.body.dom.centerContainer.addEventListener("mousemove", this._onMouseMove.bind(this));
              this.body.dom.centerContainer.addEventListener("contextmenu", this._onDragEnd.bind(this));
              this.body.dom.centerContainer.addEventListener("mousewheel", this._onMouseWheel.bind(this));
              this.show();
            };
            ItemSet.prototype.setOptions = function(options) {
              if (options) {
                var fields = ["type", "rtl", "align", "order", "stack", "stackSubgroups", "selectable", "multiselect", "multiselectPerGroup", "groupOrder", "dataAttributes", "template", "groupTemplate", "visibleFrameTemplate", "hide", "snap", "groupOrderSwap", "showTooltips", "tooltip", "tooltipOnItemUpdateTime"];
                util.selectiveExtend(fields, this.options, options);
                if ("itemsAlwaysDraggable" in options) {
                  if (typeof options.itemsAlwaysDraggable === "boolean") {
                    this.options.itemsAlwaysDraggable.item = options.itemsAlwaysDraggable;
                    this.options.itemsAlwaysDraggable.range = false;
                  } else if ((0, _typeof3["default"])(options.itemsAlwaysDraggable) === "object") {
                    util.selectiveExtend(["item", "range"], this.options.itemsAlwaysDraggable, options.itemsAlwaysDraggable);
                    if (!this.options.itemsAlwaysDraggable.item) {
                      this.options.itemsAlwaysDraggable.range = false;
                    }
                  }
                }
                if ("orientation" in options) {
                  if (typeof options.orientation === "string") {
                    this.options.orientation.item = options.orientation === "top" ? "top" : "bottom";
                  } else if ((0, _typeof3["default"])(options.orientation) === "object" && "item" in options.orientation) {
                    this.options.orientation.item = options.orientation.item;
                  }
                }
                if ("margin" in options) {
                  if (typeof options.margin === "number") {
                    this.options.margin.axis = options.margin;
                    this.options.margin.item.horizontal = options.margin;
                    this.options.margin.item.vertical = options.margin;
                  } else if ((0, _typeof3["default"])(options.margin) === "object") {
                    util.selectiveExtend(["axis"], this.options.margin, options.margin);
                    if ("item" in options.margin) {
                      if (typeof options.margin.item === "number") {
                        this.options.margin.item.horizontal = options.margin.item;
                        this.options.margin.item.vertical = options.margin.item;
                      } else if ((0, _typeof3["default"])(options.margin.item) === "object") {
                        util.selectiveExtend(["horizontal", "vertical"], this.options.margin.item, options.margin.item);
                      }
                    }
                  }
                }
                if ("editable" in options) {
                  if (typeof options.editable === "boolean") {
                    this.options.editable.updateTime = options.editable;
                    this.options.editable.updateGroup = options.editable;
                    this.options.editable.add = options.editable;
                    this.options.editable.remove = options.editable;
                    this.options.editable.overrideItems = false;
                  } else if ((0, _typeof3["default"])(options.editable) === "object") {
                    util.selectiveExtend(["updateTime", "updateGroup", "add", "remove", "overrideItems"], this.options.editable, options.editable);
                  }
                }
                if ("groupEditable" in options) {
                  if (typeof options.groupEditable === "boolean") {
                    this.options.groupEditable.order = options.groupEditable;
                    this.options.groupEditable.add = options.groupEditable;
                    this.options.groupEditable.remove = options.groupEditable;
                  } else if ((0, _typeof3["default"])(options.groupEditable) === "object") {
                    util.selectiveExtend(["order", "add", "remove"], this.options.groupEditable, options.groupEditable);
                  }
                }
                var addCallback = (function(name) {
                  var fn = options[name];
                  if (fn) {
                    if (!(fn instanceof Function)) {
                      throw new Error("option " + name + " must be a function " + name + "(item, callback)");
                    }
                    this.options[name] = fn;
                  }
                }).bind(this);
                ["onDropObjectOnItem", "onAdd", "onUpdate", "onRemove", "onMove", "onMoving", "onAddGroup", "onMoveGroup", "onRemoveGroup"].forEach(addCallback);
                this.markDirty();
              }
            };
            ItemSet.prototype.markDirty = function(options) {
              this.groupIds = [];
              if (options && options.refreshItems) {
                util.forEach(this.items, function(item) {
                  item.dirty = true;
                  if (item.displayed) item.redraw();
                });
              }
            };
            ItemSet.prototype.destroy = function() {
              this.hide();
              this.setItems(null);
              this.setGroups(null);
              this.hammer = null;
              this.body = null;
              this.conversion = null;
            };
            ItemSet.prototype.hide = function() {
              if (this.dom.frame.parentNode) {
                this.dom.frame.parentNode.removeChild(this.dom.frame);
              }
              if (this.dom.axis.parentNode) {
                this.dom.axis.parentNode.removeChild(this.dom.axis);
              }
              if (this.dom.labelSet.parentNode) {
                this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
              }
            };
            ItemSet.prototype.show = function() {
              if (!this.dom.frame.parentNode) {
                this.body.dom.center.appendChild(this.dom.frame);
              }
              if (!this.dom.axis.parentNode) {
                this.body.dom.backgroundVertical.appendChild(this.dom.axis);
              }
              if (!this.dom.labelSet.parentNode) {
                if (this.options.rtl) {
                  this.body.dom.right.appendChild(this.dom.labelSet);
                } else {
                  this.body.dom.left.appendChild(this.dom.labelSet);
                }
              }
            };
            ItemSet.prototype.setSelection = function(ids) {
              var i, ii, id, item;
              if (ids == void 0) ids = [];
              if (!Array.isArray(ids)) ids = [ids];
              for (i = 0, ii = this.selection.length; i < ii; i++) {
                id = this.selection[i];
                item = this.items[id];
                if (item) item.unselect();
              }
              this.selection = [];
              for (i = 0, ii = ids.length; i < ii; i++) {
                id = ids[i];
                item = this.items[id];
                if (item) {
                  this.selection.push(id);
                  item.select();
                }
              }
            };
            ItemSet.prototype.getSelection = function() {
              return this.selection.concat([]);
            };
            ItemSet.prototype.getVisibleItems = function() {
              var range = this.body.range.getRange();
              var right, left;
              if (this.options.rtl) {
                right = this.body.util.toScreen(range.start);
                left = this.body.util.toScreen(range.end);
              } else {
                left = this.body.util.toScreen(range.start);
                right = this.body.util.toScreen(range.end);
              }
              var ids = [];
              for (var groupId in this.groups) {
                if (this.groups.hasOwnProperty(groupId)) {
                  var group = this.groups[groupId];
                  var rawVisibleItems = group.isVisible ? group.visibleItems : [];
                  for (var i = 0; i < rawVisibleItems.length; i++) {
                    var item = rawVisibleItems[i];
                    if (this.options.rtl) {
                      if (item.right < left && item.right + item.width > right) {
                        ids.push(item.id);
                      }
                    } else {
                      if (item.left < right && item.left + item.width > left) {
                        ids.push(item.id);
                      }
                    }
                  }
                }
              }
              return ids;
            };
            ItemSet.prototype._deselect = function(id) {
              var selection = this.selection;
              for (var i = 0, ii = selection.length; i < ii; i++) {
                if (selection[i] == id) {
                  selection.splice(i, 1);
                  break;
                }
              }
            };
            ItemSet.prototype.redraw = function() {
              var margin = this.options.margin, range = this.body.range, asSize = util.option.asSize, options = this.options, orientation = options.orientation.item, resized = false, frame = this.dom.frame;
              this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
              if (this.options.rtl) {
                this.props.right = this.body.domProps.right.width + this.body.domProps.border.right;
              } else {
                this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;
              }
              frame.className = "vis-itemset";
              resized = this._orderGroups() || resized;
              var visibleInterval = range.end - range.start;
              var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
              var scrolled = range.start != this.lastRangeStart;
              var changedStackOption = options.stack != this.lastStack;
              var changedStackSubgroupsOption = options.stackSubgroups != this.lastStackSubgroups;
              var forceRestack = zoomed || scrolled || changedStackOption || changedStackSubgroupsOption;
              this.lastVisibleInterval = visibleInterval;
              this.lastRangeStart = range.start;
              this.lastStack = options.stack;
              this.lastStackSubgroups = options.stackSubgroups;
              this.props.lastWidth = this.props.width;
              var firstGroup = this._firstGroup();
              var firstMargin = {
                item: margin.item,
                axis: margin.axis
              };
              var nonFirstMargin = {
                item: margin.item,
                axis: margin.item.vertical / 2
              };
              var height = 0;
              var minHeight = margin.axis + margin.item.vertical;
              this.groups[BACKGROUND].redraw(range, nonFirstMargin, forceRestack);
              var redrawQueue = {};
              var redrawQueueLength = 0;
              util.forEach(this.groups, function(group, key) {
                if (key === BACKGROUND) return;
                var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
                var returnQueue = true;
                redrawQueue[key] = group.redraw(range, groupMargin, forceRestack, returnQueue);
                redrawQueueLength = redrawQueue[key].length;
              });
              var needRedraw = redrawQueueLength > 0;
              if (needRedraw) {
                var redrawResults = {};
                for (var i = 0; i < redrawQueueLength; i++) {
                  util.forEach(redrawQueue, function(fns, key) {
                    redrawResults[key] = fns[i]();
                  });
                }
                util.forEach(this.groups, function(group, key) {
                  if (key === BACKGROUND) return;
                  var groupResized = redrawResults[key];
                  resized = groupResized || resized;
                  height += group.height;
                });
                height = Math.max(height, minHeight);
              }
              height = Math.max(height, minHeight);
              frame.style.height = asSize(height);
              this.props.width = frame.offsetWidth;
              this.props.height = height;
              this.dom.axis.style.top = asSize(orientation == "top" ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
              if (this.options.rtl) {
                this.dom.axis.style.right = "0";
              } else {
                this.dom.axis.style.left = "0";
              }
              this.initialItemSetDrawn = true;
              resized = this._isResized() || resized;
              return resized;
            };
            ItemSet.prototype._firstGroup = function() {
              var firstGroupIndex = this.options.orientation.item == "top" ? 0 : this.groupIds.length - 1;
              var firstGroupId = this.groupIds[firstGroupIndex];
              var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];
              return firstGroup || null;
            };
            ItemSet.prototype._updateUngrouped = function() {
              var ungrouped = this.groups[UNGROUPED];
              var item, itemId;
              if (this.groupsData) {
                if (ungrouped) {
                  ungrouped.hide();
                  delete this.groups[UNGROUPED];
                  for (itemId in this.items) {
                    if (this.items.hasOwnProperty(itemId)) {
                      item = this.items[itemId];
                      item.parent && item.parent.remove(item);
                      var groupId = this._getGroupId(item.data);
                      var group = this.groups[groupId];
                      group && group.add(item) || item.hide();
                    }
                  }
                }
              } else {
                if (!ungrouped) {
                  var id = null;
                  var data = null;
                  ungrouped = new Group(id, data, this);
                  this.groups[UNGROUPED] = ungrouped;
                  for (itemId in this.items) {
                    if (this.items.hasOwnProperty(itemId)) {
                      item = this.items[itemId];
                      ungrouped.add(item);
                    }
                  }
                  ungrouped.show();
                }
              }
            };
            ItemSet.prototype.getLabelSet = function() {
              return this.dom.labelSet;
            };
            ItemSet.prototype.setItems = function(items) {
              var me = this, ids, oldItemsData = this.itemsData;
              if (!items) {
                this.itemsData = null;
              } else if (items instanceof DataSet || items instanceof DataView) {
                this.itemsData = items;
              } else {
                throw new TypeError("Data must be an instance of DataSet or DataView");
              }
              if (oldItemsData) {
                util.forEach(this.itemListeners, function(callback, event) {
                  oldItemsData.off(event, callback);
                });
                ids = oldItemsData.getIds();
                this._onRemove(ids);
              }
              if (this.itemsData) {
                var id = this.id;
                util.forEach(this.itemListeners, function(callback, event) {
                  me.itemsData.on(event, callback, id);
                });
                ids = this.itemsData.getIds();
                this._onAdd(ids);
                this._updateUngrouped();
              }
              this.body.emitter.emit("_change", { queue: true });
            };
            ItemSet.prototype.getItems = function() {
              return this.itemsData;
            };
            ItemSet.prototype.setGroups = function(groups) {
              var me = this, ids;
              if (this.groupsData) {
                util.forEach(this.groupListeners, function(callback, event) {
                  me.groupsData.off(event, callback);
                });
                ids = this.groupsData.getIds();
                this.groupsData = null;
                this._onRemoveGroups(ids);
              }
              if (!groups) {
                this.groupsData = null;
              } else if (groups instanceof DataSet || groups instanceof DataView) {
                this.groupsData = groups;
              } else {
                throw new TypeError("Data must be an instance of DataSet or DataView");
              }
              if (this.groupsData) {
                var groupsData = this.groupsData;
                if (this.groupsData instanceof DataView) {
                  groupsData = this.groupsData.getDataSet();
                }
                groupsData.get().forEach(function(group) {
                  if (group.nestedGroups) {
                    group.nestedGroups.forEach(function(nestedGroupId) {
                      var updatedNestedGroup = groupsData.get(nestedGroupId);
                      updatedNestedGroup.nestedInGroup = group.id;
                      if (group.showNested == false) {
                        updatedNestedGroup.visible = false;
                      }
                      groupsData.update(updatedNestedGroup);
                    });
                  }
                });
                var id = this.id;
                util.forEach(this.groupListeners, function(callback, event) {
                  me.groupsData.on(event, callback, id);
                });
                ids = this.groupsData.getIds();
                this._onAddGroups(ids);
              }
              this._updateUngrouped();
              this._order();
              this.body.emitter.emit("_change", { queue: true });
            };
            ItemSet.prototype.getGroups = function() {
              return this.groupsData;
            };
            ItemSet.prototype.removeItem = function(id) {
              var item = this.itemsData.get(id), dataset = this.itemsData.getDataSet();
              if (item) {
                this.options.onRemove(item, function(item2) {
                  if (item2) {
                    dataset.remove(id);
                  }
                });
              }
            };
            ItemSet.prototype._getType = function(itemData) {
              return itemData.type || this.options.type || (itemData.end ? "range" : "box");
            };
            ItemSet.prototype._getGroupId = function(itemData) {
              var type = this._getType(itemData);
              if (type == "background" && itemData.group == void 0) {
                return BACKGROUND;
              } else {
                return this.groupsData ? itemData.group : UNGROUPED;
              }
            };
            ItemSet.prototype._onUpdate = function(ids) {
              var me = this;
              ids.forEach((function(id) {
                var itemData = me.itemsData.get(id, me.itemOptions);
                var item = me.items[id];
                var type = itemData ? me._getType(itemData) : null;
                var constructor = ItemSet.types[type];
                var selected;
                if (item) {
                  if (!constructor || !(item instanceof constructor)) {
                    selected = item.selected;
                    me._removeItem(item);
                    item = null;
                  } else {
                    me._updateItem(item, itemData);
                  }
                }
                if (!item && itemData) {
                  if (constructor) {
                    item = new constructor(itemData, me.conversion, me.options);
                    item.id = id;
                    me._addItem(item);
                    if (selected) {
                      this.selection.push(id);
                      item.select();
                    }
                  } else if (type == "rangeoverflow") {
                    throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: .vis-item.vis-range .vis-item-content {overflow: visible;}');
                  } else {
                    throw new TypeError('Unknown item type "' + type + '"');
                  }
                }
              }).bind(this));
              this._order();
              this.body.emitter.emit("_change", { queue: true });
            };
            ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;
            ItemSet.prototype._onRemove = function(ids) {
              var count = 0;
              var me = this;
              ids.forEach(function(id) {
                var item = me.items[id];
                if (item) {
                  count++;
                  me._removeItem(item);
                }
              });
              if (count) {
                this._order();
                this.body.emitter.emit("_change", { queue: true });
              }
            };
            ItemSet.prototype._order = function() {
              util.forEach(this.groups, function(group) {
                group.order();
              });
            };
            ItemSet.prototype._onUpdateGroups = function(ids) {
              this._onAddGroups(ids);
            };
            ItemSet.prototype._onAddGroups = function(ids) {
              var me = this;
              ids.forEach(function(id) {
                var groupData = me.groupsData.get(id);
                var group = me.groups[id];
                if (!group) {
                  if (id == UNGROUPED || id == BACKGROUND) {
                    throw new Error("Illegal group id. " + id + " is a reserved id.");
                  }
                  var groupOptions = (0, _create2["default"])(me.options);
                  util.extend(groupOptions, {
                    height: null
                  });
                  group = new Group(id, groupData, me);
                  me.groups[id] = group;
                  for (var itemId in me.items) {
                    if (me.items.hasOwnProperty(itemId)) {
                      var item = me.items[itemId];
                      if (item.data.group == id) {
                        group.add(item);
                      }
                    }
                  }
                  group.order();
                  group.show();
                } else {
                  group.setData(groupData);
                }
              });
              this.body.emitter.emit("_change", { queue: true });
            };
            ItemSet.prototype._onRemoveGroups = function(ids) {
              var groups = this.groups;
              ids.forEach(function(id) {
                var group = groups[id];
                if (group) {
                  group.hide();
                  delete groups[id];
                }
              });
              this.markDirty();
              this.body.emitter.emit("_change", { queue: true });
            };
            ItemSet.prototype._orderGroups = function() {
              if (this.groupsData) {
                var groupIds = this.groupsData.getIds({
                  order: this.options.groupOrder
                });
                groupIds = this._orderNestedGroups(groupIds);
                var changed = !util.equalArray(groupIds, this.groupIds);
                if (changed) {
                  var groups = this.groups;
                  groupIds.forEach(function(groupId) {
                    groups[groupId].hide();
                  });
                  groupIds.forEach(function(groupId) {
                    groups[groupId].show();
                  });
                  this.groupIds = groupIds;
                }
                return changed;
              } else {
                return false;
              }
            };
            ItemSet.prototype._orderNestedGroups = function(groupIds) {
              var newGroupIdsOrder = [];
              groupIds.forEach(function(groupId) {
                var groupData = this.groupsData.get(groupId);
                if (!groupData.nestedInGroup) {
                  newGroupIdsOrder.push(groupId);
                }
                if (groupData.nestedGroups) {
                  var nestedGroups = this.groupsData.get({
                    filter: function filter(nestedGroup) {
                      return nestedGroup.nestedInGroup == groupId;
                    },
                    order: this.options.groupOrder
                  });
                  var nestedGroupIds = nestedGroups.map(function(nestedGroup) {
                    return nestedGroup.id;
                  });
                  newGroupIdsOrder = newGroupIdsOrder.concat(nestedGroupIds);
                }
              }, this);
              return newGroupIdsOrder;
            };
            ItemSet.prototype._addItem = function(item) {
              this.items[item.id] = item;
              var groupId = this._getGroupId(item.data);
              var group = this.groups[groupId];
              if (!group) {
                item.groupShowing = false;
              } else if (group && group.data && group.data.showNested) {
                item.groupShowing = true;
              }
              if (group) group.add(item);
            };
            ItemSet.prototype._updateItem = function(item, itemData) {
              item.setData(itemData);
              var groupId = this._getGroupId(item.data);
              var group = this.groups[groupId];
              if (!group) {
                item.groupShowing = false;
              } else if (group && group.data && group.data.showNested) {
                item.groupShowing = true;
              }
            };
            ItemSet.prototype._removeItem = function(item) {
              item.hide();
              delete this.items[item.id];
              var index = this.selection.indexOf(item.id);
              if (index != -1) this.selection.splice(index, 1);
              item.parent && item.parent.remove(item);
            };
            ItemSet.prototype._constructByEndArray = function(array) {
              var endArray = [];
              for (var i = 0; i < array.length; i++) {
                if (array[i] instanceof RangeItem) {
                  endArray.push(array[i]);
                }
              }
              return endArray;
            };
            ItemSet.prototype._onTouch = function(event) {
              this.touchParams.item = this.itemFromTarget(event);
              this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
              this.touchParams.dragRightItem = event.target.dragRightItem || false;
              this.touchParams.itemProps = null;
            };
            ItemSet.prototype._getGroupIndex = function(groupId) {
              for (var i = 0; i < this.groupIds.length; i++) {
                if (groupId == this.groupIds[i]) return i;
              }
            };
            ItemSet.prototype._onDragStart = function(event) {
              if (this.touchParams.itemIsDragging) {
                return;
              }
              var item = this.touchParams.item || null;
              var me = this;
              var props;
              if (item && (item.selected || this.options.itemsAlwaysDraggable.item)) {
                if (this.options.editable.overrideItems && !this.options.editable.updateTime && !this.options.editable.updateGroup) {
                  return;
                }
                if (item.editable != null && !item.editable.updateTime && !item.editable.updateGroup && !this.options.editable.overrideItems) {
                  return;
                }
                var dragLeftItem = this.touchParams.dragLeftItem;
                var dragRightItem = this.touchParams.dragRightItem;
                this.touchParams.itemIsDragging = true;
                this.touchParams.selectedItem = item;
                if (dragLeftItem) {
                  props = {
                    item: dragLeftItem,
                    initialX: event.center.x,
                    dragLeft: true,
                    data: this._cloneItemData(item.data)
                  };
                  this.touchParams.itemProps = [props];
                } else if (dragRightItem) {
                  props = {
                    item: dragRightItem,
                    initialX: event.center.x,
                    dragRight: true,
                    data: this._cloneItemData(item.data)
                  };
                  this.touchParams.itemProps = [props];
                } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
                  this._onDragStartAddItem(event);
                } else {
                  if (this.groupIds.length < 1) {
                    this.redraw();
                  }
                  var baseGroupIndex = this._getGroupIndex(item.data.group);
                  var itemsToDrag = this.options.itemsAlwaysDraggable.item && !item.selected ? [item.id] : this.getSelection();
                  this.touchParams.itemProps = itemsToDrag.map((function(id) {
                    var item2 = me.items[id];
                    var groupIndex = me._getGroupIndex(item2.data.group);
                    return {
                      item: item2,
                      initialX: event.center.x,
                      groupOffset: baseGroupIndex - groupIndex,
                      data: this._cloneItemData(item2.data)
                    };
                  }).bind(this));
                }
                event.stopPropagation();
              } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
                this._onDragStartAddItem(event);
              }
            };
            ItemSet.prototype._onDragStartAddItem = function(event) {
              var xAbs;
              var x;
              var snap = this.options.snap || null;
              if (this.options.rtl) {
                xAbs = util.getAbsoluteRight(this.dom.frame);
                x = xAbs - event.center.x + 10;
              } else {
                xAbs = util.getAbsoluteLeft(this.dom.frame);
                x = event.center.x - xAbs - 10;
              }
              var time = this.body.util.toTime(x);
              var scale = this.body.util.getScale();
              var step = this.body.util.getStep();
              var start = snap ? snap(time, scale, step) : time;
              var end = start;
              var itemData = {
                type: "range",
                start,
                end,
                content: "new item"
              };
              var id = util.randomUUID();
              itemData[this.itemsData._fieldId] = id;
              var group = this.groupFromTarget(event);
              if (group) {
                itemData.group = group.groupId;
              }
              var newItem = new RangeItem(itemData, this.conversion, this.options);
              newItem.id = id;
              newItem.data = this._cloneItemData(itemData);
              this._addItem(newItem);
              this.touchParams.selectedItem = newItem;
              var props = {
                item: newItem,
                initialX: event.center.x,
                data: newItem.data
              };
              if (this.options.rtl) {
                props.dragLeft = true;
              } else {
                props.dragRight = true;
              }
              this.touchParams.itemProps = [props];
              event.stopPropagation();
            };
            ItemSet.prototype._onDrag = function(event) {
              if (this.touchParams.itemProps) {
                event.stopPropagation();
                var me = this;
                var snap = this.options.snap || null;
                var xOffset;
                if (this.options.rtl) {
                  xOffset = this.body.dom.root.offsetLeft + this.body.domProps.right.width;
                } else {
                  xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
                }
                var scale = this.body.util.getScale();
                var step = this.body.util.getStep();
                var selectedItem = this.touchParams.selectedItem;
                var updateGroupAllowed = (this.options.editable.overrideItems || selectedItem.editable == null) && this.options.editable.updateGroup || !this.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateGroup;
                var newGroupBase = null;
                if (updateGroupAllowed && selectedItem) {
                  if (selectedItem.data.group != void 0) {
                    var group = me.groupFromTarget(event);
                    if (group) {
                      newGroupBase = this._getGroupIndex(group.groupId);
                    }
                  }
                }
                this.touchParams.itemProps.forEach((function(props) {
                  var current = me.body.util.toTime(event.center.x - xOffset);
                  var initial = me.body.util.toTime(props.initialX - xOffset);
                  var offset;
                  var initialStart;
                  var initialEnd;
                  var start;
                  var end;
                  if (this.options.rtl) {
                    offset = -(current - initial);
                  } else {
                    offset = current - initial;
                  }
                  var itemData = this._cloneItemData(props.item.data);
                  if (props.item.editable != null && !props.item.editable.updateTime && !props.item.editable.updateGroup && !me.options.editable.overrideItems) {
                    return;
                  }
                  var updateTimeAllowed = (this.options.editable.overrideItems || selectedItem.editable == null) && this.options.editable.updateTime || !this.options.editable.overrideItems && selectedItem.editable != null && selectedItem.editable.updateTime;
                  if (updateTimeAllowed) {
                    if (props.dragLeft) {
                      if (this.options.rtl) {
                        if (itemData.end != void 0) {
                          initialEnd = util.convert(props.data.end, "Date");
                          end = new Date(initialEnd.valueOf() + offset);
                          itemData.end = snap ? snap(end, scale, step) : end;
                        }
                      } else {
                        if (itemData.start != void 0) {
                          initialStart = util.convert(props.data.start, "Date");
                          start = new Date(initialStart.valueOf() + offset);
                          itemData.start = snap ? snap(start, scale, step) : start;
                        }
                      }
                    } else if (props.dragRight) {
                      if (this.options.rtl) {
                        if (itemData.start != void 0) {
                          initialStart = util.convert(props.data.start, "Date");
                          start = new Date(initialStart.valueOf() + offset);
                          itemData.start = snap ? snap(start, scale, step) : start;
                        }
                      } else {
                        if (itemData.end != void 0) {
                          initialEnd = util.convert(props.data.end, "Date");
                          end = new Date(initialEnd.valueOf() + offset);
                          itemData.end = snap ? snap(end, scale, step) : end;
                        }
                      }
                    } else {
                      if (itemData.start != void 0) {
                        initialStart = util.convert(props.data.start, "Date").valueOf();
                        start = new Date(initialStart + offset);
                        if (itemData.end != void 0) {
                          initialEnd = util.convert(props.data.end, "Date");
                          var duration = initialEnd.valueOf() - initialStart.valueOf();
                          itemData.start = snap ? snap(start, scale, step) : start;
                          itemData.end = new Date(itemData.start.valueOf() + duration);
                        } else {
                          itemData.start = snap ? snap(start, scale, step) : start;
                        }
                      }
                    }
                  }
                  if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
                    if (itemData.group != void 0) {
                      var newOffset = newGroupBase - props.groupOffset;
                      newOffset = Math.max(0, newOffset);
                      newOffset = Math.min(me.groupIds.length - 1, newOffset);
                      itemData.group = me.groupIds[newOffset];
                    }
                  }
                  itemData = this._cloneItemData(itemData);
                  me.options.onMoving(itemData, (function(itemData2) {
                    if (itemData2) {
                      props.item.setData(this._cloneItemData(itemData2, "Date"));
                    }
                  }).bind(this));
                }).bind(this));
                this.body.emitter.emit("_change");
              }
            };
            ItemSet.prototype._moveToGroup = function(item, groupId) {
              var group = this.groups[groupId];
              if (group && group.groupId != item.data.group) {
                var oldGroup = item.parent;
                oldGroup.remove(item);
                oldGroup.order();
                item.data.group = group.groupId;
                group.add(item);
                group.order();
              }
            };
            ItemSet.prototype._onDragEnd = function(event) {
              this.touchParams.itemIsDragging = false;
              if (this.touchParams.itemProps) {
                event.stopPropagation();
                var me = this;
                var dataset = this.itemsData.getDataSet();
                var itemProps = this.touchParams.itemProps;
                this.touchParams.itemProps = null;
                itemProps.forEach((function(props) {
                  var id = props.item.id;
                  var exists = me.itemsData.get(id, me.itemOptions) != null;
                  if (!exists) {
                    me.options.onAdd(props.item.data, function(itemData2) {
                      me._removeItem(props.item);
                      if (itemData2) {
                        me.itemsData.getDataSet().add(itemData2);
                      }
                      me.body.emitter.emit("_change");
                    });
                  } else {
                    var itemData = this._cloneItemData(props.item.data);
                    me.options.onMove(itemData, function(itemData2) {
                      if (itemData2) {
                        itemData2[dataset._fieldId] = id;
                        dataset.update(itemData2);
                      } else {
                        props.item.setData(props.data);
                        me.body.emitter.emit("_change");
                      }
                    });
                  }
                }).bind(this));
              }
            };
            ItemSet.prototype._onGroupClick = function(event) {
              var group = this.groupFromTarget(event);
              if (!group || !group.nestedGroups) return;
              var groupsData = this.groupsData.getDataSet();
              var nestingGroup = groupsData.get(group.groupId);
              if (nestingGroup.showNested == void 0) {
                nestingGroup.showNested = true;
              }
              nestingGroup.showNested = !nestingGroup.showNested;
              var nestedGroups = groupsData.get(group.nestedGroups).map(function(nestedGroup) {
                nestedGroup.visible = nestingGroup.showNested;
                return nestedGroup;
              });
              groupsData.update(nestedGroups.concat(nestingGroup));
              if (nestingGroup.showNested) {
                util.removeClassName(group.dom.label, "collapsed");
                util.addClassName(group.dom.label, "expanded");
              } else {
                util.removeClassName(group.dom.label, "expanded");
                var collapsedDirClassName = this.options.rtl ? "collapsed-rtl" : "collapsed";
                util.addClassName(group.dom.label, collapsedDirClassName);
              }
            };
            ItemSet.prototype._onGroupDragStart = function(event) {
              if (this.options.groupEditable.order) {
                this.groupTouchParams.group = this.groupFromTarget(event);
                if (this.groupTouchParams.group) {
                  event.stopPropagation();
                  this.groupTouchParams.originalOrder = this.groupsData.getIds({
                    order: this.options.groupOrder
                  });
                }
              }
            };
            ItemSet.prototype._onGroupDrag = function(event) {
              if (this.options.groupEditable.order && this.groupTouchParams.group) {
                event.stopPropagation();
                var groupsData = this.groupsData;
                if (this.groupsData instanceof DataView) {
                  groupsData = this.groupsData.getDataSet();
                }
                var group = this.groupFromTarget(event);
                if (group && group.height != this.groupTouchParams.group.height) {
                  var movingUp = group.top < this.groupTouchParams.group.top;
                  var clientY = event.center ? event.center.y : event.clientY;
                  var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
                  var draggedGroupHeight = this.groupTouchParams.group.height;
                  if (movingUp) {
                    if (targetGroupTop + draggedGroupHeight < clientY) {
                      return;
                    }
                  } else {
                    var targetGroupHeight = group.height;
                    if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
                      return;
                    }
                  }
                }
                if (group && group != this.groupTouchParams.group) {
                  var targetGroup = groupsData.get(group.groupId);
                  var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);
                  if (draggedGroup && targetGroup) {
                    this.options.groupOrderSwap(draggedGroup, targetGroup, groupsData);
                    groupsData.update(draggedGroup);
                    groupsData.update(targetGroup);
                  }
                  var newOrder = groupsData.getIds({
                    order: this.options.groupOrder
                  });
                  if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
                    var origOrder = this.groupTouchParams.originalOrder;
                    var draggedId = this.groupTouchParams.group.groupId;
                    var numGroups = Math.min(origOrder.length, newOrder.length);
                    var curPos = 0;
                    var newOffset = 0;
                    var orgOffset = 0;
                    while (curPos < numGroups) {
                      while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
                        curPos++;
                      }
                      if (curPos + newOffset >= numGroups) {
                        break;
                      }
                      if (newOrder[curPos + newOffset] == draggedId) {
                        newOffset = 1;
                      } else if (origOrder[curPos + orgOffset] == draggedId) {
                        orgOffset = 1;
                      } else {
                        var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                        var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                        var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                        this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                        groupsData.update(switchGroup);
                        groupsData.update(shouldBeGroup);
                        var switchGroupId = newOrder[curPos + newOffset];
                        newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                        newOrder[slippedPosition] = switchGroupId;
                        curPos++;
                      }
                    }
                  }
                }
              }
            };
            ItemSet.prototype._onGroupDragEnd = function(event) {
              if (this.options.groupEditable.order && this.groupTouchParams.group) {
                event.stopPropagation();
                var me = this;
                var id = me.groupTouchParams.group.groupId;
                var dataset = me.groupsData.getDataSet();
                var groupData = util.extend({}, dataset.get(id));
                me.options.onMoveGroup(groupData, function(groupData2) {
                  if (groupData2) {
                    groupData2[dataset._fieldId] = id;
                    dataset.update(groupData2);
                  } else {
                    var newOrder = dataset.getIds({
                      order: me.options.groupOrder
                    });
                    if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
                      var origOrder = me.groupTouchParams.originalOrder;
                      var numGroups = Math.min(origOrder.length, newOrder.length);
                      var curPos = 0;
                      while (curPos < numGroups) {
                        while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
                          curPos++;
                        }
                        if (curPos >= numGroups) {
                          break;
                        }
                        var slippedPosition = newOrder.indexOf(origOrder[curPos]);
                        var switchGroup = dataset.get(newOrder[curPos]);
                        var shouldBeGroup = dataset.get(origOrder[curPos]);
                        me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
                        dataset.update(switchGroup);
                        dataset.update(shouldBeGroup);
                        var switchGroupId = newOrder[curPos];
                        newOrder[curPos] = origOrder[curPos];
                        newOrder[slippedPosition] = switchGroupId;
                        curPos++;
                      }
                    }
                  }
                });
                me.body.emitter.emit("groupDragged", { groupId: id });
              }
            };
            ItemSet.prototype._onSelectItem = function(event) {
              if (!this.options.selectable) return;
              var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
              var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
              if (ctrlKey || shiftKey) {
                this._onMultiSelectItem(event);
                return;
              }
              var oldSelection = this.getSelection();
              var item = this.itemFromTarget(event);
              var selection = item ? [item.id] : [];
              this.setSelection(selection);
              var newSelection = this.getSelection();
              if (newSelection.length > 0 || oldSelection.length > 0) {
                this.body.emitter.emit("select", {
                  items: newSelection,
                  event
                });
              }
            };
            ItemSet.prototype._onMouseOver = function(event) {
              var item = this.itemFromTarget(event);
              if (!item) return;
              var related = this.itemFromRelatedTarget(event);
              if (item === related) {
                return;
              }
              var title = item.getTitle();
              if (this.options.showTooltips && title) {
                if (this.popup == null) {
                  this.popup = new Popup(this.body.dom.root, this.options.tooltip.overflowMethod || "flip");
                }
                this.popup.setText(title);
                var container = this.body.dom.centerContainer;
                this.popup.setPosition(event.clientX - util.getAbsoluteLeft(container) + container.offsetLeft, event.clientY - util.getAbsoluteTop(container) + container.offsetTop);
                this.popup.show();
              } else {
                if (this.popup != null) {
                  this.popup.hide();
                }
              }
              this.body.emitter.emit("itemover", {
                item: item.id,
                event
              });
            };
            ItemSet.prototype._onMouseOut = function(event) {
              var item = this.itemFromTarget(event);
              if (!item) return;
              var related = this.itemFromRelatedTarget(event);
              if (item === related) {
                return;
              }
              if (this.popup != null) {
                this.popup.hide();
              }
              this.body.emitter.emit("itemout", {
                item: item.id,
                event
              });
            };
            ItemSet.prototype._onMouseMove = function(event) {
              var item = this.itemFromTarget(event);
              if (!item) return;
              if (this.options.showTooltips && this.options.tooltip.followMouse) {
                if (this.popup) {
                  if (!this.popup.hidden) {
                    var container = this.body.dom.centerContainer;
                    this.popup.setPosition(event.clientX - util.getAbsoluteLeft(container) + container.offsetLeft, event.clientY - util.getAbsoluteTop(container) + container.offsetTop);
                    this.popup.show();
                  }
                }
              }
            };
            ItemSet.prototype._onMouseWheel = function(event) {
              if (this.touchParams.itemIsDragging) {
                this._onDragEnd(event);
              }
            };
            ItemSet.prototype._onUpdateItem = function(item) {
              if (!this.options.selectable) return;
              if (!this.options.editable.add) return;
              var me = this;
              if (item) {
                var itemData = me.itemsData.get(item.id);
                this.options.onUpdate(itemData, function(itemData2) {
                  if (itemData2) {
                    me.itemsData.getDataSet().update(itemData2);
                  }
                });
              }
            };
            ItemSet.prototype._onDropObjectOnItem = function(event) {
              var item = this.itemFromTarget(event);
              var objectData = JSON.parse(event.dataTransfer.getData("text"));
              this.options.onDropObjectOnItem(objectData, item);
            };
            ItemSet.prototype._onAddItem = function(event) {
              if (!this.options.selectable) return;
              if (!this.options.editable.add) return;
              var me = this;
              var snap = this.options.snap || null;
              var xAbs;
              var x;
              if (this.options.rtl) {
                xAbs = util.getAbsoluteRight(this.dom.frame);
                x = xAbs - event.center.x;
              } else {
                xAbs = util.getAbsoluteLeft(this.dom.frame);
                x = event.center.x - xAbs;
              }
              var start = this.body.util.toTime(x);
              var scale = this.body.util.getScale();
              var step = this.body.util.getStep();
              var end;
              var newItemData;
              if (event.type == "drop") {
                newItemData = JSON.parse(event.dataTransfer.getData("text"));
                newItemData.content = newItemData.content ? newItemData.content : "new item";
                newItemData.start = newItemData.start ? newItemData.start : snap ? snap(start, scale, step) : start;
                newItemData.type = newItemData.type || "box";
                newItemData[this.itemsData._fieldId] = newItemData.id || util.randomUUID();
                if (newItemData.type == "range" && !newItemData.end) {
                  end = this.body.util.toTime(x + this.props.width / 5);
                  newItemData.end = snap ? snap(end, scale, step) : end;
                }
              } else {
                newItemData = {
                  start: snap ? snap(start, scale, step) : start,
                  content: "new item"
                };
                newItemData[this.itemsData._fieldId] = util.randomUUID();
                if (this.options.type === "range") {
                  end = this.body.util.toTime(x + this.props.width / 5);
                  newItemData.end = snap ? snap(end, scale, step) : end;
                }
              }
              var group = this.groupFromTarget(event);
              if (group) {
                newItemData.group = group.groupId;
              }
              newItemData = this._cloneItemData(newItemData);
              this.options.onAdd(newItemData, function(item) {
                if (item) {
                  me.itemsData.getDataSet().add(item);
                  if (event.type == "drop") {
                    me.setSelection([item.id]);
                  }
                }
              });
            };
            ItemSet.prototype._onMultiSelectItem = function(event) {
              if (!this.options.selectable) return;
              var item = this.itemFromTarget(event);
              if (item) {
                var selection = this.options.multiselect ? this.getSelection() : [];
                var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;
                if (shiftKey && this.options.multiselect) {
                  var itemGroup = this.itemsData.get(item.id).group;
                  var lastSelectedGroup = void 0;
                  if (this.options.multiselectPerGroup) {
                    if (selection.length > 0) {
                      lastSelectedGroup = this.itemsData.get(selection[0]).group;
                    }
                  }
                  if (!this.options.multiselectPerGroup || lastSelectedGroup == void 0 || lastSelectedGroup == itemGroup) {
                    selection.push(item.id);
                  }
                  var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));
                  if (!this.options.multiselectPerGroup || lastSelectedGroup == itemGroup) {
                    selection = [];
                    for (var id in this.items) {
                      if (this.items.hasOwnProperty(id)) {
                        var _item = this.items[id];
                        var start = _item.data.start;
                        var end = _item.data.end !== void 0 ? _item.data.end : start;
                        if (start >= range.min && end <= range.max && (!this.options.multiselectPerGroup || lastSelectedGroup == this.itemsData.get(_item.id).group) && !(_item instanceof BackgroundItem)) {
                          selection.push(_item.id);
                        }
                      }
                    }
                  }
                } else {
                  var index = selection.indexOf(item.id);
                  if (index == -1) {
                    selection.push(item.id);
                  } else {
                    selection.splice(index, 1);
                  }
                }
                this.setSelection(selection);
                this.body.emitter.emit("select", {
                  items: this.getSelection(),
                  event
                });
              }
            };
            ItemSet._getItemRange = function(itemsData) {
              var max = null;
              var min = null;
              itemsData.forEach(function(data) {
                if (min == null || data.start < min) {
                  min = data.start;
                }
                if (data.end != void 0) {
                  if (max == null || data.end > max) {
                    max = data.end;
                  }
                } else {
                  if (max == null || data.start > max) {
                    max = data.start;
                  }
                }
              });
              return {
                min,
                max
              };
            };
            ItemSet.prototype.itemFromElement = function(element) {
              var cur = element;
              while (cur) {
                if (cur.hasOwnProperty("timeline-item")) {
                  return cur["timeline-item"];
                }
                cur = cur.parentNode;
              }
              return null;
            };
            ItemSet.prototype.itemFromTarget = function(event) {
              return this.itemFromElement(event.target);
            };
            ItemSet.prototype.itemFromRelatedTarget = function(event) {
              return this.itemFromElement(event.relatedTarget);
            };
            ItemSet.prototype.groupFromTarget = function(event) {
              var clientY = event.center ? event.center.y : event.clientY;
              var groupIds = this.groupIds;
              if (groupIds.length <= 0 && this.groupsData) {
                groupIds = this.groupsData.getIds({
                  order: this.options.groupOrder
                });
              }
              for (var i = 0; i < groupIds.length; i++) {
                var groupId = groupIds[i];
                var group = this.groups[groupId];
                var foreground = group.dom.foreground;
                var top = util.getAbsoluteTop(foreground);
                if (clientY > top && clientY < top + foreground.offsetHeight) {
                  return group;
                }
                if (this.options.orientation.item === "top") {
                  if (i === this.groupIds.length - 1 && clientY > top) {
                    return group;
                  }
                } else {
                  if (i === 0 && clientY < top + foreground.offset) {
                    return group;
                  }
                }
              }
              return null;
            };
            ItemSet.itemSetFromTarget = function(event) {
              var target = event.target;
              while (target) {
                if (target.hasOwnProperty("timeline-itemset")) {
                  return target["timeline-itemset"];
                }
                target = target.parentNode;
              }
              return null;
            };
            ItemSet.prototype._cloneItemData = function(itemData, type) {
              var clone = util.extend({}, itemData);
              if (!type) {
                type = this.itemsData.getDataSet()._options.type;
              }
              if (clone.start != void 0) {
                clone.start = util.convert(clone.start, type && type.start || "Date");
              }
              if (clone.end != void 0) {
                clone.end = util.convert(clone.end, type && type.end || "Date");
              }
              return clone;
            };
            module2.exports = ItemSet;
          },
          /* 100 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var EPSILON = 1e-3;
            exports2.orderByStart = function(items) {
              items.sort(function(a, b) {
                return a.data.start - b.data.start;
              });
            };
            exports2.orderByEnd = function(items) {
              items.sort(function(a, b) {
                var aTime = "end" in a.data ? a.data.end : a.data.start, bTime = "end" in b.data ? b.data.end : b.data.start;
                return aTime - bTime;
              });
            };
            exports2.stack = function(items, margin, force) {
              if (force) {
                for (var i = 0; i < items.length; i++) {
                  items[i].top = null;
                }
              }
              for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.stack && item.top === null) {
                  item.top = margin.axis;
                  do {
                    var collidingItem = null;
                    for (var j = 0, jj = items.length; j < jj; j++) {
                      var other = items[j];
                      if (other.top !== null && other !== item && other.stack && exports2.collision(item, other, margin.item, other.options.rtl)) {
                        collidingItem = other;
                        break;
                      }
                    }
                    if (collidingItem != null) {
                      item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
                    }
                  } while (collidingItem);
                }
              }
            };
            exports2.substack = function(items, margin, subgroup) {
              for (var i = 0; i < items.length; i++) {
                items[i].top = null;
              }
              var subgroupHeight = subgroup.height;
              for (i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.stack && item.top === null) {
                  item.top = item.baseTop;
                  do {
                    var collidingItem = null;
                    for (var j = 0, jj = items.length; j < jj; j++) {
                      var other = items[j];
                      if (other.top !== null && other !== item && exports2.collision(item, other, margin.item, other.options.rtl)) {
                        collidingItem = other;
                        break;
                      }
                    }
                    if (collidingItem != null) {
                      item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
                    }
                    if (item.top + item.height > subgroupHeight) {
                      subgroupHeight = item.top + item.height;
                    }
                  } while (collidingItem);
                }
              }
              subgroup.height = subgroupHeight - subgroup.top + 0.5 * margin.item.vertical;
            };
            exports2.nostack = function(items, margin, subgroups, stackSubgroups) {
              for (var i = 0; i < items.length; i++) {
                if (items[i].data.subgroup == void 0) {
                  items[i].top = margin.item.vertical;
                } else if (items[i].data.subgroup !== void 0 && stackSubgroups) {
                  var newTop = 0;
                  for (var subgroup in subgroups) {
                    if (subgroups.hasOwnProperty(subgroup)) {
                      if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
                        newTop += subgroups[subgroup].height;
                        subgroups[items[i].data.subgroup].top = newTop;
                      }
                    }
                  }
                  items[i].top = newTop + 0.5 * margin.item.vertical;
                }
              }
              if (!stackSubgroups) {
                exports2.stackSubgroups(items, margin, subgroups);
              }
            };
            exports2.stackSubgroups = function(items, margin, subgroups) {
              for (var subgroup in subgroups) {
                if (subgroups.hasOwnProperty(subgroup)) {
                  subgroups[subgroup].top = 0;
                  do {
                    var collidingItem = null;
                    for (var otherSubgroup in subgroups) {
                      if (subgroups[otherSubgroup].top !== null && otherSubgroup !== subgroup && subgroups[subgroup].index > subgroups[otherSubgroup].index && exports2.collisionByTimes(subgroups[subgroup], subgroups[otherSubgroup])) {
                        collidingItem = subgroups[otherSubgroup];
                        break;
                      }
                    }
                    if (collidingItem != null) {
                      subgroups[subgroup].top = collidingItem.top + collidingItem.height;
                    }
                  } while (collidingItem);
                }
              }
              for (var i = 0; i < items.length; i++) {
                if (items[i].data.subgroup !== void 0) {
                  items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;
                }
              }
            };
            exports2.stackSubgroupsWithInnerStack = function(subgroupItems, margin, subgroups) {
              var doSubStack = false;
              var subgroupOrder = [];
              for (var subgroup in subgroups) {
                if (subgroups[subgroup].hasOwnProperty("index")) {
                  subgroupOrder[subgroups[subgroup].index] = subgroup;
                } else {
                  subgroupOrder.push(subgroup);
                }
              }
              for (var j = 0; j < subgroupOrder.length; j++) {
                subgroup = subgroupOrder[j];
                if (subgroups.hasOwnProperty(subgroup)) {
                  doSubStack = doSubStack || subgroups[subgroup].stack;
                  subgroups[subgroup].top = 0;
                  for (var otherSubgroup in subgroups) {
                    if (subgroups[otherSubgroup].visible && subgroups[subgroup].index > subgroups[otherSubgroup].index) {
                      subgroups[subgroup].top += subgroups[otherSubgroup].height;
                    }
                  }
                  var items = subgroupItems[subgroup];
                  for (var i = 0; i < items.length; i++) {
                    if (items[i].data.subgroup !== void 0) {
                      items[i].top = subgroups[items[i].data.subgroup].top + 0.5 * margin.item.vertical;
                      if (subgroups[subgroup].stack) {
                        items[i].baseTop = items[i].top;
                      }
                    }
                  }
                  if (doSubStack && subgroups[subgroup].stack) {
                    exports2.substack(subgroupItems[subgroup], margin, subgroups[subgroup]);
                  }
                }
              }
            };
            exports2.collision = function(a, b, margin, rtl) {
              if (rtl) {
                return a.right - margin.horizontal + EPSILON < b.right + b.width && a.right + a.width + margin.horizontal - EPSILON > b.right && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
              } else {
                return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
              }
            };
            exports2.collisionByTimes = function(a, b) {
              return a.start <= b.start && a.end >= b.start && a.top < b.top + b.height && a.top + a.height > b.top || b.start <= a.start && b.end >= a.start && b.top < a.top + a.height && b.top + b.height > a.top;
            };
          },
          /* 101 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Item = __webpack_require__(38);
            function BoxItem(data, conversion, options) {
              this.props = {
                dot: {
                  width: 0,
                  height: 0
                },
                line: {
                  width: 0,
                  height: 0
                }
              };
              this.options = options;
              if (data) {
                if (data.start == void 0) {
                  throw new Error('Property "start" missing in item ' + data);
                }
              }
              Item.call(this, data, conversion, options);
            }
            BoxItem.prototype = new Item(null, null, null);
            BoxItem.prototype.isVisible = function(range) {
              var isVisible;
              var align = this.options.align;
              var widthInMs = this.width * range.getMillisecondsPerPixel();
              if (align == "right") {
                isVisible = this.data.start.getTime() > range.start && this.data.start.getTime() - widthInMs < range.end;
              } else if (align == "left") {
                isVisible = this.data.start.getTime() + widthInMs > range.start && this.data.start.getTime() < range.end;
              } else {
                isVisible = this.data.start.getTime() + widthInMs / 2 > range.start && this.data.start.getTime() - widthInMs / 2 < range.end;
              }
              return isVisible;
            };
            BoxItem.prototype._createDomElement = function() {
              if (!this.dom) {
                this.dom = {};
                this.dom.box = document.createElement("DIV");
                this.dom.content = document.createElement("DIV");
                this.dom.content.className = "vis-item-content";
                this.dom.box.appendChild(this.dom.content);
                this.dom.line = document.createElement("DIV");
                this.dom.line.className = "vis-line";
                this.dom.dot = document.createElement("DIV");
                this.dom.dot.className = "vis-dot";
                this.dom.box["timeline-item"] = this;
                this.dirty = true;
              }
            };
            BoxItem.prototype._appendDomElement = function() {
              if (!this.parent) {
                throw new Error("Cannot redraw item: no parent attached");
              }
              if (!this.dom.box.parentNode) {
                var foreground = this.parent.dom.foreground;
                if (!foreground) throw new Error("Cannot redraw item: parent has no foreground container element");
                foreground.appendChild(this.dom.box);
              }
              if (!this.dom.line.parentNode) {
                var background = this.parent.dom.background;
                if (!background) throw new Error("Cannot redraw item: parent has no background container element");
                background.appendChild(this.dom.line);
              }
              if (!this.dom.dot.parentNode) {
                var axis = this.parent.dom.axis;
                if (!background) throw new Error("Cannot redraw item: parent has no axis container element");
                axis.appendChild(this.dom.dot);
              }
              this.displayed = true;
            };
            BoxItem.prototype._updateDirtyDomComponents = function() {
              if (this.dirty) {
                this._updateContents(this.dom.content);
                this._updateDataAttributes(this.dom.box);
                this._updateStyle(this.dom.box);
                var editable = this.editable.updateTime || this.editable.updateGroup;
                var className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
                this.dom.box.className = "vis-item vis-box" + className;
                this.dom.line.className = "vis-item vis-line" + className;
                this.dom.dot.className = "vis-item vis-dot" + className;
              }
            };
            BoxItem.prototype._getDomComponentsSizes = function() {
              return {
                previous: {
                  right: this.dom.box.style.right,
                  left: this.dom.box.style.left
                },
                dot: {
                  height: this.dom.dot.offsetHeight,
                  width: this.dom.dot.offsetWidth
                },
                line: {
                  width: this.dom.line.offsetWidth
                },
                box: {
                  width: this.dom.box.offsetWidth,
                  height: this.dom.box.offsetHeight
                }
              };
            };
            BoxItem.prototype._updateDomComponentsSizes = function(sizes) {
              if (this.options.rtl) {
                this.dom.box.style.right = "0px";
              } else {
                this.dom.box.style.left = "0px";
              }
              this.props.dot.height = sizes.dot.height;
              this.props.dot.width = sizes.dot.width;
              this.props.line.width = sizes.line.width;
              this.width = sizes.box.width;
              this.height = sizes.box.height;
              if (this.options.rtl) {
                this.dom.box.style.right = sizes.previous.right;
              } else {
                this.dom.box.style.left = sizes.previous.left;
              }
              this.dirty = false;
            };
            BoxItem.prototype._repaintDomAdditionals = function() {
              this._repaintOnItemUpdateTimeTooltip(this.dom.box);
              this._repaintDragCenter();
              this._repaintDeleteButton(this.dom.box);
            };
            BoxItem.prototype.redraw = function(returnQueue) {
              var sizes;
              var queue = [
                // create item DOM
                this._createDomElement.bind(this),
                // append DOM to parent DOM
                this._appendDomElement.bind(this),
                // update dirty DOM
                this._updateDirtyDomComponents.bind(this),
                (function() {
                  if (this.dirty) {
                    sizes = this._getDomComponentsSizes();
                  }
                }).bind(this),
                (function() {
                  if (this.dirty) {
                    this._updateDomComponentsSizes.bind(this)(sizes);
                  }
                }).bind(this),
                // repaint DOM additionals
                this._repaintDomAdditionals.bind(this)
              ];
              if (returnQueue) {
                return queue;
              } else {
                var result;
                queue.forEach(function(fn) {
                  result = fn();
                });
                return result;
              }
            };
            BoxItem.prototype.show = function() {
              if (!this.displayed) {
                this.redraw();
              }
            };
            BoxItem.prototype.hide = function() {
              if (this.displayed) {
                var dom = this.dom;
                if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
                if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
                if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);
                this.displayed = false;
              }
            };
            BoxItem.prototype.repositionX = function() {
              var start = this.conversion.toScreen(this.data.start);
              var align = this.options.align;
              if (align == "right") {
                if (this.options.rtl) {
                  this.right = start - this.width;
                  this.dom.box.style.right = this.right + "px";
                  this.dom.line.style.right = start - this.props.line.width + "px";
                  this.dom.dot.style.right = start - this.props.line.width / 2 - this.props.dot.width / 2 + "px";
                } else {
                  this.left = start - this.width;
                  this.dom.box.style.left = this.left + "px";
                  this.dom.line.style.left = start - this.props.line.width + "px";
                  this.dom.dot.style.left = start - this.props.line.width / 2 - this.props.dot.width / 2 + "px";
                }
              } else if (align == "left") {
                if (this.options.rtl) {
                  this.right = start;
                  this.dom.box.style.right = this.right + "px";
                  this.dom.line.style.right = start + "px";
                  this.dom.dot.style.right = start + this.props.line.width / 2 - this.props.dot.width / 2 + "px";
                } else {
                  this.left = start;
                  this.dom.box.style.left = this.left + "px";
                  this.dom.line.style.left = start + "px";
                  this.dom.dot.style.left = start + this.props.line.width / 2 - this.props.dot.width / 2 + "px";
                }
              } else {
                if (this.options.rtl) {
                  this.right = start - this.width / 2;
                  this.dom.box.style.right = this.right + "px";
                  this.dom.line.style.right = start - this.props.line.width + "px";
                  this.dom.dot.style.right = start - this.props.dot.width / 2 + "px";
                } else {
                  this.left = start - this.width / 2;
                  this.dom.box.style.left = this.left + "px";
                  this.dom.line.style.left = start - this.props.line.width / 2 + "px";
                  this.dom.dot.style.left = start - this.props.dot.width / 2 + "px";
                }
              }
            };
            BoxItem.prototype.repositionY = function() {
              var orientation = this.options.orientation.item;
              var box = this.dom.box;
              var line = this.dom.line;
              var dot = this.dom.dot;
              if (orientation == "top") {
                box.style.top = (this.top || 0) + "px";
                line.style.top = "0";
                line.style.height = this.parent.top + this.top + 1 + "px";
                line.style.bottom = "";
              } else {
                var itemSetHeight = this.parent.itemSet.props.height;
                var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;
                box.style.top = (this.parent.height - this.top - this.height || 0) + "px";
                line.style.top = itemSetHeight - lineHeight + "px";
                line.style.bottom = "0";
              }
              dot.style.top = -this.props.dot.height / 2 + "px";
            };
            BoxItem.prototype.getWidthLeft = function() {
              return this.width / 2;
            };
            BoxItem.prototype.getWidthRight = function() {
              return this.width / 2;
            };
            module2.exports = BoxItem;
          },
          /* 102 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Item = __webpack_require__(38);
            function PointItem(data, conversion, options) {
              this.props = {
                dot: {
                  top: 0,
                  width: 0,
                  height: 0
                },
                content: {
                  height: 0,
                  marginLeft: 0,
                  marginRight: 0
                }
              };
              this.options = options;
              if (data) {
                if (data.start == void 0) {
                  throw new Error('Property "start" missing in item ' + data);
                }
              }
              Item.call(this, data, conversion, options);
            }
            PointItem.prototype = new Item(null, null, null);
            PointItem.prototype.isVisible = function(range) {
              var widthInMs = this.width * range.getMillisecondsPerPixel();
              return this.data.start.getTime() + widthInMs > range.start && this.data.start < range.end;
            };
            PointItem.prototype._createDomElement = function() {
              if (!this.dom) {
                this.dom = {};
                this.dom.point = document.createElement("div");
                this.dom.content = document.createElement("div");
                this.dom.content.className = "vis-item-content";
                this.dom.point.appendChild(this.dom.content);
                this.dom.dot = document.createElement("div");
                this.dom.point.appendChild(this.dom.dot);
                this.dom.point["timeline-item"] = this;
                this.dirty = true;
              }
            };
            PointItem.prototype._appendDomElement = function() {
              if (!this.parent) {
                throw new Error("Cannot redraw item: no parent attached");
              }
              if (!this.dom.point.parentNode) {
                var foreground = this.parent.dom.foreground;
                if (!foreground) {
                  throw new Error("Cannot redraw item: parent has no foreground container element");
                }
                foreground.appendChild(this.dom.point);
              }
              this.displayed = true;
            };
            PointItem.prototype._updateDirtyDomComponents = function() {
              if (this.dirty) {
                this._updateContents(this.dom.content);
                this._updateDataAttributes(this.dom.point);
                this._updateStyle(this.dom.point);
                var editable = this.editable.updateTime || this.editable.updateGroup;
                var className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "") + (editable ? " vis-editable" : " vis-readonly");
                this.dom.point.className = "vis-item vis-point" + className;
                this.dom.dot.className = "vis-item vis-dot" + className;
              }
            };
            PointItem.prototype._getDomComponentsSizes = function() {
              return {
                dot: {
                  width: this.dom.dot.offsetWidth,
                  height: this.dom.dot.offsetHeight
                },
                content: {
                  width: this.dom.content.offsetWidth,
                  height: this.dom.content.offsetHeight
                },
                point: {
                  width: this.dom.point.offsetWidth,
                  height: this.dom.point.offsetHeight
                }
              };
            };
            PointItem.prototype._updateDomComponentsSizes = function(sizes) {
              this.props.dot.width = sizes.dot.width;
              this.props.dot.height = sizes.dot.height;
              this.props.content.height = sizes.content.height;
              if (this.options.rtl) {
                this.dom.content.style.marginRight = 2 * this.props.dot.width + "px";
              } else {
                this.dom.content.style.marginLeft = 2 * this.props.dot.width + "px";
              }
              this.width = sizes.point.width;
              this.height = sizes.point.height;
              this.dom.dot.style.top = (this.height - this.props.dot.height) / 2 + "px";
              if (this.options.rtl) {
                this.dom.dot.style.right = this.props.dot.width / 2 + "px";
              } else {
                this.dom.dot.style.left = this.props.dot.width / 2 + "px";
              }
              this.dirty = false;
            };
            PointItem.prototype._repaintDomAdditionals = function() {
              this._repaintOnItemUpdateTimeTooltip(this.dom.point);
              this._repaintDragCenter();
              this._repaintDeleteButton(this.dom.point);
            };
            PointItem.prototype.redraw = function(returnQueue) {
              var sizes;
              var queue = [
                // create item DOM
                this._createDomElement.bind(this),
                // append DOM to parent DOM
                this._appendDomElement.bind(this),
                // update dirty DOM
                this._updateDirtyDomComponents.bind(this),
                (function() {
                  if (this.dirty) {
                    sizes = this._getDomComponentsSizes();
                  }
                }).bind(this),
                (function() {
                  if (this.dirty) {
                    this._updateDomComponentsSizes.bind(this)(sizes);
                  }
                }).bind(this),
                // repaint DOM additionals
                this._repaintDomAdditionals.bind(this)
              ];
              if (returnQueue) {
                return queue;
              } else {
                var result;
                queue.forEach(function(fn) {
                  result = fn();
                });
                return result;
              }
            };
            PointItem.prototype.show = function() {
              if (!this.displayed) {
                this.redraw();
              }
            };
            PointItem.prototype.hide = function() {
              if (this.displayed) {
                if (this.dom.point.parentNode) {
                  this.dom.point.parentNode.removeChild(this.dom.point);
                }
                this.displayed = false;
              }
            };
            PointItem.prototype.repositionX = function() {
              var start = this.conversion.toScreen(this.data.start);
              if (this.options.rtl) {
                this.right = start - this.props.dot.width;
                this.dom.point.style.right = this.right + "px";
              } else {
                this.left = start - this.props.dot.width;
                this.dom.point.style.left = this.left + "px";
              }
            };
            PointItem.prototype.repositionY = function() {
              var orientation = this.options.orientation.item;
              var point = this.dom.point;
              if (orientation == "top") {
                point.style.top = this.top + "px";
              } else {
                point.style.top = this.parent.height - this.top - this.height + "px";
              }
            };
            PointItem.prototype.getWidthLeft = function() {
              return this.props.dot.width;
            };
            PointItem.prototype.getWidthRight = function() {
              return this.props.dot.width;
            };
            module2.exports = PointItem;
          },
          /* 103 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Item = __webpack_require__(38);
            var BackgroundGroup = __webpack_require__(69);
            var RangeItem = __webpack_require__(70);
            function BackgroundItem(data, conversion, options) {
              this.props = {
                content: {
                  width: 0
                }
              };
              this.overflow = false;
              if (data) {
                if (data.start == void 0) {
                  throw new Error('Property "start" missing in item ' + data.id);
                }
                if (data.end == void 0) {
                  throw new Error('Property "end" missing in item ' + data.id);
                }
              }
              Item.call(this, data, conversion, options);
            }
            BackgroundItem.prototype = new Item(null, null, null);
            BackgroundItem.prototype.baseClassName = "vis-item vis-background";
            BackgroundItem.prototype.stack = false;
            BackgroundItem.prototype.isVisible = function(range) {
              return this.data.start < range.end && this.data.end > range.start;
            };
            BackgroundItem.prototype._createDomElement = function() {
              if (!this.dom) {
                this.dom = {};
                this.dom.box = document.createElement("div");
                this.dom.frame = document.createElement("div");
                this.dom.frame.className = "vis-item-overflow";
                this.dom.box.appendChild(this.dom.frame);
                this.dom.content = document.createElement("div");
                this.dom.content.className = "vis-item-content";
                this.dom.frame.appendChild(this.dom.content);
                this.dirty = true;
              }
            };
            BackgroundItem.prototype._appendDomElement = function() {
              if (!this.parent) {
                throw new Error("Cannot redraw item: no parent attached");
              }
              if (!this.dom.box.parentNode) {
                var background = this.parent.dom.background;
                if (!background) {
                  throw new Error("Cannot redraw item: parent has no background container element");
                }
                background.appendChild(this.dom.box);
              }
              this.displayed = true;
            };
            BackgroundItem.prototype._updateDirtyDomComponents = function() {
              if (this.dirty) {
                this._updateContents(this.dom.content);
                this._updateDataAttributes(this.dom.content);
                this._updateStyle(this.dom.box);
                var className = (this.data.className ? " " + this.data.className : "") + (this.selected ? " vis-selected" : "");
                this.dom.box.className = this.baseClassName + className;
              }
            };
            BackgroundItem.prototype._getDomComponentsSizes = function() {
              this.overflow = window.getComputedStyle(this.dom.content).overflow !== "hidden";
              return {
                content: {
                  width: this.dom.content.offsetWidth
                }
              };
            };
            BackgroundItem.prototype._updateDomComponentsSizes = function(sizes) {
              this.props.content.width = sizes.content.width;
              this.height = 0;
              this.dirty = false;
            };
            BackgroundItem.prototype._repaintDomAdditionals = function() {
            };
            BackgroundItem.prototype.redraw = function(returnQueue) {
              var sizes;
              var queue = [
                // create item DOM
                this._createDomElement.bind(this),
                // append DOM to parent DOM
                this._appendDomElement.bind(this),
                this._updateDirtyDomComponents.bind(this),
                (function() {
                  if (this.dirty) {
                    sizes = this._getDomComponentsSizes.bind(this)();
                  }
                }).bind(this),
                (function() {
                  if (this.dirty) {
                    this._updateDomComponentsSizes.bind(this)(sizes);
                  }
                }).bind(this),
                // repaint DOM additionals
                this._repaintDomAdditionals.bind(this)
              ];
              if (returnQueue) {
                return queue;
              } else {
                var result;
                queue.forEach(function(fn) {
                  result = fn();
                });
                return result;
              }
            };
            BackgroundItem.prototype.show = RangeItem.prototype.show;
            BackgroundItem.prototype.hide = RangeItem.prototype.hide;
            BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;
            BackgroundItem.prototype.repositionY = function(margin) {
              var height;
              var orientation = this.options.orientation.item;
              if (this.data.subgroup !== void 0) {
                var itemSubgroup = this.data.subgroup;
                this.dom.box.style.height = this.parent.subgroups[itemSubgroup].height + "px";
                if (orientation == "top") {
                  this.dom.box.style.top = this.parent.top + this.parent.subgroups[itemSubgroup].top + "px";
                } else {
                  this.dom.box.style.top = this.parent.top + this.parent.height - this.parent.subgroups[itemSubgroup].top - this.parent.subgroups[itemSubgroup].height + "px";
                }
                this.dom.box.style.bottom = "";
              } else {
                if (this.parent instanceof BackgroundGroup) {
                  height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
                  this.dom.box.style.bottom = orientation == "bottom" ? "0" : "";
                  this.dom.box.style.top = orientation == "top" ? "0" : "";
                } else {
                  height = this.parent.height;
                  this.dom.box.style.top = this.parent.top + "px";
                  this.dom.box.style.bottom = "";
                }
              }
              this.dom.box.style.height = height + "px";
            };
            module2.exports = BackgroundItem;
          },
          /* 104 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Popup = function() {
              function Popup2(container, overflowMethod) {
                (0, _classCallCheck3["default"])(this, Popup2);
                this.container = container;
                this.overflowMethod = overflowMethod || "cap";
                this.x = 0;
                this.y = 0;
                this.padding = 5;
                this.hidden = false;
                this.frame = document.createElement("div");
                this.frame.className = "vis-tooltip";
                this.container.appendChild(this.frame);
              }
              (0, _createClass3["default"])(Popup2, [{
                key: "setPosition",
                value: function setPosition(x, y) {
                  this.x = parseInt(x);
                  this.y = parseInt(y);
                }
                /**
                 * Set the content for the popup window. This can be HTML code or text.
                 * @param {string | Element} content
                 */
              }, {
                key: "setText",
                value: function setText(content) {
                  if (content instanceof Element) {
                    this.frame.innerHTML = "";
                    this.frame.appendChild(content);
                  } else {
                    this.frame.innerHTML = content;
                  }
                }
                /**
                 * Show the popup window
                 * @param {boolean} [doShow]    Show or hide the window
                 */
              }, {
                key: "show",
                value: function show(doShow) {
                  if (doShow === void 0) {
                    doShow = true;
                  }
                  if (doShow === true) {
                    var height = this.frame.clientHeight;
                    var width = this.frame.clientWidth;
                    var maxHeight = this.frame.parentNode.clientHeight;
                    var maxWidth = this.frame.parentNode.clientWidth;
                    var left = 0, top = 0;
                    if (this.overflowMethod == "flip") {
                      var isLeft = false, isTop = true;
                      if (this.y - height < this.padding) {
                        isTop = false;
                      }
                      if (this.x + width > maxWidth - this.padding) {
                        isLeft = true;
                      }
                      if (isLeft) {
                        left = this.x - width;
                      } else {
                        left = this.x;
                      }
                      if (isTop) {
                        top = this.y - height;
                      } else {
                        top = this.y;
                      }
                    } else {
                      top = this.y - height;
                      if (top + height + this.padding > maxHeight) {
                        top = maxHeight - height - this.padding;
                      }
                      if (top < this.padding) {
                        top = this.padding;
                      }
                      left = this.x;
                      if (left + width + this.padding > maxWidth) {
                        left = maxWidth - width - this.padding;
                      }
                      if (left < this.padding) {
                        left = this.padding;
                      }
                    }
                    this.frame.style.left = left + "px";
                    this.frame.style.top = top + "px";
                    this.frame.style.visibility = "visible";
                    this.hidden = false;
                  } else {
                    this.hide();
                  }
                }
                /**
                 * Hide the popup window
                 */
              }, {
                key: "hide",
                value: function hide() {
                  this.hidden = true;
                  this.frame.style.left = "0";
                  this.frame.style.top = "0";
                  this.frame.style.visibility = "hidden";
                }
                /**
                 * Remove the popup window
                 */
              }, {
                key: "destroy",
                value: function destroy() {
                  this.frame.parentNode.removeChild(this.frame);
                }
              }]);
              return Popup2;
            }();
            exports2["default"] = Popup;
          },
          /* 105 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var string = "string";
            var bool = "boolean";
            var number = "number";
            var array = "array";
            var date = "date";
            var object = "object";
            var dom = "dom";
            var moment = "moment";
            var any = "any";
            var allOptions = {
              configure: {
                enabled: { "boolean": bool },
                filter: { "boolean": bool, "function": "function" },
                container: { dom },
                __type__: { object, "boolean": bool, "function": "function" }
              },
              //globals :
              align: { string },
              rtl: { "boolean": bool, "undefined": "undefined" },
              rollingMode: {
                follow: { "boolean": bool },
                offset: { number, "undefined": "undefined" },
                __type__: { object }
              },
              verticalScroll: { "boolean": bool, "undefined": "undefined" },
              horizontalScroll: { "boolean": bool, "undefined": "undefined" },
              autoResize: { "boolean": bool },
              throttleRedraw: { number },
              // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
              clickToUse: { "boolean": bool },
              dataAttributes: { string, array },
              editable: {
                add: { "boolean": bool, "undefined": "undefined" },
                remove: { "boolean": bool, "undefined": "undefined" },
                updateGroup: { "boolean": bool, "undefined": "undefined" },
                updateTime: { "boolean": bool, "undefined": "undefined" },
                overrideItems: { "boolean": bool, "undefined": "undefined" },
                __type__: { "boolean": bool, object }
              },
              end: { number, date, string, moment },
              format: {
                minorLabels: {
                  millisecond: { string, "undefined": "undefined" },
                  second: { string, "undefined": "undefined" },
                  minute: { string, "undefined": "undefined" },
                  hour: { string, "undefined": "undefined" },
                  weekday: { string, "undefined": "undefined" },
                  day: { string, "undefined": "undefined" },
                  week: { string, "undefined": "undefined" },
                  month: { string, "undefined": "undefined" },
                  year: { string, "undefined": "undefined" },
                  __type__: { object, "function": "function" }
                },
                majorLabels: {
                  millisecond: { string, "undefined": "undefined" },
                  second: { string, "undefined": "undefined" },
                  minute: { string, "undefined": "undefined" },
                  hour: { string, "undefined": "undefined" },
                  weekday: { string, "undefined": "undefined" },
                  day: { string, "undefined": "undefined" },
                  week: { string, "undefined": "undefined" },
                  month: { string, "undefined": "undefined" },
                  year: { string, "undefined": "undefined" },
                  __type__: { object, "function": "function" }
                },
                __type__: { object }
              },
              moment: { "function": "function" },
              groupOrder: { string, "function": "function" },
              groupEditable: {
                add: { "boolean": bool, "undefined": "undefined" },
                remove: { "boolean": bool, "undefined": "undefined" },
                order: { "boolean": bool, "undefined": "undefined" },
                __type__: { "boolean": bool, object }
              },
              groupOrderSwap: { "function": "function" },
              height: { string, number },
              hiddenDates: {
                start: { date, number, string, moment },
                end: { date, number, string, moment },
                repeat: { string },
                __type__: { object, array }
              },
              itemsAlwaysDraggable: {
                item: { "boolean": bool, "undefined": "undefined" },
                range: { "boolean": bool, "undefined": "undefined" },
                __type__: { "boolean": bool, object }
              },
              limitSize: { "boolean": bool },
              locale: { string },
              locales: {
                __any__: { any },
                __type__: { object }
              },
              margin: {
                axis: { number },
                item: {
                  horizontal: { number, "undefined": "undefined" },
                  vertical: { number, "undefined": "undefined" },
                  __type__: { object, number }
                },
                __type__: { object, number }
              },
              max: { date, number, string, moment },
              maxHeight: { number, string },
              maxMinorChars: { number },
              min: { date, number, string, moment },
              minHeight: { number, string },
              moveable: { "boolean": bool },
              multiselect: { "boolean": bool },
              multiselectPerGroup: { "boolean": bool },
              onAdd: { "function": "function" },
              onDropObjectOnItem: { "function": "function" },
              onUpdate: { "function": "function" },
              onMove: { "function": "function" },
              onMoving: { "function": "function" },
              onRemove: { "function": "function" },
              onAddGroup: { "function": "function" },
              onMoveGroup: { "function": "function" },
              onRemoveGroup: { "function": "function" },
              onInitialDrawComplete: { "function": "function" },
              order: { "function": "function" },
              orientation: {
                axis: { string, "undefined": "undefined" },
                item: { string, "undefined": "undefined" },
                __type__: { string, object }
              },
              selectable: { "boolean": bool },
              showCurrentTime: { "boolean": bool },
              showMajorLabels: { "boolean": bool },
              showMinorLabels: { "boolean": bool },
              stack: { "boolean": bool },
              stackSubgroups: { "boolean": bool },
              snap: { "function": "function", "null": "null" },
              start: { date, number, string, moment },
              template: { "function": "function" },
              groupTemplate: { "function": "function" },
              visibleFrameTemplate: { string, "function": "function" },
              showTooltips: { "boolean": bool },
              tooltip: {
                followMouse: { "boolean": bool },
                overflowMethod: { "string": ["cap", "flip"] },
                __type__: { object }
              },
              tooltipOnItemUpdateTime: {
                template: { "function": "function" },
                __type__: { "boolean": bool, object }
              },
              timeAxis: {
                scale: { string, "undefined": "undefined" },
                step: { number, "undefined": "undefined" },
                __type__: { object }
              },
              type: { string },
              width: { string, number },
              zoomable: { "boolean": bool },
              zoomKey: { string: ["ctrlKey", "altKey", "metaKey", ""] },
              zoomMax: { number },
              zoomMin: { number },
              __type__: { object }
            };
            var configureOptions = {
              global: {
                align: ["center", "left", "right"],
                direction: false,
                autoResize: true,
                clickToUse: false,
                // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
                editable: {
                  add: false,
                  remove: false,
                  updateGroup: false,
                  updateTime: false
                },
                end: "",
                format: {
                  minorLabels: {
                    millisecond: "SSS",
                    second: "s",
                    minute: "HH:mm",
                    hour: "HH:mm",
                    weekday: "ddd D",
                    day: "D",
                    week: "w",
                    month: "MMM",
                    year: "YYYY"
                  },
                  majorLabels: {
                    millisecond: "HH:mm:ss",
                    second: "D MMMM HH:mm",
                    minute: "ddd D MMMM",
                    hour: "ddd D MMMM",
                    weekday: "MMMM YYYY",
                    day: "MMMM YYYY",
                    week: "MMMM YYYY",
                    month: "YYYY",
                    year: ""
                  }
                },
                //groupOrder: {string, 'function': 'function'},
                groupsDraggable: false,
                height: "",
                //hiddenDates: {object, array},
                locale: "",
                margin: {
                  axis: [20, 0, 100, 1],
                  item: {
                    horizontal: [10, 0, 100, 1],
                    vertical: [10, 0, 100, 1]
                  }
                },
                max: "",
                maxHeight: "",
                maxMinorChars: [7, 0, 20, 1],
                min: "",
                minHeight: "",
                moveable: false,
                multiselect: false,
                multiselectPerGroup: false,
                //onAdd: {'function': 'function'},
                //onUpdate: {'function': 'function'},
                //onMove: {'function': 'function'},
                //onMoving: {'function': 'function'},
                //onRename: {'function': 'function'},
                //order: {'function': 'function'},
                orientation: {
                  axis: ["both", "bottom", "top"],
                  item: ["bottom", "top"]
                },
                selectable: true,
                showCurrentTime: false,
                showMajorLabels: true,
                showMinorLabels: true,
                stack: true,
                stackSubgroups: true,
                //snap: {'function': 'function', nada},
                start: "",
                //template: {'function': 'function'},
                //timeAxis: {
                //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'week', 'month', 'year'],
                //  step: [1, 1, 10, 1]
                //},
                showTooltips: true,
                tooltip: {
                  followMouse: false,
                  overflowMethod: "flip"
                },
                tooltipOnItemUpdateTime: false,
                type: ["box", "point", "range", "background"],
                width: "100%",
                zoomable: true,
                zoomKey: ["ctrlKey", "altKey", "metaKey", ""],
                zoomMax: [31536e10, 10, 31536e10, 1],
                zoomMin: [10, 10, 31536e10, 1]
              }
            };
            exports2.allOptions = allOptions;
            exports2.configureOptions = configureOptions;
          },
          /* 106 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DOMutil = __webpack_require__(14);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Component = __webpack_require__(16);
            var DataAxis = __webpack_require__(107);
            var GraphGroup = __webpack_require__(109);
            var Legend = __webpack_require__(112);
            var Bars = __webpack_require__(110);
            var Lines = __webpack_require__(111);
            var Points = __webpack_require__(72);
            var UNGROUPED = "__ungrouped__";
            function LineGraph(body, options) {
              this.id = util.randomUUID();
              this.body = body;
              this.defaultOptions = {
                yAxisOrientation: "left",
                defaultGroup: "default",
                sort: true,
                sampling: true,
                stack: false,
                graphHeight: "400px",
                shaded: {
                  enabled: false,
                  orientation: "bottom"
                  // top, bottom, zero
                },
                style: "line",
                // line, bar
                barChart: {
                  width: 50,
                  sideBySide: false,
                  align: "center"
                  // left, center, right
                },
                interpolation: {
                  enabled: true,
                  parametrization: "centripetal",
                  // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
                  alpha: 0.5
                },
                drawPoints: {
                  enabled: true,
                  size: 6,
                  style: "square"
                  // square, circle
                },
                dataAxis: {},
                //Defaults are done on DataAxis level
                legend: {},
                //Defaults are done on Legend level
                groups: {
                  visibility: {}
                }
              };
              this.options = util.extend({}, this.defaultOptions);
              this.dom = {};
              this.props = {};
              this.hammer = null;
              this.groups = {};
              this.abortedGraphUpdate = false;
              this.updateSVGheight = false;
              this.updateSVGheightOnResize = false;
              this.forceGraphUpdate = true;
              var me = this;
              this.itemsData = null;
              this.groupsData = null;
              this.itemListeners = {
                "add": function add(event, params, senderId) {
                  me._onAdd(params.items);
                },
                "update": function update(event, params, senderId) {
                  me._onUpdate(params.items);
                },
                "remove": function remove(event, params, senderId) {
                  me._onRemove(params.items);
                }
              };
              this.groupListeners = {
                "add": function add(event, params, senderId) {
                  me._onAddGroups(params.items);
                },
                "update": function update(event, params, senderId) {
                  me._onUpdateGroups(params.items);
                },
                "remove": function remove(event, params, senderId) {
                  me._onRemoveGroups(params.items);
                }
              };
              this.items = {};
              this.selection = [];
              this.lastStart = this.body.range.start;
              this.touchParams = {};
              this.svgElements = {};
              this.setOptions(options);
              this.groupsUsingDefaultStyles = [0];
              this.body.emitter.on("rangechanged", function() {
                me.lastStart = me.body.range.start;
                me.svg.style.left = util.option.asSize(-me.props.width);
                me.forceGraphUpdate = true;
                me.redraw.call(me);
              });
              this._create();
              this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
            }
            LineGraph.prototype = new Component();
            LineGraph.prototype._create = function() {
              var frame = document.createElement("div");
              frame.className = "vis-line-graph";
              this.dom.frame = frame;
              this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              this.svg.style.position = "relative";
              this.svg.style.height = ("" + this.options.graphHeight).replace("px", "") + "px";
              this.svg.style.display = "block";
              frame.appendChild(this.svg);
              this.options.dataAxis.orientation = "left";
              this.yAxisLeft = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
              this.options.dataAxis.orientation = "right";
              this.yAxisRight = new DataAxis(this.body, this.options.dataAxis, this.svg, this.options.groups);
              delete this.options.dataAxis.orientation;
              this.legendLeft = new Legend(this.body, this.options.legend, "left", this.options.groups);
              this.legendRight = new Legend(this.body, this.options.legend, "right", this.options.groups);
              this.show();
            };
            LineGraph.prototype.setOptions = function(options) {
              if (options) {
                var fields = ["sampling", "defaultGroup", "stack", "height", "graphHeight", "yAxisOrientation", "style", "barChart", "dataAxis", "sort", "groups"];
                if (options.graphHeight === void 0 && options.height !== void 0) {
                  this.updateSVGheight = true;
                  this.updateSVGheightOnResize = true;
                } else if (this.body.domProps.centerContainer.height !== void 0 && options.graphHeight !== void 0) {
                  if (parseInt((options.graphHeight + "").replace("px", "")) < this.body.domProps.centerContainer.height) {
                    this.updateSVGheight = true;
                  }
                }
                util.selectiveDeepExtend(fields, this.options, options);
                util.mergeOptions(this.options, options, "interpolation");
                util.mergeOptions(this.options, options, "drawPoints");
                util.mergeOptions(this.options, options, "shaded");
                util.mergeOptions(this.options, options, "legend");
                if (options.interpolation) {
                  if ((0, _typeof3["default"])(options.interpolation) == "object") {
                    if (options.interpolation.parametrization) {
                      if (options.interpolation.parametrization == "uniform") {
                        this.options.interpolation.alpha = 0;
                      } else if (options.interpolation.parametrization == "chordal") {
                        this.options.interpolation.alpha = 1;
                      } else {
                        this.options.interpolation.parametrization = "centripetal";
                        this.options.interpolation.alpha = 0.5;
                      }
                    }
                  }
                }
                if (this.yAxisLeft) {
                  if (options.dataAxis !== void 0) {
                    this.yAxisLeft.setOptions(this.options.dataAxis);
                    this.yAxisRight.setOptions(this.options.dataAxis);
                  }
                }
                if (this.legendLeft) {
                  if (options.legend !== void 0) {
                    this.legendLeft.setOptions(this.options.legend);
                    this.legendRight.setOptions(this.options.legend);
                  }
                }
                if (this.groups.hasOwnProperty(UNGROUPED)) {
                  this.groups[UNGROUPED].setOptions(options);
                }
              }
              if (this.dom.frame) {
                this.forceGraphUpdate = true;
                this.body.emitter.emit("_change", { queue: true });
              }
            };
            LineGraph.prototype.hide = function() {
              if (this.dom.frame.parentNode) {
                this.dom.frame.parentNode.removeChild(this.dom.frame);
              }
            };
            LineGraph.prototype.show = function() {
              if (!this.dom.frame.parentNode) {
                this.body.dom.center.appendChild(this.dom.frame);
              }
            };
            LineGraph.prototype.setItems = function(items) {
              var me = this, ids, oldItemsData = this.itemsData;
              if (!items) {
                this.itemsData = null;
              } else if (items instanceof DataSet || items instanceof DataView) {
                this.itemsData = items;
              } else {
                throw new TypeError("Data must be an instance of DataSet or DataView");
              }
              if (oldItemsData) {
                util.forEach(this.itemListeners, function(callback, event) {
                  oldItemsData.off(event, callback);
                });
                ids = oldItemsData.getIds();
                this._onRemove(ids);
              }
              if (this.itemsData) {
                var id = this.id;
                util.forEach(this.itemListeners, function(callback, event) {
                  me.itemsData.on(event, callback, id);
                });
                ids = this.itemsData.getIds();
                this._onAdd(ids);
              }
            };
            LineGraph.prototype.setGroups = function(groups) {
              var me = this;
              var ids;
              if (this.groupsData) {
                util.forEach(this.groupListeners, function(callback, event) {
                  me.groupsData.off(event, callback);
                });
                ids = this.groupsData.getIds();
                this.groupsData = null;
                for (var i = 0; i < ids.length; i++) {
                  this._removeGroup(ids[i]);
                }
              }
              if (!groups) {
                this.groupsData = null;
              } else if (groups instanceof DataSet || groups instanceof DataView) {
                this.groupsData = groups;
              } else {
                throw new TypeError("Data must be an instance of DataSet or DataView");
              }
              if (this.groupsData) {
                var id = this.id;
                util.forEach(this.groupListeners, function(callback, event) {
                  me.groupsData.on(event, callback, id);
                });
                ids = this.groupsData.getIds();
                this._onAddGroups(ids);
              }
            };
            LineGraph.prototype._onUpdate = function(ids) {
              this._updateAllGroupData(ids);
            };
            LineGraph.prototype._onAdd = function(ids) {
              this._onUpdate(ids);
            };
            LineGraph.prototype._onRemove = function(ids) {
              this._onUpdate(ids);
            };
            LineGraph.prototype._onUpdateGroups = function(groupIds) {
              this._updateAllGroupData(null, groupIds);
            };
            LineGraph.prototype._onAddGroups = function(groupIds) {
              this._onUpdateGroups(groupIds);
            };
            LineGraph.prototype._onRemoveGroups = function(groupIds) {
              for (var i = 0; i < groupIds.length; i++) {
                this._removeGroup(groupIds[i]);
              }
              this.forceGraphUpdate = true;
              this.body.emitter.emit("_change", { queue: true });
            };
            LineGraph.prototype._removeGroup = function(groupId) {
              if (this.groups.hasOwnProperty(groupId)) {
                if (this.groups[groupId].options.yAxisOrientation == "right") {
                  this.yAxisRight.removeGroup(groupId);
                  this.legendRight.removeGroup(groupId);
                  this.legendRight.redraw();
                } else {
                  this.yAxisLeft.removeGroup(groupId);
                  this.legendLeft.removeGroup(groupId);
                  this.legendLeft.redraw();
                }
                delete this.groups[groupId];
              }
            };
            LineGraph.prototype._updateGroup = function(group, groupId) {
              if (!this.groups.hasOwnProperty(groupId)) {
                this.groups[groupId] = new GraphGroup(group, groupId, this.options, this.groupsUsingDefaultStyles);
                if (this.groups[groupId].options.yAxisOrientation == "right") {
                  this.yAxisRight.addGroup(groupId, this.groups[groupId]);
                  this.legendRight.addGroup(groupId, this.groups[groupId]);
                } else {
                  this.yAxisLeft.addGroup(groupId, this.groups[groupId]);
                  this.legendLeft.addGroup(groupId, this.groups[groupId]);
                }
              } else {
                this.groups[groupId].update(group);
                if (this.groups[groupId].options.yAxisOrientation == "right") {
                  this.yAxisRight.updateGroup(groupId, this.groups[groupId]);
                  this.legendRight.updateGroup(groupId, this.groups[groupId]);
                  this.yAxisLeft.removeGroup(groupId);
                  this.legendLeft.removeGroup(groupId);
                } else {
                  this.yAxisLeft.updateGroup(groupId, this.groups[groupId]);
                  this.legendLeft.updateGroup(groupId, this.groups[groupId]);
                  this.yAxisRight.removeGroup(groupId);
                  this.legendRight.removeGroup(groupId);
                }
              }
              this.legendLeft.redraw();
              this.legendRight.redraw();
            };
            LineGraph.prototype._updateAllGroupData = function(ids, groupIds) {
              if (this.itemsData != null) {
                var groupsContent = {};
                var items = this.itemsData.get();
                var fieldId = this.itemsData._fieldId;
                var idMap = {};
                if (ids) {
                  ids.map(function(id) {
                    idMap[id] = id;
                  });
                }
                var groupCounts = {};
                for (var i = 0; i < items.length; i++) {
                  var item = items[i];
                  var groupId = item.group;
                  if (groupId === null || groupId === void 0) {
                    groupId = UNGROUPED;
                  }
                  groupCounts.hasOwnProperty(groupId) ? groupCounts[groupId]++ : groupCounts[groupId] = 1;
                }
                var existingItemsMap = {};
                if (!groupIds && ids) {
                  for (groupId in this.groups) {
                    if (this.groups.hasOwnProperty(groupId)) {
                      group = this.groups[groupId];
                      var existing_items = group.getItems();
                      groupsContent[groupId] = existing_items.filter(function(item2) {
                        existingItemsMap[item2[fieldId]] = item2[fieldId];
                        return item2[fieldId] !== idMap[item2[fieldId]];
                      });
                      var newLength = groupCounts[groupId];
                      groupCounts[groupId] -= groupsContent[groupId].length;
                      if (groupsContent[groupId].length < newLength) {
                        groupsContent[groupId][newLength - 1] = {};
                      }
                    }
                  }
                }
                for (i = 0; i < items.length; i++) {
                  item = items[i];
                  groupId = item.group;
                  if (groupId === null || groupId === void 0) {
                    groupId = UNGROUPED;
                  }
                  if (!groupIds && ids && item[fieldId] !== idMap[item[fieldId]] && existingItemsMap.hasOwnProperty(item[fieldId])) {
                    continue;
                  }
                  if (!groupsContent.hasOwnProperty(groupId)) {
                    groupsContent[groupId] = new Array(groupCounts[groupId]);
                  }
                  var extended = util.bridgeObject(item);
                  extended.x = util.convert(item.x, "Date");
                  extended.end = util.convert(item.end, "Date");
                  extended.orginalY = item.y;
                  extended.y = Number(item.y);
                  extended[fieldId] = item[fieldId];
                  var index = groupsContent[groupId].length - groupCounts[groupId]--;
                  groupsContent[groupId][index] = extended;
                }
                for (groupId in this.groups) {
                  if (this.groups.hasOwnProperty(groupId)) {
                    if (!groupsContent.hasOwnProperty(groupId)) {
                      groupsContent[groupId] = new Array(0);
                    }
                  }
                }
                for (groupId in groupsContent) {
                  if (groupsContent.hasOwnProperty(groupId)) {
                    if (groupsContent[groupId].length == 0) {
                      if (this.groups.hasOwnProperty(groupId)) {
                        this._removeGroup(groupId);
                      }
                    } else {
                      var group = void 0;
                      if (this.groupsData != void 0) {
                        group = this.groupsData.get(groupId);
                      }
                      if (group == void 0) {
                        group = { id: groupId, content: this.options.defaultGroup + groupId };
                      }
                      this._updateGroup(group, groupId);
                      this.groups[groupId].setItems(groupsContent[groupId]);
                    }
                  }
                }
                this.forceGraphUpdate = true;
                this.body.emitter.emit("_change", { queue: true });
              }
            };
            LineGraph.prototype.redraw = function() {
              var resized = false;
              this.props.width = this.dom.frame.offsetWidth;
              this.props.height = this.body.domProps.centerContainer.height - this.body.domProps.border.top - this.body.domProps.border.bottom;
              resized = this._isResized() || resized;
              var visibleInterval = this.body.range.end - this.body.range.start;
              var zoomed = visibleInterval != this.lastVisibleInterval;
              this.lastVisibleInterval = visibleInterval;
              if (resized == true) {
                this.svg.style.width = util.option.asSize(3 * this.props.width);
                this.svg.style.left = util.option.asSize(-this.props.width);
                if ((this.options.height + "").indexOf("%") != -1 || this.updateSVGheightOnResize == true) {
                  this.updateSVGheight = true;
                }
              }
              if (this.updateSVGheight == true) {
                if (this.options.graphHeight != this.props.height + "px") {
                  this.options.graphHeight = this.props.height + "px";
                  this.svg.style.height = this.props.height + "px";
                }
                this.updateSVGheight = false;
              } else {
                this.svg.style.height = ("" + this.options.graphHeight).replace("px", "") + "px";
              }
              if (resized == true || zoomed == true || this.abortedGraphUpdate == true || this.forceGraphUpdate == true) {
                resized = this._updateGraph() || resized;
                this.forceGraphUpdate = false;
              } else {
                if (this.lastStart != 0) {
                  var offset = this.body.range.start - this.lastStart;
                  var range = this.body.range.end - this.body.range.start;
                  if (this.props.width != 0) {
                    var rangePerPixelInv = this.props.width / range;
                    var xOffset = offset * rangePerPixelInv;
                    this.svg.style.left = -this.props.width - xOffset + "px";
                  }
                }
              }
              this.legendLeft.redraw();
              this.legendRight.redraw();
              return resized;
            };
            LineGraph.prototype._getSortedGroupIds = function() {
              var grouplist = [];
              for (var groupId in this.groups) {
                if (this.groups.hasOwnProperty(groupId)) {
                  var group = this.groups[groupId];
                  if (group.visible == true && (this.options.groups.visibility[groupId] === void 0 || this.options.groups.visibility[groupId] == true)) {
                    grouplist.push({ id: groupId, zIndex: group.options.zIndex });
                  }
                }
              }
              util.insertSort(grouplist, function(a, b) {
                var az = a.zIndex;
                var bz = b.zIndex;
                if (az === void 0) az = 0;
                if (bz === void 0) bz = 0;
                return az == bz ? 0 : az < bz ? -1 : 1;
              });
              var groupIds = new Array(grouplist.length);
              for (var i = 0; i < grouplist.length; i++) {
                groupIds[i] = grouplist[i].id;
              }
              return groupIds;
            };
            LineGraph.prototype._updateGraph = function() {
              DOMutil.prepareElements(this.svgElements);
              if (this.props.width != 0 && this.itemsData != null) {
                var group, i;
                var groupRanges = {};
                var changeCalled = false;
                var minDate = this.body.util.toGlobalTime(-this.body.domProps.root.width);
                var maxDate = this.body.util.toGlobalTime(2 * this.body.domProps.root.width);
                var groupIds = this._getSortedGroupIds();
                if (groupIds.length > 0) {
                  var groupsData = {};
                  this._getRelevantData(groupIds, groupsData, minDate, maxDate);
                  this._applySampling(groupIds, groupsData);
                  for (i = 0; i < groupIds.length; i++) {
                    this._convertXcoordinates(groupsData[groupIds[i]]);
                  }
                  this._getYRanges(groupIds, groupsData, groupRanges);
                  changeCalled = this._updateYAxis(groupIds, groupRanges);
                  if (changeCalled == true) {
                    DOMutil.cleanupElements(this.svgElements);
                    this.abortedGraphUpdate = true;
                    return true;
                  }
                  this.abortedGraphUpdate = false;
                  var below = void 0;
                  for (i = 0; i < groupIds.length; i++) {
                    group = this.groups[groupIds[i]];
                    if (this.options.stack === true && this.options.style === "line") {
                      if (group.options.excludeFromStacking == void 0 || !group.options.excludeFromStacking) {
                        if (below != void 0) {
                          this._stack(groupsData[group.id], groupsData[below.id]);
                          if (group.options.shaded.enabled == true && group.options.shaded.orientation !== "group") {
                            if (group.options.shaded.orientation == "top" && below.options.shaded.orientation !== "group") {
                              below.options.shaded.orientation = "group";
                              below.options.shaded.groupId = group.id;
                            } else {
                              group.options.shaded.orientation = "group";
                              group.options.shaded.groupId = below.id;
                            }
                          }
                        }
                        below = group;
                      }
                    }
                    this._convertYcoordinates(groupsData[groupIds[i]], group);
                  }
                  var paths = {};
                  for (i = 0; i < groupIds.length; i++) {
                    group = this.groups[groupIds[i]];
                    if (group.options.style === "line" && group.options.shaded.enabled == true) {
                      var dataset = groupsData[groupIds[i]];
                      if (dataset == null || dataset.length == 0) {
                        continue;
                      }
                      if (!paths.hasOwnProperty(groupIds[i])) {
                        paths[groupIds[i]] = Lines.calcPath(dataset, group);
                      }
                      if (group.options.shaded.orientation === "group") {
                        var subGroupId = group.options.shaded.groupId;
                        if (groupIds.indexOf(subGroupId) === -1) {
                          console.log(group.id + ": Unknown shading group target given:" + subGroupId);
                          continue;
                        }
                        if (!paths.hasOwnProperty(subGroupId)) {
                          paths[subGroupId] = Lines.calcPath(groupsData[subGroupId], this.groups[subGroupId]);
                        }
                        Lines.drawShading(paths[groupIds[i]], group, paths[subGroupId], this.framework);
                      } else {
                        Lines.drawShading(paths[groupIds[i]], group, void 0, this.framework);
                      }
                    }
                  }
                  Bars.draw(groupIds, groupsData, this.framework);
                  for (i = 0; i < groupIds.length; i++) {
                    group = this.groups[groupIds[i]];
                    if (groupsData[groupIds[i]].length > 0) {
                      switch (group.options.style) {
                        case "line":
                          if (!paths.hasOwnProperty(groupIds[i])) {
                            paths[groupIds[i]] = Lines.calcPath(groupsData[groupIds[i]], group);
                          }
                          Lines.draw(paths[groupIds[i]], group, this.framework);
                        // eslint-disable-line no-fallthrough
                        case "point":
                        // eslint-disable-line no-fallthrough
                        case "points":
                          if (group.options.style == "point" || group.options.style == "points" || group.options.drawPoints.enabled == true) {
                            Points.draw(groupsData[groupIds[i]], group, this.framework);
                          }
                          break;
                        case "bar":
                        // bar needs to be drawn enmasse
                        // eslint-disable-line no-fallthrough
                        default:
                      }
                    }
                  }
                }
              }
              DOMutil.cleanupElements(this.svgElements);
              return false;
            };
            LineGraph.prototype._stack = function(data, subData) {
              var index, dx, dy, subPrevPoint, subNextPoint;
              index = 0;
              for (var j = 0; j < data.length; j++) {
                subPrevPoint = void 0;
                subNextPoint = void 0;
                for (var k = index; k < subData.length; k++) {
                  if (subData[k].x === data[j].x) {
                    subPrevPoint = subData[k];
                    subNextPoint = subData[k];
                    index = k;
                    break;
                  } else if (subData[k].x > data[j].x) {
                    subNextPoint = subData[k];
                    if (k == 0) {
                      subPrevPoint = subNextPoint;
                    } else {
                      subPrevPoint = subData[k - 1];
                    }
                    index = k;
                    break;
                  }
                }
                if (subNextPoint === void 0) {
                  subPrevPoint = subData[subData.length - 1];
                  subNextPoint = subData[subData.length - 1];
                }
                dx = subNextPoint.x - subPrevPoint.x;
                dy = subNextPoint.y - subPrevPoint.y;
                if (dx == 0) {
                  data[j].y = data[j].orginalY + subNextPoint.y;
                } else {
                  data[j].y = data[j].orginalY + dy / dx * (data[j].x - subPrevPoint.x) + subPrevPoint.y;
                }
              }
            };
            LineGraph.prototype._getRelevantData = function(groupIds, groupsData, minDate, maxDate) {
              var group, i, j, item;
              if (groupIds.length > 0) {
                for (i = 0; i < groupIds.length; i++) {
                  group = this.groups[groupIds[i]];
                  var itemsData = group.getItems();
                  if (group.options.sort == true) {
                    var dateComparator = function dateComparator2(a, b) {
                      return a.getTime() == b.getTime() ? 0 : a < b ? -1 : 1;
                    };
                    var first = Math.max(0, util.binarySearchValue(itemsData, minDate, "x", "before", dateComparator));
                    var last = Math.min(itemsData.length, util.binarySearchValue(itemsData, maxDate, "x", "after", dateComparator) + 1);
                    if (last <= 0) {
                      last = itemsData.length;
                    }
                    var dataContainer = new Array(last - first);
                    for (j = first; j < last; j++) {
                      item = group.itemsData[j];
                      dataContainer[j - first] = item;
                    }
                    groupsData[groupIds[i]] = dataContainer;
                  } else {
                    groupsData[groupIds[i]] = group.itemsData;
                  }
                }
              }
            };
            LineGraph.prototype._applySampling = function(groupIds, groupsData) {
              var group;
              if (groupIds.length > 0) {
                for (var i = 0; i < groupIds.length; i++) {
                  group = this.groups[groupIds[i]];
                  if (group.options.sampling == true) {
                    var dataContainer = groupsData[groupIds[i]];
                    if (dataContainer.length > 0) {
                      var increment = 1;
                      var amountOfPoints = dataContainer.length;
                      var xDistance = this.body.util.toGlobalScreen(dataContainer[dataContainer.length - 1].x) - this.body.util.toGlobalScreen(dataContainer[0].x);
                      var pointsPerPixel = amountOfPoints / xDistance;
                      increment = Math.min(Math.ceil(0.2 * amountOfPoints), Math.max(1, Math.round(pointsPerPixel)));
                      var sampledData = new Array(amountOfPoints);
                      for (var j = 0; j < amountOfPoints; j += increment) {
                        var idx = Math.round(j / increment);
                        sampledData[idx] = dataContainer[j];
                      }
                      groupsData[groupIds[i]] = sampledData.splice(0, Math.round(amountOfPoints / increment));
                    }
                  }
                }
              }
            };
            LineGraph.prototype._getYRanges = function(groupIds, groupsData, groupRanges) {
              var groupData, group, i;
              var combinedDataLeft = [];
              var combinedDataRight = [];
              var options;
              if (groupIds.length > 0) {
                for (i = 0; i < groupIds.length; i++) {
                  groupData = groupsData[groupIds[i]];
                  options = this.groups[groupIds[i]].options;
                  if (groupData.length > 0) {
                    group = this.groups[groupIds[i]];
                    if (options.stack === true && options.style === "bar") {
                      if (options.yAxisOrientation === "left") {
                        combinedDataLeft = combinedDataLeft.concat(groupData);
                      } else {
                        combinedDataRight = combinedDataRight.concat(groupData);
                      }
                    } else {
                      groupRanges[groupIds[i]] = group.getYRange(groupData, groupIds[i]);
                    }
                  }
                }
                Bars.getStackedYRange(combinedDataLeft, groupRanges, groupIds, "__barStackLeft", "left");
                Bars.getStackedYRange(combinedDataRight, groupRanges, groupIds, "__barStackRight", "right");
              }
            };
            LineGraph.prototype._updateYAxis = function(groupIds, groupRanges) {
              var resized = false;
              var yAxisLeftUsed = false;
              var yAxisRightUsed = false;
              var minLeft = 1e9, minRight = 1e9, maxLeft = -1e9, maxRight = -1e9, minVal, maxVal;
              if (groupIds.length > 0) {
                for (var i = 0; i < groupIds.length; i++) {
                  var group = this.groups[groupIds[i]];
                  if (group && group.options.yAxisOrientation != "right") {
                    yAxisLeftUsed = true;
                    minLeft = 1e9;
                    maxLeft = -1e9;
                  } else if (group && group.options.yAxisOrientation) {
                    yAxisRightUsed = true;
                    minRight = 1e9;
                    maxRight = -1e9;
                  }
                }
                for (i = 0; i < groupIds.length; i++) {
                  if (groupRanges.hasOwnProperty(groupIds[i])) {
                    if (groupRanges[groupIds[i]].ignore !== true) {
                      minVal = groupRanges[groupIds[i]].min;
                      maxVal = groupRanges[groupIds[i]].max;
                      if (groupRanges[groupIds[i]].yAxisOrientation != "right") {
                        yAxisLeftUsed = true;
                        minLeft = minLeft > minVal ? minVal : minLeft;
                        maxLeft = maxLeft < maxVal ? maxVal : maxLeft;
                      } else {
                        yAxisRightUsed = true;
                        minRight = minRight > minVal ? minVal : minRight;
                        maxRight = maxRight < maxVal ? maxVal : maxRight;
                      }
                    }
                  }
                }
                if (yAxisLeftUsed == true) {
                  this.yAxisLeft.setRange(minLeft, maxLeft);
                }
                if (yAxisRightUsed == true) {
                  this.yAxisRight.setRange(minRight, maxRight);
                }
              }
              resized = this._toggleAxisVisiblity(yAxisLeftUsed, this.yAxisLeft) || resized;
              resized = this._toggleAxisVisiblity(yAxisRightUsed, this.yAxisRight) || resized;
              if (yAxisRightUsed == true && yAxisLeftUsed == true) {
                this.yAxisLeft.drawIcons = true;
                this.yAxisRight.drawIcons = true;
              } else {
                this.yAxisLeft.drawIcons = false;
                this.yAxisRight.drawIcons = false;
              }
              this.yAxisRight.master = !yAxisLeftUsed;
              this.yAxisRight.masterAxis = this.yAxisLeft;
              if (this.yAxisRight.master == false) {
                if (yAxisRightUsed == true) {
                  this.yAxisLeft.lineOffset = this.yAxisRight.width;
                } else {
                  this.yAxisLeft.lineOffset = 0;
                }
                resized = this.yAxisLeft.redraw() || resized;
                resized = this.yAxisRight.redraw() || resized;
              } else {
                resized = this.yAxisRight.redraw() || resized;
              }
              var tempGroups = ["__barStackLeft", "__barStackRight", "__lineStackLeft", "__lineStackRight"];
              for (i = 0; i < tempGroups.length; i++) {
                if (groupIds.indexOf(tempGroups[i]) != -1) {
                  groupIds.splice(groupIds.indexOf(tempGroups[i]), 1);
                }
              }
              return resized;
            };
            LineGraph.prototype._toggleAxisVisiblity = function(axisUsed, axis) {
              var changed = false;
              if (axisUsed == false) {
                if (axis.dom.frame.parentNode && axis.hidden == false) {
                  axis.hide();
                  changed = true;
                }
              } else {
                if (!axis.dom.frame.parentNode && axis.hidden == true) {
                  axis.show();
                  changed = true;
                }
              }
              return changed;
            };
            LineGraph.prototype._convertXcoordinates = function(datapoints) {
              var toScreen = this.body.util.toScreen;
              for (var i = 0; i < datapoints.length; i++) {
                datapoints[i].screen_x = toScreen(datapoints[i].x) + this.props.width;
                datapoints[i].screen_y = datapoints[i].y;
                if (datapoints[i].end != void 0) {
                  datapoints[i].screen_end = toScreen(datapoints[i].end) + this.props.width;
                } else {
                  datapoints[i].screen_end = void 0;
                }
              }
            };
            LineGraph.prototype._convertYcoordinates = function(datapoints, group) {
              var axis = this.yAxisLeft;
              var svgHeight = Number(this.svg.style.height.replace("px", ""));
              if (group.options.yAxisOrientation == "right") {
                axis = this.yAxisRight;
              }
              for (var i = 0; i < datapoints.length; i++) {
                datapoints[i].screen_y = Math.round(axis.convertValue(datapoints[i].y));
              }
              group.setZeroPosition(Math.min(svgHeight, axis.convertValue(0)));
            };
            module2.exports = LineGraph;
          },
          /* 107 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DOMutil = __webpack_require__(14);
            var Component = __webpack_require__(16);
            var DataScale = __webpack_require__(108);
            function DataAxis(body, options, svg, linegraphOptions) {
              this.id = util.randomUUID();
              this.body = body;
              this.defaultOptions = {
                orientation: "left",
                // supported: 'left', 'right'
                showMinorLabels: true,
                showMajorLabels: true,
                icons: false,
                majorLinesOffset: 7,
                minorLinesOffset: 4,
                labelOffsetX: 10,
                labelOffsetY: 2,
                iconWidth: 20,
                width: "40px",
                visible: true,
                alignZeros: true,
                left: {
                  range: { min: void 0, max: void 0 },
                  format: function format(value) {
                    return "" + parseFloat(value.toPrecision(3));
                  },
                  title: { text: void 0, style: void 0 }
                },
                right: {
                  range: { min: void 0, max: void 0 },
                  format: function format(value) {
                    return "" + parseFloat(value.toPrecision(3));
                  },
                  title: { text: void 0, style: void 0 }
                }
              };
              this.linegraphOptions = linegraphOptions;
              this.linegraphSVG = svg;
              this.props = {};
              this.DOMelements = {
                // dynamic elements
                lines: {},
                labels: {},
                title: {}
              };
              this.dom = {};
              this.scale = void 0;
              this.range = { start: 0, end: 0 };
              this.options = util.extend({}, this.defaultOptions);
              this.conversionFactor = 1;
              this.setOptions(options);
              this.width = Number(("" + this.options.width).replace("px", ""));
              this.minWidth = this.width;
              this.height = this.linegraphSVG.getBoundingClientRect().height;
              this.hidden = false;
              this.stepPixels = 25;
              this.zeroCrossing = -1;
              this.amountOfSteps = -1;
              this.lineOffset = 0;
              this.master = true;
              this.masterAxis = null;
              this.svgElements = {};
              this.iconsRemoved = false;
              this.groups = {};
              this.amountOfGroups = 0;
              this._create();
              this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
              var me = this;
              this.body.emitter.on("verticalDrag", function() {
                me.dom.lineContainer.style.top = me.body.domProps.scrollTop + "px";
              });
            }
            DataAxis.prototype = new Component();
            DataAxis.prototype.addGroup = function(label, graphOptions) {
              if (!this.groups.hasOwnProperty(label)) {
                this.groups[label] = graphOptions;
              }
              this.amountOfGroups += 1;
            };
            DataAxis.prototype.updateGroup = function(label, graphOptions) {
              if (!this.groups.hasOwnProperty(label)) {
                this.amountOfGroups += 1;
              }
              this.groups[label] = graphOptions;
            };
            DataAxis.prototype.removeGroup = function(label) {
              if (this.groups.hasOwnProperty(label)) {
                delete this.groups[label];
                this.amountOfGroups -= 1;
              }
            };
            DataAxis.prototype.setOptions = function(options) {
              if (options) {
                var redraw = false;
                if (this.options.orientation != options.orientation && options.orientation !== void 0) {
                  redraw = true;
                }
                var fields = ["orientation", "showMinorLabels", "showMajorLabels", "icons", "majorLinesOffset", "minorLinesOffset", "labelOffsetX", "labelOffsetY", "iconWidth", "width", "visible", "left", "right", "alignZeros"];
                util.selectiveDeepExtend(fields, this.options, options);
                this.minWidth = Number(("" + this.options.width).replace("px", ""));
                if (redraw === true && this.dom.frame) {
                  this.hide();
                  this.show();
                }
              }
            };
            DataAxis.prototype._create = function() {
              this.dom.frame = document.createElement("div");
              this.dom.frame.style.width = this.options.width;
              this.dom.frame.style.height = this.height;
              this.dom.lineContainer = document.createElement("div");
              this.dom.lineContainer.style.width = "100%";
              this.dom.lineContainer.style.height = this.height;
              this.dom.lineContainer.style.position = "relative";
              this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              this.svg.style.position = "absolute";
              this.svg.style.top = "0px";
              this.svg.style.height = "100%";
              this.svg.style.width = "100%";
              this.svg.style.display = "block";
              this.dom.frame.appendChild(this.svg);
            };
            DataAxis.prototype._redrawGroupIcons = function() {
              DOMutil.prepareElements(this.svgElements);
              var x;
              var iconWidth = this.options.iconWidth;
              var iconHeight = 15;
              var iconOffset = 4;
              var y = iconOffset + 0.5 * iconHeight;
              if (this.options.orientation === "left") {
                x = iconOffset;
              } else {
                x = this.width - iconWidth - iconOffset;
              }
              var groupArray = (0, _keys2["default"])(this.groups);
              groupArray.sort(function(a, b) {
                return a < b ? -1 : 1;
              });
              for (var i = 0; i < groupArray.length; i++) {
                var groupId = groupArray[i];
                if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] === true)) {
                  this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
                  y += iconHeight + iconOffset;
                }
              }
              DOMutil.cleanupElements(this.svgElements);
              this.iconsRemoved = false;
            };
            DataAxis.prototype._cleanupIcons = function() {
              if (this.iconsRemoved === false) {
                DOMutil.prepareElements(this.svgElements);
                DOMutil.cleanupElements(this.svgElements);
                this.iconsRemoved = true;
              }
            };
            DataAxis.prototype.show = function() {
              this.hidden = false;
              if (!this.dom.frame.parentNode) {
                if (this.options.orientation === "left") {
                  this.body.dom.left.appendChild(this.dom.frame);
                } else {
                  this.body.dom.right.appendChild(this.dom.frame);
                }
              }
              if (!this.dom.lineContainer.parentNode) {
                this.body.dom.backgroundHorizontal.appendChild(this.dom.lineContainer);
              }
            };
            DataAxis.prototype.hide = function() {
              this.hidden = true;
              if (this.dom.frame.parentNode) {
                this.dom.frame.parentNode.removeChild(this.dom.frame);
              }
              if (this.dom.lineContainer.parentNode) {
                this.dom.lineContainer.parentNode.removeChild(this.dom.lineContainer);
              }
            };
            DataAxis.prototype.setRange = function(start, end) {
              this.range.start = start;
              this.range.end = end;
            };
            DataAxis.prototype.redraw = function() {
              var resized = false;
              var activeGroups = 0;
              this.dom.lineContainer.style.top = this.body.domProps.scrollTop + "px";
              for (var groupId in this.groups) {
                if (this.groups.hasOwnProperty(groupId)) {
                  if (this.groups[groupId].visible === true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] === true)) {
                    activeGroups++;
                  }
                }
              }
              if (this.amountOfGroups === 0 || activeGroups === 0) {
                this.hide();
              } else {
                this.show();
                this.height = Number(this.linegraphSVG.style.height.replace("px", ""));
                this.dom.lineContainer.style.height = this.height + "px";
                this.width = this.options.visible === true ? Number(("" + this.options.width).replace("px", "")) : 0;
                var props = this.props;
                var frame = this.dom.frame;
                frame.className = "vis-data-axis";
                this._calculateCharSize();
                var orientation = this.options.orientation;
                var showMinorLabels = this.options.showMinorLabels;
                var showMajorLabels = this.options.showMajorLabels;
                props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
                props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
                props.minorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.minorLinesOffset;
                props.minorLineHeight = 1;
                props.majorLineWidth = this.body.dom.backgroundHorizontal.offsetWidth - this.lineOffset - this.width + 2 * this.options.majorLinesOffset;
                props.majorLineHeight = 1;
                if (orientation === "left") {
                  frame.style.top = "0";
                  frame.style.left = "0";
                  frame.style.bottom = "";
                  frame.style.width = this.width + "px";
                  frame.style.height = this.height + "px";
                  this.props.width = this.body.domProps.left.width;
                  this.props.height = this.body.domProps.left.height;
                } else {
                  frame.style.top = "";
                  frame.style.bottom = "0";
                  frame.style.left = "0";
                  frame.style.width = this.width + "px";
                  frame.style.height = this.height + "px";
                  this.props.width = this.body.domProps.right.width;
                  this.props.height = this.body.domProps.right.height;
                }
                resized = this._redrawLabels();
                resized = this._isResized() || resized;
                if (this.options.icons === true) {
                  this._redrawGroupIcons();
                } else {
                  this._cleanupIcons();
                }
                this._redrawTitle(orientation);
              }
              return resized;
            };
            DataAxis.prototype._redrawLabels = function() {
              var _this = this;
              var resized = false;
              DOMutil.prepareElements(this.DOMelements.lines);
              DOMutil.prepareElements(this.DOMelements.labels);
              var orientation = this.options["orientation"];
              var customRange = this.options[orientation].range != void 0 ? this.options[orientation].range : {};
              var autoScaleEnd = true;
              if (customRange.max != void 0) {
                this.range.end = customRange.max;
                autoScaleEnd = false;
              }
              var autoScaleStart = true;
              if (customRange.min != void 0) {
                this.range.start = customRange.min;
                autoScaleStart = false;
              }
              this.scale = new DataScale(this.range.start, this.range.end, autoScaleStart, autoScaleEnd, this.dom.frame.offsetHeight, this.props.majorCharHeight, this.options.alignZeros, this.options[orientation].format);
              if (this.master === false && this.masterAxis != void 0) {
                this.scale.followScale(this.masterAxis.scale);
              }
              this.maxLabelSize = 0;
              var lines = this.scale.getLines();
              lines.forEach(function(line) {
                var y = line.y;
                var isMajor = line.major;
                if (_this.options["showMinorLabels"] && isMajor === false) {
                  _this._redrawLabel(y - 2, line.val, orientation, "vis-y-axis vis-minor", _this.props.minorCharHeight);
                }
                if (isMajor) {
                  if (y >= 0) {
                    _this._redrawLabel(y - 2, line.val, orientation, "vis-y-axis vis-major", _this.props.majorCharHeight);
                  }
                }
                if (_this.master === true) {
                  if (isMajor) {
                    _this._redrawLine(y, orientation, "vis-grid vis-horizontal vis-major", _this.options.majorLinesOffset, _this.props.majorLineWidth);
                  } else {
                    _this._redrawLine(y, orientation, "vis-grid vis-horizontal vis-minor", _this.options.minorLinesOffset, _this.props.minorLineWidth);
                  }
                }
              });
              var titleWidth = 0;
              if (this.options[orientation].title !== void 0 && this.options[orientation].title.text !== void 0) {
                titleWidth = this.props.titleCharHeight;
              }
              var offset = this.options.icons === true ? Math.max(this.options.iconWidth, titleWidth) + this.options.labelOffsetX + 15 : titleWidth + this.options.labelOffsetX + 15;
              if (this.maxLabelSize > this.width - offset && this.options.visible === true) {
                this.width = this.maxLabelSize + offset;
                this.options.width = this.width + "px";
                DOMutil.cleanupElements(this.DOMelements.lines);
                DOMutil.cleanupElements(this.DOMelements.labels);
                this.redraw();
                resized = true;
              } else if (this.maxLabelSize < this.width - offset && this.options.visible === true && this.width > this.minWidth) {
                this.width = Math.max(this.minWidth, this.maxLabelSize + offset);
                this.options.width = this.width + "px";
                DOMutil.cleanupElements(this.DOMelements.lines);
                DOMutil.cleanupElements(this.DOMelements.labels);
                this.redraw();
                resized = true;
              } else {
                DOMutil.cleanupElements(this.DOMelements.lines);
                DOMutil.cleanupElements(this.DOMelements.labels);
                resized = false;
              }
              return resized;
            };
            DataAxis.prototype.convertValue = function(value) {
              return this.scale.convertValue(value);
            };
            DataAxis.prototype.screenToValue = function(x) {
              return this.scale.screenToValue(x);
            };
            DataAxis.prototype._redrawLabel = function(y, text, orientation, className, characterHeight) {
              var label = DOMutil.getDOMElement("div", this.DOMelements.labels, this.dom.frame);
              label.className = className;
              label.innerHTML = text;
              if (orientation === "left") {
                label.style.left = "-" + this.options.labelOffsetX + "px";
                label.style.textAlign = "right";
              } else {
                label.style.right = "-" + this.options.labelOffsetX + "px";
                label.style.textAlign = "left";
              }
              label.style.top = y - 0.5 * characterHeight + this.options.labelOffsetY + "px";
              text += "";
              var largestWidth = Math.max(this.props.majorCharWidth, this.props.minorCharWidth);
              if (this.maxLabelSize < text.length * largestWidth) {
                this.maxLabelSize = text.length * largestWidth;
              }
            };
            DataAxis.prototype._redrawLine = function(y, orientation, className, offset, width) {
              if (this.master === true) {
                var line = DOMutil.getDOMElement("div", this.DOMelements.lines, this.dom.lineContainer);
                line.className = className;
                line.innerHTML = "";
                if (orientation === "left") {
                  line.style.left = this.width - offset + "px";
                } else {
                  line.style.right = this.width - offset + "px";
                }
                line.style.width = width + "px";
                line.style.top = y + "px";
              }
            };
            DataAxis.prototype._redrawTitle = function(orientation) {
              DOMutil.prepareElements(this.DOMelements.title);
              if (this.options[orientation].title !== void 0 && this.options[orientation].title.text !== void 0) {
                var title = DOMutil.getDOMElement("div", this.DOMelements.title, this.dom.frame);
                title.className = "vis-y-axis vis-title vis-" + orientation;
                title.innerHTML = this.options[orientation].title.text;
                if (this.options[orientation].title.style !== void 0) {
                  util.addCssText(title, this.options[orientation].title.style);
                }
                if (orientation === "left") {
                  title.style.left = this.props.titleCharHeight + "px";
                } else {
                  title.style.right = this.props.titleCharHeight + "px";
                }
                title.style.width = this.height + "px";
              }
              DOMutil.cleanupElements(this.DOMelements.title);
            };
            DataAxis.prototype._calculateCharSize = function() {
              if (!("minorCharHeight" in this.props)) {
                var textMinor = document.createTextNode("0");
                var measureCharMinor = document.createElement("div");
                measureCharMinor.className = "vis-y-axis vis-minor vis-measure";
                measureCharMinor.appendChild(textMinor);
                this.dom.frame.appendChild(measureCharMinor);
                this.props.minorCharHeight = measureCharMinor.clientHeight;
                this.props.minorCharWidth = measureCharMinor.clientWidth;
                this.dom.frame.removeChild(measureCharMinor);
              }
              if (!("majorCharHeight" in this.props)) {
                var textMajor = document.createTextNode("0");
                var measureCharMajor = document.createElement("div");
                measureCharMajor.className = "vis-y-axis vis-major vis-measure";
                measureCharMajor.appendChild(textMajor);
                this.dom.frame.appendChild(measureCharMajor);
                this.props.majorCharHeight = measureCharMajor.clientHeight;
                this.props.majorCharWidth = measureCharMajor.clientWidth;
                this.dom.frame.removeChild(measureCharMajor);
              }
              if (!("titleCharHeight" in this.props)) {
                var textTitle = document.createTextNode("0");
                var measureCharTitle = document.createElement("div");
                measureCharTitle.className = "vis-y-axis vis-title vis-measure";
                measureCharTitle.appendChild(textTitle);
                this.dom.frame.appendChild(measureCharTitle);
                this.props.titleCharHeight = measureCharTitle.clientHeight;
                this.props.titleCharWidth = measureCharTitle.clientWidth;
                this.dom.frame.removeChild(measureCharTitle);
              }
            };
            module2.exports = DataAxis;
          },
          /* 108 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function DataScale(start, end, autoScaleStart, autoScaleEnd, containerHeight, majorCharHeight) {
              var zeroAlign = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              var formattingFunction = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
              this.majorSteps = [1, 2, 5, 10];
              this.minorSteps = [0.25, 0.5, 1, 2];
              this.customLines = null;
              this.containerHeight = containerHeight;
              this.majorCharHeight = majorCharHeight;
              this._start = start;
              this._end = end;
              this.scale = 1;
              this.minorStepIdx = -1;
              this.magnitudefactor = 1;
              this.determineScale();
              this.zeroAlign = zeroAlign;
              this.autoScaleStart = autoScaleStart;
              this.autoScaleEnd = autoScaleEnd;
              this.formattingFunction = formattingFunction;
              if (autoScaleStart || autoScaleEnd) {
                var me = this;
                var roundToMinor = function roundToMinor2(value) {
                  var rounded = value - value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]);
                  if (value % (me.magnitudefactor * me.minorSteps[me.minorStepIdx]) > 0.5 * (me.magnitudefactor * me.minorSteps[me.minorStepIdx])) {
                    return rounded + me.magnitudefactor * me.minorSteps[me.minorStepIdx];
                  } else {
                    return rounded;
                  }
                };
                if (autoScaleStart) {
                  this._start -= this.magnitudefactor * 2 * this.minorSteps[this.minorStepIdx];
                  this._start = roundToMinor(this._start);
                }
                if (autoScaleEnd) {
                  this._end += this.magnitudefactor * this.minorSteps[this.minorStepIdx];
                  this._end = roundToMinor(this._end);
                }
                this.determineScale();
              }
            }
            DataScale.prototype.setCharHeight = function(majorCharHeight) {
              this.majorCharHeight = majorCharHeight;
            };
            DataScale.prototype.setHeight = function(containerHeight) {
              this.containerHeight = containerHeight;
            };
            DataScale.prototype.determineScale = function() {
              var range = this._end - this._start;
              this.scale = this.containerHeight / range;
              var minimumStepValue = this.majorCharHeight / this.scale;
              var orderOfMagnitude = range > 0 ? Math.round(Math.log(range) / Math.LN10) : 0;
              this.minorStepIdx = -1;
              this.magnitudefactor = Math.pow(10, orderOfMagnitude);
              var start = 0;
              if (orderOfMagnitude < 0) {
                start = orderOfMagnitude;
              }
              var solutionFound = false;
              for (var l = start; Math.abs(l) <= Math.abs(orderOfMagnitude); l++) {
                this.magnitudefactor = Math.pow(10, l);
                for (var j = 0; j < this.minorSteps.length; j++) {
                  var stepSize = this.magnitudefactor * this.minorSteps[j];
                  if (stepSize >= minimumStepValue) {
                    solutionFound = true;
                    this.minorStepIdx = j;
                    break;
                  }
                }
                if (solutionFound === true) {
                  break;
                }
              }
            };
            DataScale.prototype.is_major = function(value) {
              return value % (this.magnitudefactor * this.majorSteps[this.minorStepIdx]) === 0;
            };
            DataScale.prototype.getStep = function() {
              return this.magnitudefactor * this.minorSteps[this.minorStepIdx];
            };
            DataScale.prototype.getFirstMajor = function() {
              var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
              return this.convertValue(this._start + (majorStep - this._start % majorStep) % majorStep);
            };
            DataScale.prototype.formatValue = function(current) {
              var returnValue = current.toPrecision(5);
              if (typeof this.formattingFunction === "function") {
                returnValue = this.formattingFunction(current);
              }
              if (typeof returnValue === "number") {
                return "" + returnValue;
              } else if (typeof returnValue === "string") {
                return returnValue;
              } else {
                return current.toPrecision(5);
              }
            };
            DataScale.prototype.getLines = function() {
              var lines = [];
              var step = this.getStep();
              var bottomOffset = (step - this._start % step) % step;
              for (var i = this._start + bottomOffset; this._end - i > 1e-5; i += step) {
                if (i != this._start) {
                  lines.push({ major: this.is_major(i), y: this.convertValue(i), val: this.formatValue(i) });
                }
              }
              return lines;
            };
            DataScale.prototype.followScale = function(other) {
              var oldStepIdx = this.minorStepIdx;
              var oldStart = this._start;
              var oldEnd = this._end;
              var me = this;
              var increaseMagnitude = function increaseMagnitude2() {
                me.magnitudefactor *= 2;
              };
              var decreaseMagnitude = function decreaseMagnitude2() {
                me.magnitudefactor /= 2;
              };
              if (other.minorStepIdx <= 1 && this.minorStepIdx <= 1 || other.minorStepIdx > 1 && this.minorStepIdx > 1) {
              } else if (other.minorStepIdx < this.minorStepIdx) {
                this.minorStepIdx = 1;
                if (oldStepIdx == 2) {
                  increaseMagnitude();
                } else {
                  increaseMagnitude();
                  increaseMagnitude();
                }
              } else {
                this.minorStepIdx = 2;
                if (oldStepIdx == 1) {
                  decreaseMagnitude();
                } else {
                  decreaseMagnitude();
                  decreaseMagnitude();
                }
              }
              var otherZero = other.convertValue(0);
              var otherStep = other.getStep() * other.scale;
              var done = false;
              var count = 0;
              while (!done && count++ < 5) {
                this.scale = otherStep / (this.minorSteps[this.minorStepIdx] * this.magnitudefactor);
                var newRange = this.containerHeight / this.scale;
                this._start = oldStart;
                this._end = this._start + newRange;
                var myOriginalZero = this._end * this.scale;
                var majorStep = this.magnitudefactor * this.majorSteps[this.minorStepIdx];
                var majorOffset = this.getFirstMajor() - other.getFirstMajor();
                if (this.zeroAlign) {
                  var zeroOffset = otherZero - myOriginalZero;
                  this._end += zeroOffset / this.scale;
                  this._start = this._end - newRange;
                } else {
                  if (!this.autoScaleStart) {
                    this._start += majorStep - majorOffset / this.scale;
                    this._end = this._start + newRange;
                  } else {
                    this._start -= majorOffset / this.scale;
                    this._end = this._start + newRange;
                  }
                }
                if (!this.autoScaleEnd && this._end > oldEnd + 1e-5) {
                  decreaseMagnitude();
                  done = false;
                  continue;
                }
                if (!this.autoScaleStart && this._start < oldStart - 1e-5) {
                  if (this.zeroAlign && oldStart >= 0) {
                    console.warn("Can't adhere to given 'min' range, due to zeroalign");
                  } else {
                    decreaseMagnitude();
                    done = false;
                    continue;
                  }
                }
                if (this.autoScaleStart && this.autoScaleEnd && newRange < oldEnd - oldStart) {
                  increaseMagnitude();
                  done = false;
                  continue;
                }
                done = true;
              }
            };
            DataScale.prototype.convertValue = function(value) {
              return this.containerHeight - (value - this._start) * this.scale;
            };
            DataScale.prototype.screenToValue = function(pixels) {
              return (this.containerHeight - pixels) / this.scale + this._start;
            };
            module2.exports = DataScale;
          },
          /* 109 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Bars = __webpack_require__(110);
            var Lines = __webpack_require__(111);
            var Points = __webpack_require__(72);
            function GraphGroup(group, groupId, options, groupsUsingDefaultStyles) {
              this.id = groupId;
              var fields = ["sampling", "style", "sort", "yAxisOrientation", "barChart", "drawPoints", "shaded", "interpolation", "zIndex", "excludeFromStacking", "excludeFromLegend"];
              this.options = util.selectiveBridgeObject(fields, options);
              this.usingDefaultStyle = group.className === void 0;
              this.groupsUsingDefaultStyles = groupsUsingDefaultStyles;
              this.zeroPosition = 0;
              this.update(group);
              if (this.usingDefaultStyle == true) {
                this.groupsUsingDefaultStyles[0] += 1;
              }
              this.itemsData = [];
              this.visible = group.visible === void 0 ? true : group.visible;
            }
            GraphGroup.prototype.setItems = function(items) {
              if (items != null) {
                this.itemsData = items;
                if (this.options.sort == true) {
                  util.insertSort(this.itemsData, function(a, b) {
                    return a.x > b.x ? 1 : -1;
                  });
                }
              } else {
                this.itemsData = [];
              }
            };
            GraphGroup.prototype.getItems = function() {
              return this.itemsData;
            };
            GraphGroup.prototype.setZeroPosition = function(pos) {
              this.zeroPosition = pos;
            };
            GraphGroup.prototype.setOptions = function(options) {
              if (options !== void 0) {
                var fields = ["sampling", "style", "sort", "yAxisOrientation", "barChart", "zIndex", "excludeFromStacking", "excludeFromLegend"];
                util.selectiveDeepExtend(fields, this.options, options);
                if (typeof options.drawPoints == "function") {
                  options.drawPoints = {
                    onRender: options.drawPoints
                  };
                }
                util.mergeOptions(this.options, options, "interpolation");
                util.mergeOptions(this.options, options, "drawPoints");
                util.mergeOptions(this.options, options, "shaded");
                if (options.interpolation) {
                  if ((0, _typeof3["default"])(options.interpolation) == "object") {
                    if (options.interpolation.parametrization) {
                      if (options.interpolation.parametrization == "uniform") {
                        this.options.interpolation.alpha = 0;
                      } else if (options.interpolation.parametrization == "chordal") {
                        this.options.interpolation.alpha = 1;
                      } else {
                        this.options.interpolation.parametrization = "centripetal";
                        this.options.interpolation.alpha = 0.5;
                      }
                    }
                  }
                }
              }
            };
            GraphGroup.prototype.update = function(group) {
              this.group = group;
              this.content = group.content || "graph";
              this.className = group.className || this.className || "vis-graph-group" + this.groupsUsingDefaultStyles[0] % 10;
              this.visible = group.visible === void 0 ? true : group.visible;
              this.style = group.style;
              this.setOptions(group.options);
            };
            GraphGroup.prototype.getLegend = function(iconWidth, iconHeight, framework, x, y) {
              if (framework == void 0 || framework == null) {
                var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                framework = { svg, svgElements: {}, options: this.options, groups: [this] };
              }
              if (x == void 0 || x == null) {
                x = 0;
              }
              if (y == void 0 || y == null) {
                y = 0.5 * iconHeight;
              }
              switch (this.options.style) {
                case "line":
                  Lines.drawIcon(this, x, y, iconWidth, iconHeight, framework);
                  break;
                case "points":
                //explicit no break
                case "point":
                  Points.drawIcon(this, x, y, iconWidth, iconHeight, framework);
                  break;
                case "bar":
                  Bars.drawIcon(this, x, y, iconWidth, iconHeight, framework);
                  break;
              }
              return { icon: framework.svg, label: this.content, orientation: this.options.yAxisOrientation };
            };
            GraphGroup.prototype.getYRange = function(groupData) {
              var yMin = groupData[0].y;
              var yMax = groupData[0].y;
              for (var j = 0; j < groupData.length; j++) {
                yMin = yMin > groupData[j].y ? groupData[j].y : yMin;
                yMax = yMax < groupData[j].y ? groupData[j].y : yMax;
              }
              return { min: yMin, max: yMax, yAxisOrientation: this.options.yAxisOrientation };
            };
            module2.exports = GraphGroup;
          },
          /* 110 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var DOMutil = __webpack_require__(14);
            var Points = __webpack_require__(72);
            function Bargraph(groupId, options) {
            }
            Bargraph.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
              var fillHeight = iconHeight * 0.5;
              var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
              outline.setAttributeNS(null, "x", x);
              outline.setAttributeNS(null, "y", y - fillHeight);
              outline.setAttributeNS(null, "width", iconWidth);
              outline.setAttributeNS(null, "height", 2 * fillHeight);
              outline.setAttributeNS(null, "class", "vis-outline");
              var barWidth = Math.round(0.3 * iconWidth);
              var originalWidth = group.options.barChart.width;
              var scale = originalWidth / barWidth;
              var bar1Height = Math.round(0.4 * iconHeight);
              var bar2Height = Math.round(0.75 * iconHeight);
              var offset = Math.round((iconWidth - 2 * barWidth) / 3);
              DOMutil.drawBar(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, barWidth, bar1Height, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
              DOMutil.drawBar(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, barWidth, bar2Height, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
              if (group.options.drawPoints.enabled == true) {
                var groupTemplate = {
                  style: group.options.drawPoints.style,
                  styles: group.options.drawPoints.styles,
                  size: group.options.drawPoints.size / scale,
                  className: group.className
                };
                DOMutil.drawPoint(x + 0.5 * barWidth + offset, y + fillHeight - bar1Height - 1, groupTemplate, framework.svgElements, framework.svg);
                DOMutil.drawPoint(x + 1.5 * barWidth + offset + 2, y + fillHeight - bar2Height - 1, groupTemplate, framework.svgElements, framework.svg);
              }
            };
            Bargraph.draw = function(groupIds, processedGroupData, framework) {
              var combinedData = [];
              var intersections = {};
              var coreDistance;
              var key, drawData;
              var group;
              var i, j;
              var barPoints = 0;
              for (i = 0; i < groupIds.length; i++) {
                group = framework.groups[groupIds[i]];
                if (group.options.style === "bar") {
                  if (group.visible === true && (framework.options.groups.visibility[groupIds[i]] === void 0 || framework.options.groups.visibility[groupIds[i]] === true)) {
                    for (j = 0; j < processedGroupData[groupIds[i]].length; j++) {
                      combinedData.push({
                        screen_x: processedGroupData[groupIds[i]][j].screen_x,
                        screen_end: processedGroupData[groupIds[i]][j].screen_end,
                        screen_y: processedGroupData[groupIds[i]][j].screen_y,
                        x: processedGroupData[groupIds[i]][j].x,
                        end: processedGroupData[groupIds[i]][j].end,
                        y: processedGroupData[groupIds[i]][j].y,
                        groupId: groupIds[i],
                        label: processedGroupData[groupIds[i]][j].label
                      });
                      barPoints += 1;
                    }
                  }
                }
              }
              if (barPoints === 0) {
                return;
              }
              combinedData.sort(function(a, b) {
                if (a.screen_x === b.screen_x) {
                  return a.groupId < b.groupId ? -1 : 1;
                } else {
                  return a.screen_x - b.screen_x;
                }
              });
              Bargraph._getDataIntersections(intersections, combinedData);
              for (i = 0; i < combinedData.length; i++) {
                group = framework.groups[combinedData[i].groupId];
                var minWidth = group.options.barChart.minWidth != void 0 ? group.options.barChart.minWidth : 0.1 * group.options.barChart.width;
                key = combinedData[i].screen_x;
                var heightOffset = 0;
                if (intersections[key] === void 0) {
                  if (i + 1 < combinedData.length) {
                    coreDistance = Math.abs(combinedData[i + 1].screen_x - key);
                  }
                  drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
                } else {
                  var nextKey = i + (intersections[key].amount - intersections[key].resolved);
                  if (nextKey < combinedData.length) {
                    coreDistance = Math.abs(combinedData[nextKey].screen_x - key);
                  }
                  drawData = Bargraph._getSafeDrawData(coreDistance, group, minWidth);
                  intersections[key].resolved += 1;
                  if (group.options.stack === true && group.options.excludeFromStacking !== true) {
                    if (combinedData[i].screen_y < group.zeroPosition) {
                      heightOffset = intersections[key].accumulatedNegative;
                      intersections[key].accumulatedNegative += group.zeroPosition - combinedData[i].screen_y;
                    } else {
                      heightOffset = intersections[key].accumulatedPositive;
                      intersections[key].accumulatedPositive += group.zeroPosition - combinedData[i].screen_y;
                    }
                  } else if (group.options.barChart.sideBySide === true) {
                    drawData.width = drawData.width / intersections[key].amount;
                    drawData.offset += intersections[key].resolved * drawData.width - 0.5 * drawData.width * (intersections[key].amount + 1);
                  }
                }
                var dataWidth = drawData.width;
                var start = combinedData[i].screen_x;
                if (combinedData[i].screen_end != void 0) {
                  dataWidth = combinedData[i].screen_end - combinedData[i].screen_x;
                  start += dataWidth * 0.5;
                } else {
                  start += drawData.offset;
                }
                DOMutil.drawBar(start, combinedData[i].screen_y - heightOffset, dataWidth, group.zeroPosition - combinedData[i].screen_y, group.className + " vis-bar", framework.svgElements, framework.svg, group.style);
                if (group.options.drawPoints.enabled === true) {
                  var pointData = {
                    screen_x: combinedData[i].screen_x,
                    screen_y: combinedData[i].screen_y - heightOffset,
                    x: combinedData[i].x,
                    y: combinedData[i].y,
                    groupId: combinedData[i].groupId,
                    label: combinedData[i].label
                  };
                  Points.draw([pointData], group, framework, drawData.offset);
                }
              }
            };
            Bargraph._getDataIntersections = function(intersections, combinedData) {
              var coreDistance;
              for (var i = 0; i < combinedData.length; i++) {
                if (i + 1 < combinedData.length) {
                  coreDistance = Math.abs(combinedData[i + 1].screen_x - combinedData[i].screen_x);
                }
                if (i > 0) {
                  coreDistance = Math.min(coreDistance, Math.abs(combinedData[i - 1].screen_x - combinedData[i].screen_x));
                }
                if (coreDistance === 0) {
                  if (intersections[combinedData[i].screen_x] === void 0) {
                    intersections[combinedData[i].screen_x] = {
                      amount: 0,
                      resolved: 0,
                      accumulatedPositive: 0,
                      accumulatedNegative: 0
                    };
                  }
                  intersections[combinedData[i].screen_x].amount += 1;
                }
              }
            };
            Bargraph._getSafeDrawData = function(coreDistance, group, minWidth) {
              var width, offset;
              if (coreDistance < group.options.barChart.width && coreDistance > 0) {
                width = coreDistance < minWidth ? minWidth : coreDistance;
                offset = 0;
                if (group.options.barChart.align === "left") {
                  offset -= 0.5 * coreDistance;
                } else if (group.options.barChart.align === "right") {
                  offset += 0.5 * coreDistance;
                }
              } else {
                width = group.options.barChart.width;
                offset = 0;
                if (group.options.barChart.align === "left") {
                  offset -= 0.5 * group.options.barChart.width;
                } else if (group.options.barChart.align === "right") {
                  offset += 0.5 * group.options.barChart.width;
                }
              }
              return { width, offset };
            };
            Bargraph.getStackedYRange = function(combinedData, groupRanges, groupIds, groupLabel, orientation) {
              if (combinedData.length > 0) {
                combinedData.sort(function(a, b) {
                  if (a.screen_x === b.screen_x) {
                    return a.groupId < b.groupId ? -1 : 1;
                  } else {
                    return a.screen_x - b.screen_x;
                  }
                });
                var intersections = {};
                Bargraph._getDataIntersections(intersections, combinedData);
                groupRanges[groupLabel] = Bargraph._getStackedYRange(intersections, combinedData);
                groupRanges[groupLabel].yAxisOrientation = orientation;
                groupIds.push(groupLabel);
              }
            };
            Bargraph._getStackedYRange = function(intersections, combinedData) {
              var key;
              var yMin = combinedData[0].screen_y;
              var yMax = combinedData[0].screen_y;
              for (var i = 0; i < combinedData.length; i++) {
                key = combinedData[i].screen_x;
                if (intersections[key] === void 0) {
                  yMin = yMin > combinedData[i].screen_y ? combinedData[i].screen_y : yMin;
                  yMax = yMax < combinedData[i].screen_y ? combinedData[i].screen_y : yMax;
                } else {
                  if (combinedData[i].screen_y < 0) {
                    intersections[key].accumulatedNegative += combinedData[i].screen_y;
                  } else {
                    intersections[key].accumulatedPositive += combinedData[i].screen_y;
                  }
                }
              }
              for (var xpos in intersections) {
                if (intersections.hasOwnProperty(xpos)) {
                  yMin = yMin > intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMin;
                  yMin = yMin > intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMin;
                  yMax = yMax < intersections[xpos].accumulatedNegative ? intersections[xpos].accumulatedNegative : yMax;
                  yMax = yMax < intersections[xpos].accumulatedPositive ? intersections[xpos].accumulatedPositive : yMax;
                }
              }
              return { min: yMin, max: yMax };
            };
            module2.exports = Bargraph;
          },
          /* 111 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var DOMutil = __webpack_require__(14);
            function Line(groupId, options) {
            }
            Line.calcPath = function(dataset, group) {
              if (dataset != null) {
                if (dataset.length > 0) {
                  var d = [];
                  if (group.options.interpolation.enabled == true) {
                    d = Line._catmullRom(dataset, group);
                  } else {
                    d = Line._linear(dataset);
                  }
                  return d;
                }
              }
            };
            Line.drawIcon = function(group, x, y, iconWidth, iconHeight, framework) {
              var fillHeight = iconHeight * 0.5;
              var path, fillPath;
              var outline = DOMutil.getSVGElement("rect", framework.svgElements, framework.svg);
              outline.setAttributeNS(null, "x", x);
              outline.setAttributeNS(null, "y", y - fillHeight);
              outline.setAttributeNS(null, "width", iconWidth);
              outline.setAttributeNS(null, "height", 2 * fillHeight);
              outline.setAttributeNS(null, "class", "vis-outline");
              path = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
              path.setAttributeNS(null, "class", group.className);
              if (group.style !== void 0) {
                path.setAttributeNS(null, "style", group.style);
              }
              path.setAttributeNS(null, "d", "M" + x + "," + y + " L" + (x + iconWidth) + "," + y);
              if (group.options.shaded.enabled == true) {
                fillPath = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
                if (group.options.shaded.orientation == "top") {
                  fillPath.setAttributeNS(null, "d", "M" + x + ", " + (y - fillHeight) + "L" + x + "," + y + " L" + (x + iconWidth) + "," + y + " L" + (x + iconWidth) + "," + (y - fillHeight));
                } else {
                  fillPath.setAttributeNS(null, "d", "M" + x + "," + y + " L" + x + "," + (y + fillHeight) + " L" + (x + iconWidth) + "," + (y + fillHeight) + "L" + (x + iconWidth) + "," + y);
                }
                fillPath.setAttributeNS(null, "class", group.className + " vis-icon-fill");
                if (group.options.shaded.style !== void 0 && group.options.shaded.style !== "") {
                  fillPath.setAttributeNS(null, "style", group.options.shaded.style);
                }
              }
              if (group.options.drawPoints.enabled == true) {
                var groupTemplate = {
                  style: group.options.drawPoints.style,
                  styles: group.options.drawPoints.styles,
                  size: group.options.drawPoints.size,
                  className: group.className
                };
                DOMutil.drawPoint(x + 0.5 * iconWidth, y, groupTemplate, framework.svgElements, framework.svg);
              }
            };
            Line.drawShading = function(pathArray, group, subPathArray, framework) {
              if (group.options.shaded.enabled == true) {
                var svgHeight = Number(framework.svg.style.height.replace("px", ""));
                var fillPath = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
                var type = "L";
                if (group.options.interpolation.enabled == true) {
                  type = "C";
                }
                var dFill;
                var zero = 0;
                if (group.options.shaded.orientation == "top") {
                  zero = 0;
                } else if (group.options.shaded.orientation == "bottom") {
                  zero = svgHeight;
                } else {
                  zero = Math.min(Math.max(0, group.zeroPosition), svgHeight);
                }
                if (group.options.shaded.orientation == "group" && subPathArray != null && subPathArray != void 0) {
                  dFill = "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + " L" + subPathArray[subPathArray.length - 1][0] + "," + subPathArray[subPathArray.length - 1][1] + " " + this.serializePath(subPathArray, type, true) + subPathArray[0][0] + "," + subPathArray[0][1] + " Z";
                } else {
                  dFill = "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false) + " V" + zero + " H" + pathArray[0][0] + " Z";
                }
                fillPath.setAttributeNS(null, "class", group.className + " vis-fill");
                if (group.options.shaded.style !== void 0) {
                  fillPath.setAttributeNS(null, "style", group.options.shaded.style);
                }
                fillPath.setAttributeNS(null, "d", dFill);
              }
            };
            Line.draw = function(pathArray, group, framework) {
              if (pathArray != null && pathArray != void 0) {
                var path = DOMutil.getSVGElement("path", framework.svgElements, framework.svg);
                path.setAttributeNS(null, "class", group.className);
                if (group.style !== void 0) {
                  path.setAttributeNS(null, "style", group.style);
                }
                var type = "L";
                if (group.options.interpolation.enabled == true) {
                  type = "C";
                }
                path.setAttributeNS(null, "d", "M" + pathArray[0][0] + "," + pathArray[0][1] + " " + this.serializePath(pathArray, type, false));
              }
            };
            Line.serializePath = function(pathArray, type, inverse) {
              if (pathArray.length < 2) {
                return "";
              }
              var d = type;
              var i;
              if (inverse) {
                for (i = pathArray.length - 2; i > 0; i--) {
                  d += pathArray[i][0] + "," + pathArray[i][1] + " ";
                }
              } else {
                for (i = 1; i < pathArray.length; i++) {
                  d += pathArray[i][0] + "," + pathArray[i][1] + " ";
                }
              }
              return d;
            };
            Line._catmullRomUniform = function(data) {
              var p0, p1, p2, p3, bp1, bp2;
              var d = [];
              d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
              var normalization = 1 / 6;
              var length = data.length;
              for (var i = 0; i < length - 1; i++) {
                p0 = i == 0 ? data[0] : data[i - 1];
                p1 = data[i];
                p2 = data[i + 1];
                p3 = i + 2 < length ? data[i + 2] : p2;
                bp1 = {
                  screen_x: (-p0.screen_x + 6 * p1.screen_x + p2.screen_x) * normalization,
                  screen_y: (-p0.screen_y + 6 * p1.screen_y + p2.screen_y) * normalization
                };
                bp2 = {
                  screen_x: (p1.screen_x + 6 * p2.screen_x - p3.screen_x) * normalization,
                  screen_y: (p1.screen_y + 6 * p2.screen_y - p3.screen_y) * normalization
                };
                d.push([bp1.screen_x, bp1.screen_y]);
                d.push([bp2.screen_x, bp2.screen_y]);
                d.push([p2.screen_x, p2.screen_y]);
              }
              return d;
            };
            Line._catmullRom = function(data, group) {
              var alpha = group.options.interpolation.alpha;
              if (alpha == 0 || alpha === void 0) {
                return this._catmullRomUniform(data);
              } else {
                var p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
                var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
                var d = [];
                d.push([Math.round(data[0].screen_x), Math.round(data[0].screen_y)]);
                var length = data.length;
                for (var i = 0; i < length - 1; i++) {
                  p0 = i == 0 ? data[0] : data[i - 1];
                  p1 = data[i];
                  p2 = data[i + 1];
                  p3 = i + 2 < length ? data[i + 2] : p2;
                  d1 = Math.sqrt(Math.pow(p0.screen_x - p1.screen_x, 2) + Math.pow(p0.screen_y - p1.screen_y, 2));
                  d2 = Math.sqrt(Math.pow(p1.screen_x - p2.screen_x, 2) + Math.pow(p1.screen_y - p2.screen_y, 2));
                  d3 = Math.sqrt(Math.pow(p2.screen_x - p3.screen_x, 2) + Math.pow(p2.screen_y - p3.screen_y, 2));
                  d3powA = Math.pow(d3, alpha);
                  d3pow2A = Math.pow(d3, 2 * alpha);
                  d2powA = Math.pow(d2, alpha);
                  d2pow2A = Math.pow(d2, 2 * alpha);
                  d1powA = Math.pow(d1, alpha);
                  d1pow2A = Math.pow(d1, 2 * alpha);
                  A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
                  B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
                  N = 3 * d1powA * (d1powA + d2powA);
                  if (N > 0) {
                    N = 1 / N;
                  }
                  M = 3 * d3powA * (d3powA + d2powA);
                  if (M > 0) {
                    M = 1 / M;
                  }
                  bp1 = {
                    screen_x: (-d2pow2A * p0.screen_x + A * p1.screen_x + d1pow2A * p2.screen_x) * N,
                    screen_y: (-d2pow2A * p0.screen_y + A * p1.screen_y + d1pow2A * p2.screen_y) * N
                  };
                  bp2 = {
                    screen_x: (d3pow2A * p1.screen_x + B * p2.screen_x - d2pow2A * p3.screen_x) * M,
                    screen_y: (d3pow2A * p1.screen_y + B * p2.screen_y - d2pow2A * p3.screen_y) * M
                  };
                  if (bp1.screen_x == 0 && bp1.screen_y == 0) {
                    bp1 = p1;
                  }
                  if (bp2.screen_x == 0 && bp2.screen_y == 0) {
                    bp2 = p2;
                  }
                  d.push([bp1.screen_x, bp1.screen_y]);
                  d.push([bp2.screen_x, bp2.screen_y]);
                  d.push([p2.screen_x, p2.screen_y]);
                }
                return d;
              }
            };
            Line._linear = function(data) {
              var d = [];
              for (var i = 0; i < data.length; i++) {
                d.push([data[i].screen_x, data[i].screen_y]);
              }
              return d;
            };
            module2.exports = Line;
          },
          /* 112 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DOMutil = __webpack_require__(14);
            var Component = __webpack_require__(16);
            function Legend(body, options, side, linegraphOptions) {
              this.body = body;
              this.defaultOptions = {
                enabled: false,
                icons: true,
                iconSize: 20,
                iconSpacing: 6,
                left: {
                  visible: true,
                  position: "top-left"
                  // top/bottom - left,center,right
                },
                right: {
                  visible: true,
                  position: "top-right"
                  // top/bottom - left,center,right
                }
              };
              this.side = side;
              this.options = util.extend({}, this.defaultOptions);
              this.linegraphOptions = linegraphOptions;
              this.svgElements = {};
              this.dom = {};
              this.groups = {};
              this.amountOfGroups = 0;
              this._create();
              this.framework = { svg: this.svg, svgElements: this.svgElements, options: this.options, groups: this.groups };
              this.setOptions(options);
            }
            Legend.prototype = new Component();
            Legend.prototype.clear = function() {
              this.groups = {};
              this.amountOfGroups = 0;
            };
            Legend.prototype.addGroup = function(label, graphOptions) {
              if (graphOptions.options.excludeFromLegend != true) {
                if (!this.groups.hasOwnProperty(label)) {
                  this.groups[label] = graphOptions;
                }
                this.amountOfGroups += 1;
              }
            };
            Legend.prototype.updateGroup = function(label, graphOptions) {
              this.groups[label] = graphOptions;
            };
            Legend.prototype.removeGroup = function(label) {
              if (this.groups.hasOwnProperty(label)) {
                delete this.groups[label];
                this.amountOfGroups -= 1;
              }
            };
            Legend.prototype._create = function() {
              this.dom.frame = document.createElement("div");
              this.dom.frame.className = "vis-legend";
              this.dom.frame.style.position = "absolute";
              this.dom.frame.style.top = "10px";
              this.dom.frame.style.display = "block";
              this.dom.textArea = document.createElement("div");
              this.dom.textArea.className = "vis-legend-text";
              this.dom.textArea.style.position = "relative";
              this.dom.textArea.style.top = "0px";
              this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              this.svg.style.position = "absolute";
              this.svg.style.top = "0px";
              this.svg.style.width = this.options.iconSize + 5 + "px";
              this.svg.style.height = "100%";
              this.dom.frame.appendChild(this.svg);
              this.dom.frame.appendChild(this.dom.textArea);
            };
            Legend.prototype.hide = function() {
              if (this.dom.frame.parentNode) {
                this.dom.frame.parentNode.removeChild(this.dom.frame);
              }
            };
            Legend.prototype.show = function() {
              if (!this.dom.frame.parentNode) {
                this.body.dom.center.appendChild(this.dom.frame);
              }
            };
            Legend.prototype.setOptions = function(options) {
              var fields = ["enabled", "orientation", "icons", "left", "right"];
              util.selectiveDeepExtend(fields, this.options, options);
            };
            Legend.prototype.redraw = function() {
              var activeGroups = 0;
              var groupArray = (0, _keys2["default"])(this.groups);
              groupArray.sort(function(a, b) {
                return a < b ? -1 : 1;
              });
              for (var i = 0; i < groupArray.length; i++) {
                var groupId = groupArray[i];
                if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
                  activeGroups++;
                }
              }
              if (this.options[this.side].visible == false || this.amountOfGroups == 0 || this.options.enabled == false || activeGroups == 0) {
                this.hide();
              } else {
                this.show();
                if (this.options[this.side].position == "top-left" || this.options[this.side].position == "bottom-left") {
                  this.dom.frame.style.left = "4px";
                  this.dom.frame.style.textAlign = "left";
                  this.dom.textArea.style.textAlign = "left";
                  this.dom.textArea.style.left = this.options.iconSize + 15 + "px";
                  this.dom.textArea.style.right = "";
                  this.svg.style.left = "0px";
                  this.svg.style.right = "";
                } else {
                  this.dom.frame.style.right = "4px";
                  this.dom.frame.style.textAlign = "right";
                  this.dom.textArea.style.textAlign = "right";
                  this.dom.textArea.style.right = this.options.iconSize + 15 + "px";
                  this.dom.textArea.style.left = "";
                  this.svg.style.right = "0px";
                  this.svg.style.left = "";
                }
                if (this.options[this.side].position == "top-left" || this.options[this.side].position == "top-right") {
                  this.dom.frame.style.top = 4 - Number(this.body.dom.center.style.top.replace("px", "")) + "px";
                  this.dom.frame.style.bottom = "";
                } else {
                  var scrollableHeight = this.body.domProps.center.height - this.body.domProps.centerContainer.height;
                  this.dom.frame.style.bottom = 4 + scrollableHeight + Number(this.body.dom.center.style.top.replace("px", "")) + "px";
                  this.dom.frame.style.top = "";
                }
                if (this.options.icons == false) {
                  this.dom.frame.style.width = this.dom.textArea.offsetWidth + 10 + "px";
                  this.dom.textArea.style.right = "";
                  this.dom.textArea.style.left = "";
                  this.svg.style.width = "0px";
                } else {
                  this.dom.frame.style.width = this.options.iconSize + 15 + this.dom.textArea.offsetWidth + 10 + "px";
                  this.drawLegendIcons();
                }
                var content = "";
                for (i = 0; i < groupArray.length; i++) {
                  groupId = groupArray[i];
                  if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
                    content += this.groups[groupId].content + "<br />";
                  }
                }
                this.dom.textArea.innerHTML = content;
                this.dom.textArea.style.lineHeight = 0.75 * this.options.iconSize + this.options.iconSpacing + "px";
              }
            };
            Legend.prototype.drawLegendIcons = function() {
              if (this.dom.frame.parentNode) {
                var groupArray = (0, _keys2["default"])(this.groups);
                groupArray.sort(function(a, b) {
                  return a < b ? -1 : 1;
                });
                DOMutil.resetElements(this.svgElements);
                var padding = window.getComputedStyle(this.dom.frame).paddingTop;
                var iconOffset = Number(padding.replace("px", ""));
                var x = iconOffset;
                var iconWidth = this.options.iconSize;
                var iconHeight = 0.75 * this.options.iconSize;
                var y = iconOffset + 0.5 * iconHeight + 3;
                this.svg.style.width = iconWidth + 5 + iconOffset + "px";
                for (var i = 0; i < groupArray.length; i++) {
                  var groupId = groupArray[i];
                  if (this.groups[groupId].visible == true && (this.linegraphOptions.visibility[groupId] === void 0 || this.linegraphOptions.visibility[groupId] == true)) {
                    this.groups[groupId].getLegend(iconWidth, iconHeight, this.framework, x, y);
                    y += iconHeight + this.options.iconSpacing;
                  }
                }
              }
            };
            module2.exports = Legend;
          },
          /* 113 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var string = "string";
            var bool = "boolean";
            var number = "number";
            var array = "array";
            var date = "date";
            var object = "object";
            var dom = "dom";
            var moment = "moment";
            var any = "any";
            var allOptions = {
              configure: {
                enabled: { "boolean": bool },
                filter: { "boolean": bool, "function": "function" },
                container: { dom },
                __type__: { object, "boolean": bool, "function": "function" }
              },
              //globals :
              yAxisOrientation: { string: ["left", "right"] },
              defaultGroup: { string },
              sort: { "boolean": bool },
              sampling: { "boolean": bool },
              stack: { "boolean": bool },
              graphHeight: { string, number },
              shaded: {
                enabled: { "boolean": bool },
                orientation: { string: ["bottom", "top", "zero", "group"] },
                // top, bottom, zero, group
                groupId: { object },
                __type__: { "boolean": bool, object }
              },
              style: { string: ["line", "bar", "points"] },
              // line, bar
              barChart: {
                width: { number },
                minWidth: { number },
                sideBySide: { "boolean": bool },
                align: { string: ["left", "center", "right"] },
                __type__: { object }
              },
              interpolation: {
                enabled: { "boolean": bool },
                parametrization: { string: ["centripetal", "chordal", "uniform"] },
                // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
                alpha: { number },
                __type__: { object, "boolean": bool }
              },
              drawPoints: {
                enabled: { "boolean": bool },
                onRender: { "function": "function" },
                size: { number },
                style: { string: ["square", "circle"] },
                // square, circle
                __type__: { object, "boolean": bool, "function": "function" }
              },
              dataAxis: {
                showMinorLabels: { "boolean": bool },
                showMajorLabels: { "boolean": bool },
                icons: { "boolean": bool },
                width: { string, number },
                visible: { "boolean": bool },
                alignZeros: { "boolean": bool },
                left: {
                  range: { min: { number, "undefined": "undefined" }, max: { number, "undefined": "undefined" }, __type__: { object } },
                  format: { "function": "function" },
                  title: { text: { string, number, "undefined": "undefined" }, style: { string, "undefined": "undefined" }, __type__: { object } },
                  __type__: { object }
                },
                right: {
                  range: { min: { number, "undefined": "undefined" }, max: { number, "undefined": "undefined" }, __type__: { object } },
                  format: { "function": "function" },
                  title: { text: { string, number, "undefined": "undefined" }, style: { string, "undefined": "undefined" }, __type__: { object } },
                  __type__: { object }
                },
                __type__: { object }
              },
              legend: {
                enabled: { "boolean": bool },
                icons: { "boolean": bool },
                left: {
                  visible: { "boolean": bool },
                  position: { string: ["top-right", "bottom-right", "top-left", "bottom-left"] },
                  __type__: { object }
                },
                right: {
                  visible: { "boolean": bool },
                  position: { string: ["top-right", "bottom-right", "top-left", "bottom-left"] },
                  __type__: { object }
                },
                __type__: { object, "boolean": bool }
              },
              groups: {
                visibility: { any },
                __type__: { object }
              },
              autoResize: { "boolean": bool },
              throttleRedraw: { number },
              // TODO: DEPRICATED see https://github.com/almende/vis/issues/2511
              clickToUse: { "boolean": bool },
              end: { number, date, string, moment },
              format: {
                minorLabels: {
                  millisecond: { string, "undefined": "undefined" },
                  second: { string, "undefined": "undefined" },
                  minute: { string, "undefined": "undefined" },
                  hour: { string, "undefined": "undefined" },
                  weekday: { string, "undefined": "undefined" },
                  day: { string, "undefined": "undefined" },
                  month: { string, "undefined": "undefined" },
                  year: { string, "undefined": "undefined" },
                  __type__: { object }
                },
                majorLabels: {
                  millisecond: { string, "undefined": "undefined" },
                  second: { string, "undefined": "undefined" },
                  minute: { string, "undefined": "undefined" },
                  hour: { string, "undefined": "undefined" },
                  weekday: { string, "undefined": "undefined" },
                  day: { string, "undefined": "undefined" },
                  month: { string, "undefined": "undefined" },
                  year: { string, "undefined": "undefined" },
                  __type__: { object }
                },
                __type__: { object }
              },
              moment: { "function": "function" },
              height: { string, number },
              hiddenDates: {
                start: { date, number, string, moment },
                end: { date, number, string, moment },
                repeat: { string },
                __type__: { object, array }
              },
              locale: { string },
              locales: {
                __any__: { any },
                __type__: { object }
              },
              max: { date, number, string, moment },
              maxHeight: { number, string },
              maxMinorChars: { number },
              min: { date, number, string, moment },
              minHeight: { number, string },
              moveable: { "boolean": bool },
              multiselect: { "boolean": bool },
              orientation: { string },
              showCurrentTime: { "boolean": bool },
              showMajorLabels: { "boolean": bool },
              showMinorLabels: { "boolean": bool },
              start: { date, number, string, moment },
              timeAxis: {
                scale: { string, "undefined": "undefined" },
                step: { number, "undefined": "undefined" },
                __type__: { object }
              },
              width: { string, number },
              zoomable: { "boolean": bool },
              zoomKey: { string: ["ctrlKey", "altKey", "metaKey", ""] },
              zoomMax: { number },
              zoomMin: { number },
              zIndex: { number },
              __type__: { object }
            };
            var configureOptions = {
              global: {
                //yAxisOrientation: ['left','right'], // TDOO: enable as soon as Grahp2d doesn't crash when changing this on the fly
                sort: true,
                sampling: true,
                stack: false,
                shaded: {
                  enabled: false,
                  orientation: ["zero", "top", "bottom", "group"]
                  // zero, top, bottom
                },
                style: ["line", "bar", "points"],
                // line, bar
                barChart: {
                  width: [50, 5, 100, 5],
                  minWidth: [50, 5, 100, 5],
                  sideBySide: false,
                  align: ["left", "center", "right"]
                  // left, center, right
                },
                interpolation: {
                  enabled: true,
                  parametrization: ["centripetal", "chordal", "uniform"]
                  // uniform (alpha = 0.0), chordal (alpha = 1.0), centripetal (alpha = 0.5)
                },
                drawPoints: {
                  enabled: true,
                  size: [6, 2, 30, 1],
                  style: ["square", "circle"]
                  // square, circle
                },
                dataAxis: {
                  showMinorLabels: true,
                  showMajorLabels: true,
                  icons: false,
                  width: [40, 0, 200, 1],
                  visible: true,
                  alignZeros: true,
                  left: {
                    //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
                    //format: function (value) {return value;},
                    title: { text: "", style: "" }
                  },
                  right: {
                    //range: {min:'undefined': 'undefined'ined,max:'undefined': 'undefined'ined},
                    //format: function (value) {return value;},
                    title: { text: "", style: "" }
                  }
                },
                legend: {
                  enabled: false,
                  icons: true,
                  left: {
                    visible: true,
                    position: ["top-right", "bottom-right", "top-left", "bottom-left"]
                    // top/bottom - left,right
                  },
                  right: {
                    visible: true,
                    position: ["top-right", "bottom-right", "top-left", "bottom-left"]
                    // top/bottom - left,right
                  }
                },
                autoResize: true,
                clickToUse: false,
                end: "",
                format: {
                  minorLabels: {
                    millisecond: "SSS",
                    second: "s",
                    minute: "HH:mm",
                    hour: "HH:mm",
                    weekday: "ddd D",
                    day: "D",
                    month: "MMM",
                    year: "YYYY"
                  },
                  majorLabels: {
                    millisecond: "HH:mm:ss",
                    second: "D MMMM HH:mm",
                    minute: "ddd D MMMM",
                    hour: "ddd D MMMM",
                    weekday: "MMMM YYYY",
                    day: "MMMM YYYY",
                    month: "YYYY",
                    year: ""
                  }
                },
                height: "",
                locale: "",
                max: "",
                maxHeight: "",
                maxMinorChars: [7, 0, 20, 1],
                min: "",
                minHeight: "",
                moveable: true,
                orientation: ["both", "bottom", "top"],
                showCurrentTime: false,
                showMajorLabels: true,
                showMinorLabels: true,
                start: "",
                width: "100%",
                zoomable: true,
                zoomKey: ["ctrlKey", "altKey", "metaKey", ""],
                zoomMax: [31536e10, 10, 31536e10, 1],
                zoomMin: [10, 10, 31536e10, 1],
                zIndex: 0
              }
            };
            exports2.allOptions = allOptions;
            exports2.configureOptions = configureOptions;
          },
          /* 114 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _create = __webpack_require__(29);
            var _create2 = _interopRequireDefault(_create);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function parseDOT(data) {
              dot = data;
              return parseGraph();
            }
            var NODE_ATTR_MAPPING = {
              "fontsize": "font.size",
              "fontcolor": "font.color",
              "labelfontcolor": "font.color",
              "fontname": "font.face",
              "color": ["color.border", "color.background"],
              "fillcolor": "color.background",
              "tooltip": "title",
              "labeltooltip": "title"
            };
            var EDGE_ATTR_MAPPING = (0, _create2["default"])(NODE_ATTR_MAPPING);
            EDGE_ATTR_MAPPING.color = "color.color";
            EDGE_ATTR_MAPPING.style = "dashes";
            var TOKENTYPE = {
              NULL: 0,
              DELIMITER: 1,
              IDENTIFIER: 2,
              UNKNOWN: 3
            };
            var DELIMITERS = {
              "{": true,
              "}": true,
              "[": true,
              "]": true,
              ";": true,
              "=": true,
              ",": true,
              "->": true,
              "--": true
            };
            var dot = "";
            var index = 0;
            var c = "";
            var token = "";
            var tokenType = TOKENTYPE.NULL;
            function first() {
              index = 0;
              c = dot.charAt(0);
            }
            function next() {
              index++;
              c = dot.charAt(index);
            }
            function nextPreview() {
              return dot.charAt(index + 1);
            }
            var regexAlphaNumeric = /[a-zA-Z_0-9.:#]/;
            function isAlphaNumeric(c2) {
              return regexAlphaNumeric.test(c2);
            }
            function merge(a, b) {
              if (!a) {
                a = {};
              }
              if (b) {
                for (var name in b) {
                  if (b.hasOwnProperty(name)) {
                    a[name] = b[name];
                  }
                }
              }
              return a;
            }
            function setValue(obj, path, value) {
              var keys = path.split(".");
              var o = obj;
              while (keys.length) {
                var key = keys.shift();
                if (keys.length) {
                  if (!o[key]) {
                    o[key] = {};
                  }
                  o = o[key];
                } else {
                  o[key] = value;
                }
              }
            }
            function addNode(graph, node) {
              var i, len;
              var current = null;
              var graphs = [graph];
              var root = graph;
              while (root.parent) {
                graphs.push(root.parent);
                root = root.parent;
              }
              if (root.nodes) {
                for (i = 0, len = root.nodes.length; i < len; i++) {
                  if (node.id === root.nodes[i].id) {
                    current = root.nodes[i];
                    break;
                  }
                }
              }
              if (!current) {
                current = {
                  id: node.id
                };
                if (graph.node) {
                  current.attr = merge(current.attr, graph.node);
                }
              }
              for (i = graphs.length - 1; i >= 0; i--) {
                var g = graphs[i];
                if (!g.nodes) {
                  g.nodes = [];
                }
                if (g.nodes.indexOf(current) === -1) {
                  g.nodes.push(current);
                }
              }
              if (node.attr) {
                current.attr = merge(current.attr, node.attr);
              }
            }
            function addEdge(graph, edge) {
              if (!graph.edges) {
                graph.edges = [];
              }
              graph.edges.push(edge);
              if (graph.edge) {
                var attr = merge({}, graph.edge);
                edge.attr = merge(attr, edge.attr);
              }
            }
            function createEdge(graph, from, to, type, attr) {
              var edge = {
                from,
                to,
                type
              };
              if (graph.edge) {
                edge.attr = merge({}, graph.edge);
              }
              edge.attr = merge(edge.attr || {}, attr);
              return edge;
            }
            function getToken() {
              tokenType = TOKENTYPE.NULL;
              token = "";
              while (c === " " || c === "	" || c === "\n" || c === "\r") {
                next();
              }
              do {
                var isComment = false;
                if (c === "#") {
                  var i = index - 1;
                  while (dot.charAt(i) === " " || dot.charAt(i) === "	") {
                    i--;
                  }
                  if (dot.charAt(i) === "\n" || dot.charAt(i) === "") {
                    while (c != "" && c != "\n") {
                      next();
                    }
                    isComment = true;
                  }
                }
                if (c === "/" && nextPreview() === "/") {
                  while (c != "" && c != "\n") {
                    next();
                  }
                  isComment = true;
                }
                if (c === "/" && nextPreview() === "*") {
                  while (c != "") {
                    if (c === "*" && nextPreview() === "/") {
                      next();
                      next();
                      break;
                    } else {
                      next();
                    }
                  }
                  isComment = true;
                }
                while (c === " " || c === "	" || c === "\n" || c === "\r") {
                  next();
                }
              } while (isComment);
              if (c === "") {
                tokenType = TOKENTYPE.DELIMITER;
                return;
              }
              var c2 = c + nextPreview();
              if (DELIMITERS[c2]) {
                tokenType = TOKENTYPE.DELIMITER;
                token = c2;
                next();
                next();
                return;
              }
              if (DELIMITERS[c]) {
                tokenType = TOKENTYPE.DELIMITER;
                token = c;
                next();
                return;
              }
              if (isAlphaNumeric(c) || c === "-") {
                token += c;
                next();
                while (isAlphaNumeric(c)) {
                  token += c;
                  next();
                }
                if (token === "false") {
                  token = false;
                } else if (token === "true") {
                  token = true;
                } else if (!isNaN(Number(token))) {
                  token = Number(token);
                }
                tokenType = TOKENTYPE.IDENTIFIER;
                return;
              }
              if (c === '"') {
                next();
                while (c != "" && (c != '"' || c === '"' && nextPreview() === '"')) {
                  if (c === '"') {
                    token += c;
                    next();
                  } else if (c === "\\" && nextPreview() === "n") {
                    token += "\n";
                    next();
                  } else {
                    token += c;
                  }
                  next();
                }
                if (c != '"') {
                  throw newSyntaxError('End of string " expected');
                }
                next();
                tokenType = TOKENTYPE.IDENTIFIER;
                return;
              }
              tokenType = TOKENTYPE.UNKNOWN;
              while (c != "") {
                token += c;
                next();
              }
              throw new SyntaxError('Syntax error in part "' + chop(token, 30) + '"');
            }
            function parseGraph() {
              var graph = {};
              first();
              getToken();
              if (token === "strict") {
                graph.strict = true;
                getToken();
              }
              if (token === "graph" || token === "digraph") {
                graph.type = token;
                getToken();
              }
              if (tokenType === TOKENTYPE.IDENTIFIER) {
                graph.id = token;
                getToken();
              }
              if (token != "{") {
                throw newSyntaxError("Angle bracket { expected");
              }
              getToken();
              parseStatements(graph);
              if (token != "}") {
                throw newSyntaxError("Angle bracket } expected");
              }
              getToken();
              if (token !== "") {
                throw newSyntaxError("End of file expected");
              }
              getToken();
              delete graph.node;
              delete graph.edge;
              delete graph.graph;
              return graph;
            }
            function parseStatements(graph) {
              while (token !== "" && token != "}") {
                parseStatement(graph);
                if (token === ";") {
                  getToken();
                }
              }
            }
            function parseStatement(graph) {
              var subgraph = parseSubgraph(graph);
              if (subgraph) {
                parseEdge(graph, subgraph);
                return;
              }
              var attr = parseAttributeStatement(graph);
              if (attr) {
                return;
              }
              if (tokenType != TOKENTYPE.IDENTIFIER) {
                throw newSyntaxError("Identifier expected");
              }
              var id = token;
              getToken();
              if (token === "=") {
                getToken();
                if (tokenType != TOKENTYPE.IDENTIFIER) {
                  throw newSyntaxError("Identifier expected");
                }
                graph[id] = token;
                getToken();
              } else {
                parseNodeStatement(graph, id);
              }
            }
            function parseSubgraph(graph) {
              var subgraph = null;
              if (token === "subgraph") {
                subgraph = {};
                subgraph.type = "subgraph";
                getToken();
                if (tokenType === TOKENTYPE.IDENTIFIER) {
                  subgraph.id = token;
                  getToken();
                }
              }
              if (token === "{") {
                getToken();
                if (!subgraph) {
                  subgraph = {};
                }
                subgraph.parent = graph;
                subgraph.node = graph.node;
                subgraph.edge = graph.edge;
                subgraph.graph = graph.graph;
                parseStatements(subgraph);
                if (token != "}") {
                  throw newSyntaxError("Angle bracket } expected");
                }
                getToken();
                delete subgraph.node;
                delete subgraph.edge;
                delete subgraph.graph;
                delete subgraph.parent;
                if (!graph.subgraphs) {
                  graph.subgraphs = [];
                }
                graph.subgraphs.push(subgraph);
              }
              return subgraph;
            }
            function parseAttributeStatement(graph) {
              if (token === "node") {
                getToken();
                graph.node = parseAttributeList();
                return "node";
              } else if (token === "edge") {
                getToken();
                graph.edge = parseAttributeList();
                return "edge";
              } else if (token === "graph") {
                getToken();
                graph.graph = parseAttributeList();
                return "graph";
              }
              return null;
            }
            function parseNodeStatement(graph, id) {
              var node = {
                id
              };
              var attr = parseAttributeList();
              if (attr) {
                node.attr = attr;
              }
              addNode(graph, node);
              parseEdge(graph, id);
            }
            function parseEdge(graph, from) {
              while (token === "->" || token === "--") {
                var to;
                var type = token;
                getToken();
                var subgraph = parseSubgraph(graph);
                if (subgraph) {
                  to = subgraph;
                } else {
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Identifier or subgraph expected");
                  }
                  to = token;
                  addNode(graph, {
                    id: to
                  });
                  getToken();
                }
                var attr = parseAttributeList();
                var edge = createEdge(graph, from, to, type, attr);
                addEdge(graph, edge);
                from = to;
              }
            }
            function parseAttributeList() {
              var attr = null;
              var edgeStyles = {
                "dashed": true,
                "solid": false,
                "dotted": [1, 5]
              };
              while (token === "[") {
                getToken();
                attr = {};
                while (token !== "" && token != "]") {
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Attribute name expected");
                  }
                  var name = token;
                  getToken();
                  if (token != "=") {
                    throw newSyntaxError("Equal sign = expected");
                  }
                  getToken();
                  if (tokenType != TOKENTYPE.IDENTIFIER) {
                    throw newSyntaxError("Attribute value expected");
                  }
                  var value = token;
                  if (name === "style") {
                    value = edgeStyles[value];
                  }
                  setValue(attr, name, value);
                  getToken();
                  if (token == ",") {
                    getToken();
                  }
                }
                if (token != "]") {
                  throw newSyntaxError("Bracket ] expected");
                }
                getToken();
              }
              return attr;
            }
            function newSyntaxError(message) {
              return new SyntaxError(message + ', got "' + chop(token, 30) + '" (char ' + index + ")");
            }
            function chop(text, maxLength) {
              return text.length <= maxLength ? text : text.substr(0, 27) + "...";
            }
            function forEach2(array1, array2, fn) {
              if (Array.isArray(array1)) {
                array1.forEach(function(elem1) {
                  if (Array.isArray(array2)) {
                    array2.forEach(function(elem2) {
                      fn(elem1, elem2);
                    });
                  } else {
                    fn(elem1, array2);
                  }
                });
              } else {
                if (Array.isArray(array2)) {
                  array2.forEach(function(elem2) {
                    fn(array1, elem2);
                  });
                } else {
                  fn(array1, array2);
                }
              }
            }
            function setProp(object, path, value) {
              var names = path.split(".");
              var prop = names.pop();
              var obj = object;
              for (var i = 0; i < names.length; i++) {
                var name = names[i];
                if (!(name in obj)) {
                  obj[name] = {};
                }
                obj = obj[name];
              }
              obj[prop] = value;
              return object;
            }
            function convertAttr(attr, mapping) {
              var converted = {};
              for (var prop in attr) {
                if (attr.hasOwnProperty(prop)) {
                  var visProp = mapping[prop];
                  if (Array.isArray(visProp)) {
                    visProp.forEach(function(visPropI) {
                      setProp(converted, visPropI, attr[prop]);
                    });
                  } else if (typeof visProp === "string") {
                    setProp(converted, visProp, attr[prop]);
                  } else {
                    setProp(converted, prop, attr[prop]);
                  }
                }
              }
              return converted;
            }
            function DOTToGraph(data) {
              var dotData = parseDOT(data);
              var graphData = {
                nodes: [],
                edges: [],
                options: {}
              };
              if (dotData.nodes) {
                dotData.nodes.forEach(function(dotNode) {
                  var graphNode = {
                    id: dotNode.id,
                    label: String(dotNode.label || dotNode.id)
                  };
                  merge(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));
                  if (graphNode.image) {
                    graphNode.shape = "image";
                  }
                  graphData.nodes.push(graphNode);
                });
              }
              if (dotData.edges) {
                var convertEdge = function convertEdge2(dotEdge) {
                  var graphEdge = {
                    from: dotEdge.from,
                    to: dotEdge.to
                  };
                  merge(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));
                  graphEdge.arrows = dotEdge.type === "->" ? "to" : void 0;
                  return graphEdge;
                };
                dotData.edges.forEach(function(dotEdge) {
                  var from, to;
                  if (dotEdge.from instanceof Object) {
                    from = dotEdge.from.nodes;
                  } else {
                    from = {
                      id: dotEdge.from
                    };
                  }
                  if (dotEdge.to instanceof Object) {
                    to = dotEdge.to.nodes;
                  } else {
                    to = {
                      id: dotEdge.to
                    };
                  }
                  if (dotEdge.from instanceof Object && dotEdge.from.edges) {
                    dotEdge.from.edges.forEach(function(subEdge) {
                      var graphEdge = convertEdge(subEdge);
                      graphData.edges.push(graphEdge);
                    });
                  }
                  forEach2(from, to, function(from2, to2) {
                    var subEdge = createEdge(graphData, from2.id, to2.id, dotEdge.type, dotEdge.attr);
                    var graphEdge = convertEdge(subEdge);
                    graphData.edges.push(graphEdge);
                  });
                  if (dotEdge.to instanceof Object && dotEdge.to.edges) {
                    dotEdge.to.edges.forEach(function(subEdge) {
                      var graphEdge = convertEdge(subEdge);
                      graphData.edges.push(graphEdge);
                    });
                  }
                });
              }
              if (dotData.attr) {
                graphData.options = dotData.attr;
              }
              return graphData;
            }
            exports2.parseDOT = parseDOT;
            exports2.DOTToGraph = DOTToGraph;
          },
          /* 115 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function parseGephi(gephiJSON, optionsObj) {
              var edges = [];
              var nodes = [];
              var options = {
                edges: {
                  inheritColor: false
                },
                nodes: {
                  fixed: false,
                  parseColor: false
                }
              };
              if (optionsObj !== void 0) {
                if (optionsObj.fixed !== void 0) {
                  options.nodes.fixed = optionsObj.fixed;
                }
                if (optionsObj.parseColor !== void 0) {
                  options.nodes.parseColor = optionsObj.parseColor;
                }
                if (optionsObj.inheritColor !== void 0) {
                  options.edges.inheritColor = optionsObj.inheritColor;
                }
              }
              var gEdges = gephiJSON.edges;
              var gNodes = gephiJSON.nodes;
              for (var i = 0; i < gEdges.length; i++) {
                var edge = {};
                var gEdge = gEdges[i];
                edge["id"] = gEdge.id;
                edge["from"] = gEdge.source;
                edge["to"] = gEdge.target;
                edge["attributes"] = gEdge.attributes;
                edge["label"] = gEdge.label;
                edge["title"] = gEdge.attributes !== void 0 ? gEdge.attributes.title : void 0;
                if (gEdge["type"] === "Directed") {
                  edge["arrows"] = "to";
                }
                if (gEdge.color && options.inheritColor === false) {
                  edge["color"] = gEdge.color;
                }
                edges.push(edge);
              }
              for (var j = 0; j < gNodes.length; j++) {
                var node = {};
                var gNode = gNodes[j];
                node["id"] = gNode.id;
                node["attributes"] = gNode.attributes;
                node["x"] = gNode.x;
                node["y"] = gNode.y;
                node["label"] = gNode.label;
                node["title"] = gNode.attributes !== void 0 ? gNode.attributes.title : gNode.title;
                if (options.nodes.parseColor === true) {
                  node["color"] = gNode.color;
                } else {
                  node["color"] = gNode.color !== void 0 ? { background: gNode.color, border: gNode.color, highlight: { background: gNode.color, border: gNode.color }, hover: { background: gNode.color, border: gNode.color } } : void 0;
                }
                node["size"] = gNode.size;
                node["fixed"] = options.nodes.fixed && gNode.x !== void 0 && gNode.y !== void 0;
                nodes.push(node);
              }
              return { nodes, edges };
            }
            exports2.parseGephi = parseGephi;
          },
          /* 116 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _CachedImage = __webpack_require__(185);
            var _CachedImage2 = _interopRequireDefault(_CachedImage);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Images = function() {
              function Images2(callback) {
                (0, _classCallCheck3["default"])(this, Images2);
                this.images = {};
                this.imageBroken = {};
                this.callback = callback;
              }
              (0, _createClass3["default"])(Images2, [{
                key: "_tryloadBrokenUrl",
                value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {
                  if (url === void 0 || imageToLoadBrokenUrlOn === void 0) return;
                  if (brokenUrl === void 0) {
                    console.warn("No broken url image defined");
                    return;
                  }
                  imageToLoadBrokenUrlOn.onerror = function() {
                    console.error("Could not load brokenImage:", brokenUrl);
                  };
                  imageToLoadBrokenUrlOn.image.src = brokenUrl;
                }
                /**
                 *
                 * @param {vis.Image} imageToRedrawWith
                 * @private
                 */
              }, {
                key: "_redrawWithImage",
                value: function _redrawWithImage(imageToRedrawWith) {
                  if (this.callback) {
                    this.callback(imageToRedrawWith);
                  }
                }
                /**
                 * @param {string} url          Url of the image
                 * @param {string} brokenUrl    Url of an image to use if the url image is not found
                 * @return {Image} img          The image object
                 */
              }, {
                key: "load",
                value: function load(url, brokenUrl) {
                  var _this = this;
                  var cachedImage = this.images[url];
                  if (cachedImage) return cachedImage;
                  var img = new _CachedImage2["default"]();
                  this.images[url] = img;
                  img.image.onload = function() {
                    _this._fixImageCoordinates(img.image);
                    img.init();
                    _this._redrawWithImage(img);
                  };
                  img.image.onerror = function() {
                    console.error("Could not load image:", url);
                    _this._tryloadBrokenUrl(url, brokenUrl, img);
                  };
                  img.image.src = url;
                  return img;
                }
                /**
                 * IE11 fix -- thanks dponch!
                 *
                 * Local helper function
                 * @param {vis.Image} imageToCache
                 * @private
                 */
              }, {
                key: "_fixImageCoordinates",
                value: function _fixImageCoordinates(imageToCache) {
                  if (imageToCache.width === 0) {
                    document.body.appendChild(imageToCache);
                    imageToCache.width = imageToCache.offsetWidth;
                    imageToCache.height = imageToCache.offsetHeight;
                    document.body.removeChild(imageToCache);
                  }
                }
              }]);
              return Images2;
            }();
            exports2["default"] = Images;
          },
          /* 117 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var ComponentUtil = __webpack_require__(48)["default"];
            var LabelSplitter = __webpack_require__(191)["default"];
            var multiFontStyle = ["bold", "ital", "boldital", "mono"];
            var Label = function() {
              function Label2(body, options) {
                var edgelabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                (0, _classCallCheck3["default"])(this, Label2);
                this.body = body;
                this.pointToSelf = false;
                this.baseSize = void 0;
                this.fontOptions = {};
                this.setOptions(options);
                this.size = { top: 0, left: 0, width: 0, height: 0, yLine: 0 };
                this.isEdgeLabel = edgelabel;
              }
              (0, _createClass3["default"])(Label2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.elementOptions = options;
                  this.initFontOptions(options.font);
                  if (ComponentUtil.isValidLabel(options.label)) {
                    this.labelDirty = true;
                  } else {
                    options.label = "";
                  }
                  if (options.font !== void 0 && options.font !== null) {
                    if (typeof options.font === "string") {
                      this.baseSize = this.fontOptions.size;
                    } else if ((0, _typeof3["default"])(options.font) === "object") {
                      var size = options.font.size;
                      if (size !== void 0) {
                        this.baseSize = size;
                      }
                    }
                  }
                }
                /**
                 * Init the font Options structure.
                 *
                 * Member fontOptions serves as an accumulator for the current font options.
                 * As such, it needs to be completely separated from the node options.
                 *
                 * @param {Object} newFontOptions the new font options to process
                 * @private
                 */
              }, {
                key: "initFontOptions",
                value: function initFontOptions(newFontOptions) {
                  var _this = this;
                  util.forEach(multiFontStyle, function(style) {
                    _this.fontOptions[style] = {};
                  });
                  if (Label2.parseFontString(this.fontOptions, newFontOptions)) {
                    this.fontOptions.vadjust = 0;
                    return;
                  }
                  util.forEach(newFontOptions, function(prop, n) {
                    if (prop !== void 0 && prop !== null && (typeof prop === "undefined" ? "undefined" : (0, _typeof3["default"])(prop)) !== "object") {
                      _this.fontOptions[n] = prop;
                    }
                  });
                }
                /**
                 * If in-variable is a string, parse it as a font specifier.
                 *
                 * Note that following is not done here and have to be done after the call:
                 * - No number conversion (size)
                 * - Not all font options are set (vadjust, mod)
                 *
                 * @param {Object} outOptions  out-parameter, object in which to store the parse results (if any)
                 * @param {Object} inOptions  font options to parse
                 * @return {boolean} true if font parsed as string, false otherwise
                 * @static
                 */
              }, {
                key: "constrain",
                /**
                 * Set the width and height constraints based on 'nearest' value
                 *
                 * @param {Array} pile array of option objects to consider
                 * @returns {object} the actual constraint values to use
                 * @private
                 */
                value: function constrain(pile) {
                  var fontOptions = {
                    constrainWidth: false,
                    maxWdt: -1,
                    minWdt: -1,
                    constrainHeight: false,
                    minHgt: -1,
                    valign: "middle"
                  };
                  var widthConstraint = util.topMost(pile, "widthConstraint");
                  if (typeof widthConstraint === "number") {
                    fontOptions.maxWdt = Number(widthConstraint);
                    fontOptions.minWdt = Number(widthConstraint);
                  } else if ((typeof widthConstraint === "undefined" ? "undefined" : (0, _typeof3["default"])(widthConstraint)) === "object") {
                    var widthConstraintMaximum = util.topMost(pile, ["widthConstraint", "maximum"]);
                    if (typeof widthConstraintMaximum === "number") {
                      fontOptions.maxWdt = Number(widthConstraintMaximum);
                    }
                    var widthConstraintMinimum = util.topMost(pile, ["widthConstraint", "minimum"]);
                    if (typeof widthConstraintMinimum === "number") {
                      fontOptions.minWdt = Number(widthConstraintMinimum);
                    }
                  }
                  var heightConstraint = util.topMost(pile, "heightConstraint");
                  if (typeof heightConstraint === "number") {
                    fontOptions.minHgt = Number(heightConstraint);
                  } else if ((typeof heightConstraint === "undefined" ? "undefined" : (0, _typeof3["default"])(heightConstraint)) === "object") {
                    var heightConstraintMinimum = util.topMost(pile, ["heightConstraint", "minimum"]);
                    if (typeof heightConstraintMinimum === "number") {
                      fontOptions.minHgt = Number(heightConstraintMinimum);
                    }
                    var heightConstraintValign = util.topMost(pile, ["heightConstraint", "valign"]);
                    if (typeof heightConstraintValign === "string") {
                      if (heightConstraintValign === "top" || heightConstraintValign === "bottom") {
                        fontOptions.valign = heightConstraintValign;
                      }
                    }
                  }
                  return fontOptions;
                }
                /**
                 * Set options and update internal state
                 *
                 * @param {Object} options  options to set
                 * @param {Array}  pile     array of option objects to consider for option 'chosen'
                 */
              }, {
                key: "update",
                value: function update(options, pile) {
                  this.setOptions(options, true);
                  this.propagateFonts(pile);
                  util.deepExtend(this.fontOptions, this.constrain(pile));
                  this.fontOptions.chooser = ComponentUtil.choosify("label", pile);
                }
                /**
                 * When margins are set in an element, adjust sizes is called to remove them
                 * from the width/height constraints. This must be done prior to label sizing.
                 *
                 * @param {{top: number, right: number, bottom: number, left: number}} margins
                 */
              }, {
                key: "adjustSizes",
                value: function adjustSizes(margins) {
                  var widthBias = margins ? margins.right + margins.left : 0;
                  if (this.fontOptions.constrainWidth) {
                    this.fontOptions.maxWdt -= widthBias;
                    this.fontOptions.minWdt -= widthBias;
                  }
                  var heightBias = margins ? margins.top + margins.bottom : 0;
                  if (this.fontOptions.constrainHeight) {
                    this.fontOptions.minHgt -= heightBias;
                  }
                }
                /////////////////////////////////////////////////////////
                // Methods for handling options piles
                // Eventually, these will be moved to a separate class
                /////////////////////////////////////////////////////////
                /**
                 * Add the font members of the passed list of option objects to the pile.
                 *
                 * @param {Pile} dstPile  pile of option objects add to 
                 * @param {Pile} srcPile  pile of option objects to take font options from
                 * @private
                 */
              }, {
                key: "addFontOptionsToPile",
                value: function addFontOptionsToPile(dstPile, srcPile) {
                  for (var i = 0; i < srcPile.length; ++i) {
                    this.addFontToPile(dstPile, srcPile[i]);
                  }
                }
                /**
                 * Add given font option object to the list of objects (the 'pile') to consider for determining
                 * multi-font option values.
                 *
                 * @param {Pile} pile  pile of option objects to use
                 * @param {object} options  instance to add to pile
                 * @private
                 */
              }, {
                key: "addFontToPile",
                value: function addFontToPile(pile, options) {
                  if (options === void 0) return;
                  if (options.font === void 0 || options.font === null) return;
                  var item = options.font;
                  pile.push(item);
                }
                /**
                 * Collect all own-property values from the font pile that aren't multi-font option objectss.
                 *
                 * @param {Pile} pile  pile of option objects to use
                 * @returns {object} object with all current own basic font properties
                 * @private
                 */
              }, {
                key: "getBasicOptions",
                value: function getBasicOptions(pile) {
                  var ret = {};
                  for (var n = 0; n < pile.length; ++n) {
                    var fontOptions = pile[n];
                    var tmpShorthand = {};
                    if (Label2.parseFontString(tmpShorthand, fontOptions)) {
                      fontOptions = tmpShorthand;
                    }
                    util.forEach(fontOptions, function(opt, name) {
                      if (opt === void 0) return;
                      if (ret.hasOwnProperty(name)) return;
                      if (multiFontStyle.indexOf(name) !== -1) {
                        ret[name] = {};
                      } else {
                        ret[name] = opt;
                      }
                    });
                  }
                  return ret;
                }
                /**
                 * Return the value for given option for the given multi-font.
                 *
                 * All available option objects are trawled in the set order to construct the option values.
                 *
                 * ---------------------------------------------------------------------
                 * ## Traversal of pile for multi-fonts
                 *
                 * The determination of multi-font option values is a special case, because any values not
                 * present in the multi-font options should by definition be taken from the main font options,
                 * i.e. from the current 'parent' object of the multi-font option.
                 *
                 * ### Search order for multi-fonts
                 *
                 * 'bold' used as example:
                 *
                 *   - search in option group 'bold' in local properties
                 *   - search in main font option group in local properties
                 *
                 * ---------------------------------------------------------------------
                 *
                 * @param {Pile} pile  pile of option objects to use
                 * @param {MultiFontStyle} multiName sub path for the multi-font
                 * @param {string} option  the option to search for, for the given multi-font
                 * @returns {string|number} the value for the given option
                 * @private
                 */
              }, {
                key: "getFontOption",
                value: function getFontOption(pile, multiName, option) {
                  var multiFont = void 0;
                  for (var n = 0; n < pile.length; ++n) {
                    var fontOptions = pile[n];
                    if (fontOptions.hasOwnProperty(multiName)) {
                      multiFont = fontOptions[multiName];
                      if (multiFont === void 0 || multiFont === null) continue;
                      var tmpShorthand = {};
                      if (Label2.parseFontString(tmpShorthand, multiFont)) {
                        multiFont = tmpShorthand;
                      }
                      if (multiFont.hasOwnProperty(option)) {
                        return multiFont[option];
                      }
                    }
                  }
                  if (this.fontOptions.hasOwnProperty(option)) {
                    return this.fontOptions[option];
                  }
                  throw new Error("Did not find value for multi-font for property: '" + option + "'");
                }
                /**
                 * Return all options values for the given multi-font.
                 *
                 * All available option objects are trawled in the set order to construct the option values.
                 *
                 * @param {Pile} pile  pile of option objects to use
                 * @param {MultiFontStyle} multiName sub path for the mod-font
                 * @returns {MultiFontOptions}
                 * @private
                 */
              }, {
                key: "getFontOptions",
                value: function getFontOptions(pile, multiName) {
                  var result = {};
                  var optionNames = ["color", "size", "face", "mod", "vadjust"];
                  for (var i = 0; i < optionNames.length; ++i) {
                    var mod = optionNames[i];
                    result[mod] = this.getFontOption(pile, multiName, mod);
                  }
                  return result;
                }
                /////////////////////////////////////////////////////////
                // End methods for handling options piles
                /////////////////////////////////////////////////////////
                /**
                 * Collapse the font options for the multi-font to single objects, from
                 * the chain of option objects passed (the 'pile').
                 *
                 * @param {Pile} pile  sequence of option objects to consider.
                 *                     First item in list assumed to be the newly set options.
                 */
              }, {
                key: "propagateFonts",
                value: function propagateFonts(pile) {
                  var _this2 = this;
                  var fontPile = [];
                  this.addFontOptionsToPile(fontPile, pile);
                  this.fontOptions = this.getBasicOptions(fontPile);
                  var _loop = function _loop2(i2) {
                    var mod = multiFontStyle[i2];
                    var modOptions = _this2.fontOptions[mod];
                    var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);
                    util.forEach(tmpMultiFontOptions, function(option, n) {
                      modOptions[n] = option;
                    });
                    modOptions.size = Number(modOptions.size);
                    modOptions.vadjust = Number(modOptions.vadjust);
                  };
                  for (var i = 0; i < multiFontStyle.length; ++i) {
                    _loop(i);
                  }
                }
                /**
                 * Main function. This is called from anything that wants to draw a label.
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x
                 * @param {number} y
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {string} [baseline='middle']
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover) {
                  var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
                  if (this.elementOptions.label === void 0) return;
                  var viewFontSize = this.fontOptions.size * this.body.view.scale;
                  if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;
                  if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {
                    viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;
                  }
                  this.calculateLabelSize(ctx, selected, hover, x, y, baseline);
                  this._drawBackground(ctx);
                  this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);
                }
                /**
                 * Draws the label background
                 * @param {CanvasRenderingContext2D} ctx
                 * @private
                 */
              }, {
                key: "_drawBackground",
                value: function _drawBackground(ctx) {
                  if (this.fontOptions.background !== void 0 && this.fontOptions.background !== "none") {
                    ctx.fillStyle = this.fontOptions.background;
                    var size = this.getSize();
                    ctx.fillRect(size.left, size.top, size.width, size.height);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x
                 * @param {number} y
                 * @param {string} [baseline='middle']
                 * @param {number} viewFontSize 
                 * @private
                 */
              }, {
                key: "_drawText",
                value: function _drawText(ctx, x, y) {
                  var baseline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "middle";
                  var viewFontSize = arguments[4];
                  var _setAlignment2 = this._setAlignment(ctx, x, y, baseline);
                  var _setAlignment3 = (0, _slicedToArray3["default"])(_setAlignment2, 2);
                  x = _setAlignment3[0];
                  y = _setAlignment3[1];
                  ctx.textAlign = "left";
                  x = x - this.size.width / 2;
                  if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {
                    if (this.fontOptions.valign === "top") {
                      y -= (this.size.height - this.size.labelHeight) / 2;
                    }
                    if (this.fontOptions.valign === "bottom") {
                      y += (this.size.height - this.size.labelHeight) / 2;
                    }
                  }
                  for (var i = 0; i < this.lineCount; i++) {
                    var line = this.lines[i];
                    if (line && line.blocks) {
                      var width = 0;
                      if (this.isEdgeLabel || this.fontOptions.align === "center") {
                        width += (this.size.width - line.width) / 2;
                      } else if (this.fontOptions.align === "right") {
                        width += this.size.width - line.width;
                      }
                      for (var j = 0; j < line.blocks.length; j++) {
                        var block = line.blocks[j];
                        ctx.font = block.font;
                        var _getColor2 = this._getColor(block.color, viewFontSize, block.strokeColor), _getColor3 = (0, _slicedToArray3["default"])(_getColor2, 2), fontColor = _getColor3[0], strokeColor = _getColor3[1];
                        if (block.strokeWidth > 0) {
                          ctx.lineWidth = block.strokeWidth;
                          ctx.strokeStyle = strokeColor;
                          ctx.lineJoin = "round";
                        }
                        ctx.fillStyle = fontColor;
                        if (block.strokeWidth > 0) {
                          ctx.strokeText(block.text, x + width, y + block.vadjust);
                        }
                        ctx.fillText(block.text, x + width, y + block.vadjust);
                        width += block.width;
                      }
                      y += line.height;
                    }
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x
                 * @param {number} y
                 * @param {string} baseline
                 * @returns {Array.<number>}
                 * @private
                 */
              }, {
                key: "_setAlignment",
                value: function _setAlignment(ctx, x, y, baseline) {
                  if (this.isEdgeLabel && this.fontOptions.align !== "horizontal" && this.pointToSelf === false) {
                    x = 0;
                    y = 0;
                    var lineMargin = 2;
                    if (this.fontOptions.align === "top") {
                      ctx.textBaseline = "alphabetic";
                      y -= 2 * lineMargin;
                    } else if (this.fontOptions.align === "bottom") {
                      ctx.textBaseline = "hanging";
                      y += 2 * lineMargin;
                    } else {
                      ctx.textBaseline = "middle";
                    }
                  } else {
                    ctx.textBaseline = baseline;
                  }
                  return [x, y];
                }
                /**
                 * fade in when relative scale is between threshold and threshold - 1.
                 * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
                 *
                 * @param {string} color  The font color to use
                 * @param {number} viewFontSize
                 * @param {string} initialStrokeColor
                 * @returns {Array.<string>} An array containing the font color and stroke color
                 * @private
                 */
              }, {
                key: "_getColor",
                value: function _getColor(color, viewFontSize, initialStrokeColor) {
                  var fontColor = color || "#000000";
                  var strokeColor = initialStrokeColor || "#ffffff";
                  if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {
                    var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));
                    fontColor = util.overrideOpacity(fontColor, opacity);
                    strokeColor = util.overrideOpacity(strokeColor, opacity);
                  }
                  return [fontColor, strokeColor];
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @returns {{width: number, height: number}}
                 */
              }, {
                key: "getTextSize",
                value: function getTextSize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  this._processLabel(ctx, selected, hover);
                  return {
                    width: this.size.width,
                    height: this.size.height,
                    lineCount: this.lineCount
                  };
                }
                /**
                 * Get the current dimensions of the label
                 *
                 * @return {rect}
                 */
              }, {
                key: "getSize",
                value: function getSize() {
                  var lineMargin = 2;
                  var x = this.size.left;
                  var y = this.size.top - 0.5 * lineMargin;
                  if (this.isEdgeLabel) {
                    var x2 = -this.size.width * 0.5;
                    switch (this.fontOptions.align) {
                      case "middle":
                        x = x2;
                        y = -this.size.height * 0.5;
                        break;
                      case "top":
                        x = x2;
                        y = -(this.size.height + lineMargin);
                        break;
                      case "bottom":
                        x = x2;
                        y = lineMargin;
                        break;
                    }
                  }
                  var ret = {
                    left: x,
                    top: y,
                    width: this.size.width,
                    height: this.size.height
                  };
                  return ret;
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {number} [x=0]
                 * @param {number} [y=0]
                 * @param {'middle'|'hanging'} [baseline='middle']
                 */
              }, {
                key: "calculateLabelSize",
                value: function calculateLabelSize(ctx, selected, hover) {
                  var x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  var y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
                  var baseline = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "middle";
                  this._processLabel(ctx, selected, hover);
                  this.size.left = x - this.size.width * 0.5;
                  this.size.top = y - this.size.height * 0.5;
                  this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;
                  if (baseline === "hanging") {
                    this.size.top += 0.5 * this.fontOptions.size;
                    this.size.top += 4;
                    this.size.yLine += 4;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {string} mod
                 * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
                 */
              }, {
                key: "getFormattingValues",
                value: function getFormattingValues(ctx, selected, hover, mod) {
                  var getValue = function getValue2(fontOptions, mod2, option) {
                    if (mod2 === "normal") {
                      if (option === "mod") return "";
                      return fontOptions[option];
                    }
                    if (fontOptions[mod2][option] !== void 0) {
                      return fontOptions[mod2][option];
                    } else {
                      return fontOptions[option];
                    }
                  };
                  var values = {
                    color: getValue(this.fontOptions, mod, "color"),
                    size: getValue(this.fontOptions, mod, "size"),
                    face: getValue(this.fontOptions, mod, "face"),
                    mod: getValue(this.fontOptions, mod, "mod"),
                    vadjust: getValue(this.fontOptions, mod, "vadjust"),
                    strokeWidth: this.fontOptions.strokeWidth,
                    strokeColor: this.fontOptions.strokeColor
                  };
                  if (selected || hover) {
                    if (mod === "normal" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {
                      values.mod = "bold";
                    } else {
                      if (typeof this.fontOptions.chooser === "function") {
                        this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);
                      }
                    }
                  }
                  var fontString = "";
                  if (values.mod !== void 0 && values.mod !== "") {
                    fontString += values.mod + " ";
                  }
                  fontString += values.size + "px " + values.face;
                  ctx.font = fontString.replace(/"/g, "");
                  values.font = ctx.font;
                  values.height = values.size;
                  return values;
                }
                /**
                 *
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @returns {boolean}
                 */
              }, {
                key: "differentState",
                value: function differentState(selected, hover) {
                  return selected !== this.selectedState || hover !== this.hoverState;
                }
                /**
                 * This explodes the passed text into lines and determines the width, height and number of lines.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {string} inText  the text to explode
                 * @returns {{width, height, lines}|*}
                 * @private
                 */
              }, {
                key: "_processLabelText",
                value: function _processLabelText(ctx, selected, hover, inText) {
                  var splitter = new LabelSplitter(ctx, this, selected, hover);
                  return splitter.process(inText);
                }
                /**
                 * This explodes the label string into lines and sets the width, height and number of lines.
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @private
                 */
              }, {
                key: "_processLabel",
                value: function _processLabel(ctx, selected, hover) {
                  if (this.labelDirty === false && !this.differentState(selected, hover)) return;
                  var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);
                  if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {
                    state.width = this.fontOptions.minWdt;
                  }
                  this.size.labelHeight = state.height;
                  if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {
                    state.height = this.fontOptions.minHgt;
                  }
                  this.lines = state.lines;
                  this.lineCount = state.lines.length;
                  this.size.width = state.width;
                  this.size.height = state.height;
                  this.selectedState = selected;
                  this.hoverState = hover;
                  this.labelDirty = false;
                }
                /**
                 * Check if this label is visible
                 *
                 * @return {boolean} true if this label will be show, false otherwise
                 */
              }, {
                key: "visible",
                value: function visible() {
                  if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === void 0) {
                    return false;
                  }
                  var viewFontSize = this.fontOptions.size * this.body.view.scale;
                  if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {
                    return false;
                  }
                  return true;
                }
              }], [{
                key: "parseFontString",
                value: function parseFontString(outOptions, inOptions) {
                  if (!inOptions || typeof inOptions !== "string") return false;
                  var newOptionsArray = inOptions.split(" ");
                  outOptions.size = newOptionsArray[0].replace("px", "");
                  outOptions.face = newOptionsArray[1];
                  outOptions.color = newOptionsArray[2];
                  return true;
                }
              }]);
              return Label2;
            }();
            exports2["default"] = Label;
          },
          /* 118 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var EndPoints = __webpack_require__(119)["default"];
            var EdgeBase = function() {
              function EdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, EdgeBase2);
                this.body = body;
                this.labelModule = labelModule;
                this.options = {};
                this.setOptions(options);
                this.colorDirty = true;
                this.color = {};
                this.selectionWidth = 2;
                this.hoverWidth = 1.5;
                this.fromPoint = this.from;
                this.toPoint = this.to;
              }
              (0, _createClass3["default"])(EdgeBase2, [{
                key: "connect",
                value: function connect() {
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                }
                /**
                 *
                 * @returns {boolean} always false
                 */
              }, {
                key: "cleanup",
                value: function cleanup() {
                  return false;
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  this.id = this.options.id;
                }
                /**
                 * Redraw a edge as a line
                 * Draw this edge in the given canvas
                 * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
                 *
                 * @param {CanvasRenderingContext2D}   ctx
                 * @param {Array} values
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {Node} viaNode
                 * @private
                 */
              }, {
                key: "drawLine",
                value: function drawLine(ctx, values, selected, hover, viaNode) {
                  ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
                  ctx.lineWidth = values.width;
                  if (values.dashes !== false) {
                    this._drawDashedLine(ctx, values, viaNode);
                  } else {
                    this._drawLine(ctx, values, viaNode);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D}   ctx
                 * @param {Array} values
                 * @param {Node} viaNode
                 * @param {{x: number, y: number}} [fromPoint]
                 * @param {{x: number, y: number}} [toPoint]
                 * @private
                 */
              }, {
                key: "_drawLine",
                value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {
                  if (this.from != this.to) {
                    this._line(ctx, values, viaNode, fromPoint, toPoint);
                  } else {
                    var _getCircleData2 = this._getCircleData(ctx), _getCircleData3 = (0, _slicedToArray3["default"])(_getCircleData2, 3), x = _getCircleData3[0], y = _getCircleData3[1], radius = _getCircleData3[2];
                    this._circle(ctx, values, x, y, radius);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Array} values
                 * @param {Node} viaNode
                 * @param {{x: number, y: number}} [fromPoint]  TODO: Remove in next major release
                 * @param {{x: number, y: number}} [toPoint]    TODO: Remove in next major release
                 * @private
                 */
              }, {
                key: "_drawDashedLine",
                value: function _drawDashedLine(ctx, values, viaNode, fromPoint, toPoint) {
                  ctx.lineCap = "round";
                  var pattern = [5, 5];
                  if (Array.isArray(values.dashes) === true) {
                    pattern = values.dashes;
                  }
                  if (ctx.setLineDash !== void 0) {
                    ctx.save();
                    ctx.setLineDash(pattern);
                    ctx.lineDashOffset = 0;
                    if (this.from != this.to) {
                      this._line(ctx, values, viaNode);
                    } else {
                      var _getCircleData4 = this._getCircleData(ctx), _getCircleData5 = (0, _slicedToArray3["default"])(_getCircleData4, 3), x = _getCircleData5[0], y = _getCircleData5[1], radius = _getCircleData5[2];
                      this._circle(ctx, values, x, y, radius);
                    }
                    ctx.setLineDash([0]);
                    ctx.lineDashOffset = 0;
                    ctx.restore();
                  } else {
                    if (this.from != this.to) {
                      ctx.dashedLine(this.from.x, this.from.y, this.to.x, this.to.y, pattern);
                    } else {
                      var _getCircleData6 = this._getCircleData(ctx), _getCircleData7 = (0, _slicedToArray3["default"])(_getCircleData6, 3), _x = _getCircleData7[0], _y = _getCircleData7[1], _radius = _getCircleData7[2];
                      this._circle(ctx, values, _x, _y, _radius);
                    }
                    this.enableShadow(ctx, values);
                    ctx.stroke();
                    this.disableShadow(ctx, values);
                  }
                }
                /**
                 *
                 * @param {Node} nearNode
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Object} options
                 * @returns {{x: number, y: number}}
                 */
              }, {
                key: "findBorderPosition",
                value: function findBorderPosition(nearNode, ctx, options) {
                  if (this.from != this.to) {
                    return this._findBorderPosition(nearNode, ctx, options);
                  } else {
                    return this._findBorderPositionCircle(nearNode, ctx, options);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @returns {{from: ({x: number, y: number, t: number}|*), to: ({x: number, y: number, t: number}|*)}}
                 */
              }, {
                key: "findBorderPositions",
                value: function findBorderPositions(ctx) {
                  var from = {};
                  var to = {};
                  if (this.from != this.to) {
                    from = this._findBorderPosition(this.from, ctx);
                    to = this._findBorderPosition(this.to, ctx);
                  } else {
                    var _getCircleData$slice = this._getCircleData(ctx).slice(0, 2), _getCircleData$slice2 = (0, _slicedToArray3["default"])(_getCircleData$slice, 2), x = _getCircleData$slice2[0], y = _getCircleData$slice2[1];
                    from = this._findBorderPositionCircle(this.from, ctx, { x, y, low: 0.25, high: 0.6, direction: -1 });
                    to = this._findBorderPositionCircle(this.from, ctx, { x, y, low: 0.6, high: 0.8, direction: 1 });
                  }
                  return { from, to };
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @returns {Array.<number>} x, y, radius
                 * @private
                 */
              }, {
                key: "_getCircleData",
                value: function _getCircleData(ctx) {
                  var x = void 0, y = void 0;
                  var node = this.from;
                  var radius = this.options.selfReferenceSize;
                  if (ctx !== void 0) {
                    if (node.shape.width === void 0) {
                      node.shape.resize(ctx);
                    }
                  }
                  if (node.shape.width > node.shape.height) {
                    x = node.x + node.shape.width * 0.5;
                    y = node.y - radius;
                  } else {
                    x = node.x + radius;
                    y = node.y - node.shape.height * 0.5;
                  }
                  return [x, y, radius];
                }
                /**
                 * Get a point on a circle
                 * @param {number} x
                 * @param {number} y
                 * @param {number} radius
                 * @param {number} percentage - Value between 0 (line start) and 1 (line end)
                 * @return {Object} point
                 * @private
                 */
              }, {
                key: "_pointOnCircle",
                value: function _pointOnCircle(x, y, radius, percentage) {
                  var angle = percentage * 2 * Math.PI;
                  return {
                    x: x + radius * Math.cos(angle),
                    y: y - radius * Math.sin(angle)
                  };
                }
                /**
                 * This function uses binary search to look for the point where the circle crosses the border of the node.
                 * @param {Node} node
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Object} options
                 * @returns {*}
                 * @private
                 */
              }, {
                key: "_findBorderPositionCircle",
                value: function _findBorderPositionCircle(node, ctx, options) {
                  var x = options.x;
                  var y = options.y;
                  var low = options.low;
                  var high = options.high;
                  var direction = options.direction;
                  var maxIterations = 10;
                  var iteration = 0;
                  var radius = this.options.selfReferenceSize;
                  var pos = void 0, angle = void 0, distanceToBorder = void 0, distanceToPoint = void 0, difference = void 0;
                  var threshold = 0.05;
                  var middle = (low + high) * 0.5;
                  while (low <= high && iteration < maxIterations) {
                    middle = (low + high) * 0.5;
                    pos = this._pointOnCircle(x, y, radius, middle);
                    angle = Math.atan2(node.y - pos.y, node.x - pos.x);
                    distanceToBorder = node.distanceToBorder(ctx, angle);
                    distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));
                    difference = distanceToBorder - distanceToPoint;
                    if (Math.abs(difference) < threshold) {
                      break;
                    } else if (difference > 0) {
                      if (direction > 0) {
                        low = middle;
                      } else {
                        high = middle;
                      }
                    } else {
                      if (direction > 0) {
                        high = middle;
                      } else {
                        low = middle;
                      }
                    }
                    iteration++;
                  }
                  pos.t = middle;
                  return pos;
                }
                /**
                 * Get the line width of the edge. Depends on width and whether one of the
                 * connected nodes is selected.
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @returns {number} width
                 * @private
                 */
              }, {
                key: "getLineWidth",
                value: function getLineWidth(selected, hover) {
                  if (selected === true) {
                    return Math.max(this.selectionWidth, 0.3 / this.body.view.scale);
                  } else {
                    if (hover === true) {
                      return Math.max(this.hoverWidth, 0.3 / this.body.view.scale);
                    } else {
                      return Math.max(this.options.width, 0.3 / this.body.view.scale);
                    }
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @param {boolean} selected - Unused
                 * @param {boolean} hover - Unused
                 * @returns {string}
                 */
              }, {
                key: "getColor",
                value: function getColor(ctx, values, selected, hover) {
                  if (values.inheritsColor !== false) {
                    if (values.inheritsColor === "both" && this.from.id !== this.to.id) {
                      var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
                      var fromColor = void 0, toColor = void 0;
                      fromColor = this.from.options.color.highlight.border;
                      toColor = this.to.options.color.highlight.border;
                      if (this.from.selected === false && this.to.selected === false) {
                        fromColor = util.overrideOpacity(this.from.options.color.border, values.opacity);
                        toColor = util.overrideOpacity(this.to.options.color.border, values.opacity);
                      } else if (this.from.selected === true && this.to.selected === false) {
                        toColor = this.to.options.color.border;
                      } else if (this.from.selected === false && this.to.selected === true) {
                        fromColor = this.from.options.color.border;
                      }
                      grd.addColorStop(0, fromColor);
                      grd.addColorStop(1, toColor);
                      return grd;
                    }
                    if (values.inheritsColor === "to") {
                      return util.overrideOpacity(this.to.options.color.border, values.opacity);
                    } else {
                      return util.overrideOpacity(this.from.options.color.border, values.opacity);
                    }
                  } else {
                    return util.overrideOpacity(values.color, values.opacity);
                  }
                }
                /**
                 * Draw a line from a node to itself, a circle
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Array} values
                 * @param {number} x
                 * @param {number} y
                 * @param {number} radius
                 * @private
                 */
              }, {
                key: "_circle",
                value: function _circle(ctx, values, x, y, radius) {
                  this.enableShadow(ctx, values);
                  ctx.beginPath();
                  ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
                /**
                 * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
                 * (x3,y3) is the point.
                 *
                 * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @param {Node} via
                 * @param {Array} values
                 * @returns {number}
                 */
              }, {
                key: "getDistanceToEdge",
                value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3, via, values) {
                  var returnValue = 0;
                  if (this.from != this.to) {
                    returnValue = this._getDistanceToEdge(x1, y1, x2, y2, x3, y3, via);
                  } else {
                    var _getCircleData8 = this._getCircleData(void 0), _getCircleData9 = (0, _slicedToArray3["default"])(_getCircleData8, 3), x = _getCircleData9[0], y = _getCircleData9[1], radius = _getCircleData9[2];
                    var dx = x - x3;
                    var dy = y - y3;
                    returnValue = Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);
                  }
                  return returnValue;
                }
                /**
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToLine",
                value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {
                  var px = x2 - x1;
                  var py = y2 - y1;
                  var something = px * px + py * py;
                  var u = ((x3 - x1) * px + (y3 - y1) * py) / something;
                  if (u > 1) {
                    u = 1;
                  } else if (u < 0) {
                    u = 0;
                  }
                  var x = x1 + u * px;
                  var y = y1 + u * py;
                  var dx = x - x3;
                  var dy = y - y3;
                  return Math.sqrt(dx * dx + dy * dy);
                }
                /**
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {string} position
                 * @param {Node} viaNode
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {Array} values
                 * @returns {{point: *, core: {x: number, y: number}, angle: *, length: number, type: *}}
                 */
              }, {
                key: "getArrowData",
                value: function getArrowData(ctx, position, viaNode, selected, hover, values) {
                  var angle = void 0;
                  var arrowPoint = void 0;
                  var node1 = void 0;
                  var node2 = void 0;
                  var guideOffset = void 0;
                  var scaleFactor = void 0;
                  var type = void 0;
                  var lineWidth = values.width;
                  if (position === "from") {
                    node1 = this.from;
                    node2 = this.to;
                    guideOffset = 0.1;
                    scaleFactor = values.fromArrowScale;
                    type = values.fromArrowType;
                  } else if (position === "to") {
                    node1 = this.to;
                    node2 = this.from;
                    guideOffset = -0.1;
                    scaleFactor = values.toArrowScale;
                    type = values.toArrowType;
                  } else {
                    node1 = this.to;
                    node2 = this.from;
                    scaleFactor = values.middleArrowScale;
                    type = values.middleArrowType;
                  }
                  if (node1 != node2) {
                    if (position !== "middle") {
                      if (this.options.smooth.enabled === true) {
                        arrowPoint = this.findBorderPosition(node1, ctx, { via: viaNode });
                        var guidePos = this.getPoint(Math.max(0, Math.min(1, arrowPoint.t + guideOffset)), viaNode);
                        angle = Math.atan2(arrowPoint.y - guidePos.y, arrowPoint.x - guidePos.x);
                      } else {
                        angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                        arrowPoint = this.findBorderPosition(node1, ctx);
                      }
                    } else {
                      angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                      arrowPoint = this.getPoint(0.5, viaNode);
                    }
                  } else {
                    var _getCircleData10 = this._getCircleData(ctx), _getCircleData11 = (0, _slicedToArray3["default"])(_getCircleData10, 3), x = _getCircleData11[0], y = _getCircleData11[1], radius = _getCircleData11[2];
                    if (position === "from") {
                      arrowPoint = this.findBorderPosition(this.from, ctx, { x, y, low: 0.25, high: 0.6, direction: -1 });
                      angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;
                    } else if (position === "to") {
                      arrowPoint = this.findBorderPosition(this.from, ctx, { x, y, low: 0.6, high: 1, direction: 1 });
                      angle = arrowPoint.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;
                    } else {
                      arrowPoint = this._pointOnCircle(x, y, radius, 0.175);
                      angle = 3.9269908169872414;
                    }
                  }
                  if (position === "middle" && scaleFactor < 0) lineWidth *= -1;
                  var length = 15 * scaleFactor + 3 * lineWidth;
                  var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);
                  var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);
                  var arrowCore = { x: xi, y: yi };
                  return { point: arrowPoint, core: arrowCore, angle, length, type };
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {Object} arrowData
                 */
              }, {
                key: "drawArrowHead",
                value: function drawArrowHead(ctx, values, selected, hover, arrowData) {
                  ctx.strokeStyle = this.getColor(ctx, values, selected, hover);
                  ctx.fillStyle = ctx.strokeStyle;
                  ctx.lineWidth = values.width;
                  EndPoints.draw(ctx, arrowData);
                  this.enableShadow(ctx, values);
                  ctx.fill();
                  this.disableShadow(ctx, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "enableShadow",
                value: function enableShadow(ctx, values) {
                  if (values.shadow === true) {
                    ctx.shadowColor = values.shadowColor;
                    ctx.shadowBlur = values.shadowSize;
                    ctx.shadowOffsetX = values.shadowX;
                    ctx.shadowOffsetY = values.shadowY;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "disableShadow",
                value: function disableShadow(ctx, values) {
                  if (values.shadow === true) {
                    ctx.shadowColor = "rgba(0,0,0,0)";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                  }
                }
              }]);
              return EdgeBase2;
            }();
            exports2["default"] = EdgeBase;
          },
          /* 119 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var EndPoint = function() {
              function EndPoint2() {
                (0, _classCallCheck3["default"])(this, EndPoint2);
              }
              (0, _createClass3["default"])(EndPoint2, null, [{
                key: "transform",
                /**
                 * Apply transformation on points for display.
                 *
                 * The following is done:
                 * - rotate by the specified angle
                 * - multiply the (normalized) coordinates by the passed length
                 * - offset by the target coordinates
                 *
                 * @param {Array<Point>} points
                 * @param {ArrowData} arrowData
                 * @static
                 */
                value: function transform(points, arrowData) {
                  if (!(points instanceof Array)) {
                    points = [points];
                  }
                  var x = arrowData.point.x;
                  var y = arrowData.point.y;
                  var angle = arrowData.angle;
                  var length = arrowData.length;
                  for (var i = 0; i < points.length; ++i) {
                    var p = points[i];
                    var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);
                    var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);
                    p.x = x + length * xt;
                    p.y = y + length * yt;
                  }
                }
                /**
                 * Draw a closed path using the given real coordinates.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Array.<Point>} points
                 * @static
                 */
              }, {
                key: "drawPath",
                value: function drawPath(ctx, points) {
                  ctx.beginPath();
                  ctx.moveTo(points[0].x, points[0].y);
                  for (var i = 1; i < points.length; ++i) {
                    ctx.lineTo(points[i].x, points[i].y);
                  }
                  ctx.closePath();
                }
              }]);
              return EndPoint2;
            }();
            var Arrow = function(_EndPoint) {
              (0, _inherits3["default"])(Arrow2, _EndPoint);
              function Arrow2() {
                (0, _classCallCheck3["default"])(this, Arrow2);
                return (0, _possibleConstructorReturn3["default"])(this, (Arrow2.__proto__ || (0, _getPrototypeOf2["default"])(Arrow2)).apply(this, arguments));
              }
              (0, _createClass3["default"])(Arrow2, null, [{
                key: "draw",
                /**
                 * Draw this shape at the end of a line.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {ArrowData} arrowData
                 * @static
                 */
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0 }, { x: -1, y: 0.3 }, { x: -0.9, y: 0 }, { x: -1, y: -0.3 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Arrow2;
            }(EndPoint);
            var Circle = function() {
              function Circle2() {
                (0, _classCallCheck3["default"])(this, Circle2);
              }
              (0, _createClass3["default"])(Circle2, null, [{
                key: "draw",
                /**
                 * Draw this shape at the end of a line.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {ArrowData} arrowData
                 * @static
                 */
                value: function draw(ctx, arrowData) {
                  var point = { x: -0.4, y: 0 };
                  EndPoint.transform(point, arrowData);
                  ctx.circle(point.x, point.y, arrowData.length * 0.4);
                }
              }]);
              return Circle2;
            }();
            var Bar = function() {
              function Bar2() {
                (0, _classCallCheck3["default"])(this, Bar2);
              }
              (0, _createClass3["default"])(Bar2, null, [{
                key: "draw",
                /**
                 * Draw this shape at the end of a line.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {ArrowData} arrowData
                 * @static
                 */
                value: function draw(ctx, arrowData) {
                  var points = [{ x: 0, y: 0.5 }, { x: 0, y: -0.5 }, { x: -0.15, y: -0.5 }, { x: -0.15, y: 0.5 }];
                  EndPoint.transform(points, arrowData);
                  EndPoint.drawPath(ctx, points);
                }
              }]);
              return Bar2;
            }();
            var EndPoints = function() {
              function EndPoints2() {
                (0, _classCallCheck3["default"])(this, EndPoints2);
              }
              (0, _createClass3["default"])(EndPoints2, null, [{
                key: "draw",
                /**
                 * Draw an endpoint
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {ArrowData} arrowData
                 * @static
                 */
                value: function draw(ctx, arrowData) {
                  var type;
                  if (arrowData.type) {
                    type = arrowData.type.toLowerCase();
                  }
                  switch (type) {
                    case "circle":
                      Circle.draw(ctx, arrowData);
                      break;
                    case "bar":
                      Bar.draw(ctx, arrowData);
                      break;
                    case "arrow":
                    // fall-through
                    default:
                      Arrow.draw(ctx, arrowData);
                  }
                }
              }]);
              return EndPoints2;
            }();
            exports2["default"] = EndPoints;
          },
          /* 120 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BarnesHutSolver = function() {
              function BarnesHutSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, BarnesHutSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.barnesHutTree;
                this.setOptions(options);
                this.randomSeed = 5;
              }
              (0, _createClass3["default"])(BarnesHutSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                  this.thetaInversed = 1 / this.options.theta;
                  this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));
                }
                /**
                 *
                 * @returns {number} random integer
                 */
              }, {
                key: "seededRandom",
                value: function seededRandom() {
                  var x = Math.sin(this.randomSeed++) * 1e4;
                  return x - Math.floor(x);
                }
                /**
                 * This function calculates the forces the nodes apply on each other based on a gravitational model.
                 * The Barnes Hut method is used to speed up this N-body simulation.
                 *
                 * @private
                 */
              }, {
                key: "solve",
                value: function solve() {
                  if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {
                    var node = void 0;
                    var nodes = this.body.nodes;
                    var nodeIndices = this.physicsBody.physicsNodeIndices;
                    var nodeCount = nodeIndices.length;
                    var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);
                    this.barnesHutTree = barnesHutTree;
                    for (var i = 0; i < nodeCount; i++) {
                      node = nodes[nodeIndices[i]];
                      if (node.options.mass > 0) {
                        this._getForceContributions(barnesHutTree.root, node);
                      }
                    }
                  }
                }
                /**
                 * @param {Object} parentBranch
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_getForceContributions",
                value: function _getForceContributions(parentBranch, node) {
                  this._getForceContribution(parentBranch.children.NW, node);
                  this._getForceContribution(parentBranch.children.NE, node);
                  this._getForceContribution(parentBranch.children.SW, node);
                  this._getForceContribution(parentBranch.children.SE, node);
                }
                /**
                 * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
                 * If a region contains a single node, we check if it is not itself, then we apply the force.
                 *
                 * @param {Object} parentBranch
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_getForceContribution",
                value: function _getForceContribution(parentBranch, node) {
                  if (parentBranch.childrenCount > 0) {
                    var dx = void 0, dy = void 0, distance = void 0;
                    dx = parentBranch.centerOfMass.x - node.x;
                    dy = parentBranch.centerOfMass.y - node.y;
                    distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance * parentBranch.calcSize > this.thetaInversed) {
                      this._calculateForces(distance, dx, dy, node, parentBranch);
                    } else {
                      if (parentBranch.childrenCount === 4) {
                        this._getForceContributions(parentBranch, node);
                      } else {
                        if (parentBranch.children.data.id != node.id) {
                          this._calculateForces(distance, dx, dy, node, parentBranch);
                        }
                      }
                    }
                  }
                }
                /**
                 * Calculate the forces based on the distance.
                 *
                 * @param {number} distance
                 * @param {number} dx
                 * @param {number} dy
                 * @param {Node} node
                 * @param {Object} parentBranch
                 * @private
                 */
              }, {
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, node, parentBranch) {
                  if (distance === 0) {
                    distance = 0.1;
                    dx = distance;
                  }
                  if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
                    distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
                  }
                  var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);
                  var fx = dx * gravityForce;
                  var fy = dy * gravityForce;
                  this.physicsBody.forces[node.id].x += fx;
                  this.physicsBody.forces[node.id].y += fy;
                }
                /**
                 * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
                 *
                 * @param {Array.<Node>} nodes
                 * @param {Array.<number>} nodeIndices
                 * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
                 * @private
                 */
              }, {
                key: "_formBarnesHutTree",
                value: function _formBarnesHutTree(nodes, nodeIndices) {
                  var node = void 0;
                  var nodeCount = nodeIndices.length;
                  var minX = nodes[nodeIndices[0]].x;
                  var minY = nodes[nodeIndices[0]].y;
                  var maxX = nodes[nodeIndices[0]].x;
                  var maxY = nodes[nodeIndices[0]].y;
                  for (var i = 1; i < nodeCount; i++) {
                    var _node = nodes[nodeIndices[i]];
                    var x = _node.x;
                    var y = _node.y;
                    if (_node.options.mass > 0) {
                      if (x < minX) {
                        minX = x;
                      }
                      if (x > maxX) {
                        maxX = x;
                      }
                      if (y < minY) {
                        minY = y;
                      }
                      if (y > maxY) {
                        maxY = y;
                      }
                    }
                  }
                  var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY);
                  if (sizeDiff > 0) {
                    minY -= 0.5 * sizeDiff;
                    maxY += 0.5 * sizeDiff;
                  } else {
                    minX += 0.5 * sizeDiff;
                    maxX -= 0.5 * sizeDiff;
                  }
                  var minimumTreeSize = 1e-5;
                  var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));
                  var halfRootSize = 0.5 * rootSize;
                  var centerX = 0.5 * (minX + maxX), centerY = 0.5 * (minY + maxY);
                  var barnesHutTree = {
                    root: {
                      centerOfMass: { x: 0, y: 0 },
                      mass: 0,
                      range: {
                        minX: centerX - halfRootSize,
                        maxX: centerX + halfRootSize,
                        minY: centerY - halfRootSize,
                        maxY: centerY + halfRootSize
                      },
                      size: rootSize,
                      calcSize: 1 / rootSize,
                      children: { data: null },
                      maxWidth: 0,
                      level: 0,
                      childrenCount: 4
                    }
                  };
                  this._splitBranch(barnesHutTree.root);
                  for (var _i = 0; _i < nodeCount; _i++) {
                    node = nodes[nodeIndices[_i]];
                    if (node.options.mass > 0) {
                      this._placeInTree(barnesHutTree.root, node);
                    }
                  }
                  return barnesHutTree;
                }
                /**
                 * this updates the mass of a branch. this is increased by adding a node.
                 *
                 * @param {Object} parentBranch
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_updateBranchMass",
                value: function _updateBranchMass(parentBranch, node) {
                  var centerOfMass = parentBranch.centerOfMass;
                  var totalMass = parentBranch.mass + node.options.mass;
                  var totalMassInv = 1 / totalMass;
                  centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;
                  centerOfMass.x *= totalMassInv;
                  centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;
                  centerOfMass.y *= totalMassInv;
                  parentBranch.mass = totalMass;
                  var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);
                  parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;
                }
                /**
                 * determine in which branch the node will be placed.
                 *
                 * @param {Object} parentBranch
                 * @param {Node} node
                 * @param {boolean} skipMassUpdate
                 * @private
                 */
              }, {
                key: "_placeInTree",
                value: function _placeInTree(parentBranch, node, skipMassUpdate) {
                  if (skipMassUpdate != true || skipMassUpdate === void 0) {
                    this._updateBranchMass(parentBranch, node);
                  }
                  var range = parentBranch.children.NW.range;
                  var region = void 0;
                  if (range.maxX > node.x) {
                    if (range.maxY > node.y) {
                      region = "NW";
                    } else {
                      region = "SW";
                    }
                  } else {
                    if (range.maxY > node.y) {
                      region = "NE";
                    } else {
                      region = "SE";
                    }
                  }
                  this._placeInRegion(parentBranch, node, region);
                }
                /**
                 * actually place the node in a region (or branch)
                 *
                 * @param {Object} parentBranch
                 * @param {Node} node
                 * @param {'NW'| 'NE' | 'SW' | 'SE'} region
                 * @private
                 */
              }, {
                key: "_placeInRegion",
                value: function _placeInRegion(parentBranch, node, region) {
                  var children = parentBranch.children[region];
                  switch (children.childrenCount) {
                    case 0:
                      children.children.data = node;
                      children.childrenCount = 1;
                      this._updateBranchMass(children, node);
                      break;
                    case 1:
                      if (children.children.data.x === node.x && children.children.data.y === node.y) {
                        node.x += this.seededRandom();
                        node.y += this.seededRandom();
                      } else {
                        this._splitBranch(children);
                        this._placeInTree(children, node);
                      }
                      break;
                    case 4:
                      this._placeInTree(children, node);
                      break;
                  }
                }
                /**
                 * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
                 * after the split is complete.
                 *
                 * @param {Object} parentBranch
                 * @private
                 */
              }, {
                key: "_splitBranch",
                value: function _splitBranch(parentBranch) {
                  var containedNode = null;
                  if (parentBranch.childrenCount === 1) {
                    containedNode = parentBranch.children.data;
                    parentBranch.mass = 0;
                    parentBranch.centerOfMass.x = 0;
                    parentBranch.centerOfMass.y = 0;
                  }
                  parentBranch.childrenCount = 4;
                  parentBranch.children.data = null;
                  this._insertRegion(parentBranch, "NW");
                  this._insertRegion(parentBranch, "NE");
                  this._insertRegion(parentBranch, "SW");
                  this._insertRegion(parentBranch, "SE");
                  if (containedNode != null) {
                    this._placeInTree(parentBranch, containedNode);
                  }
                }
                /**
                 * This function subdivides the region into four new segments.
                 * Specifically, this inserts a single new segment.
                 * It fills the children section of the parentBranch
                 *
                 * @param {Object} parentBranch
                 * @param {'NW'| 'NE' | 'SW' | 'SE'} region
                 * @private
                 */
              }, {
                key: "_insertRegion",
                value: function _insertRegion(parentBranch, region) {
                  var minX = void 0, maxX = void 0, minY = void 0, maxY = void 0;
                  var childSize = 0.5 * parentBranch.size;
                  switch (region) {
                    case "NW":
                      minX = parentBranch.range.minX;
                      maxX = parentBranch.range.minX + childSize;
                      minY = parentBranch.range.minY;
                      maxY = parentBranch.range.minY + childSize;
                      break;
                    case "NE":
                      minX = parentBranch.range.minX + childSize;
                      maxX = parentBranch.range.maxX;
                      minY = parentBranch.range.minY;
                      maxY = parentBranch.range.minY + childSize;
                      break;
                    case "SW":
                      minX = parentBranch.range.minX;
                      maxX = parentBranch.range.minX + childSize;
                      minY = parentBranch.range.minY + childSize;
                      maxY = parentBranch.range.maxY;
                      break;
                    case "SE":
                      minX = parentBranch.range.minX + childSize;
                      maxX = parentBranch.range.maxX;
                      minY = parentBranch.range.minY + childSize;
                      maxY = parentBranch.range.maxY;
                      break;
                  }
                  parentBranch.children[region] = {
                    centerOfMass: { x: 0, y: 0 },
                    mass: 0,
                    range: { minX, maxX, minY, maxY },
                    size: 0.5 * parentBranch.size,
                    calcSize: 2 * parentBranch.calcSize,
                    children: { data: null },
                    maxWidth: 0,
                    level: parentBranch.level + 1,
                    childrenCount: 0
                  };
                }
                //---------------------------  DEBUGGING BELOW  ---------------------------//
                /**
                 * This function is for debugging purposed, it draws the tree.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {string} color
                 * @private
                 */
              }, {
                key: "_debug",
                value: function _debug(ctx, color) {
                  if (this.barnesHutTree !== void 0) {
                    ctx.lineWidth = 1;
                    this._drawBranch(this.barnesHutTree.root, ctx, color);
                  }
                }
                /**
                 * This function is for debugging purposes. It draws the branches recursively.
                 *
                 * @param {Object} branch
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {string} color
                 * @private
                 */
              }, {
                key: "_drawBranch",
                value: function _drawBranch(branch, ctx, color) {
                  if (color === void 0) {
                    color = "#FF0000";
                  }
                  if (branch.childrenCount === 4) {
                    this._drawBranch(branch.children.NW, ctx);
                    this._drawBranch(branch.children.NE, ctx);
                    this._drawBranch(branch.children.SE, ctx);
                    this._drawBranch(branch.children.SW, ctx);
                  }
                  ctx.strokeStyle = color;
                  ctx.beginPath();
                  ctx.moveTo(branch.range.minX, branch.range.minY);
                  ctx.lineTo(branch.range.maxX, branch.range.minY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.maxX, branch.range.minY);
                  ctx.lineTo(branch.range.maxX, branch.range.maxY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.maxX, branch.range.maxY);
                  ctx.lineTo(branch.range.minX, branch.range.maxY);
                  ctx.stroke();
                  ctx.beginPath();
                  ctx.moveTo(branch.range.minX, branch.range.maxY);
                  ctx.lineTo(branch.range.minX, branch.range.minY);
                  ctx.stroke();
                }
              }]);
              return BarnesHutSolver2;
            }();
            exports2["default"] = BarnesHutSolver;
          },
          /* 121 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CentralGravitySolver = function() {
              function CentralGravitySolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, CentralGravitySolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(CentralGravitySolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 * Calculates forces for each node
                 */
              }, {
                key: "solve",
                value: function solve() {
                  var dx = void 0, dy = void 0, distance = void 0, node = void 0;
                  var nodes = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    node = nodes[nodeId];
                    dx = -node.x;
                    dy = -node.y;
                    distance = Math.sqrt(dx * dx + dy * dy);
                    this._calculateForces(distance, dx, dy, forces, node);
                  }
                }
                /**
                 * Calculate the forces based on the distance.
                 * @param {number} distance
                 * @param {number} dx
                 * @param {number} dy
                 * @param {Object<Node.id, vis.Node>} forces
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, forces, node) {
                  var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;
                  forces[node.id].x = dx * gravityForce;
                  forces[node.id].y = dy * gravityForce;
                }
              }]);
              return CentralGravitySolver2;
            }();
            exports2["default"] = CentralGravitySolver;
          },
          /* 122 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var string = "string";
            var bool = "boolean";
            var number = "number";
            var array = "array";
            var object = "object";
            var dom = "dom";
            var any = "any";
            var endPoints = ["arrow", "circle", "bar"];
            var allOptions = {
              configure: {
                enabled: { boolean: bool },
                filter: { boolean: bool, string, array, "function": "function" },
                container: { dom },
                showButton: { boolean: bool },
                __type__: { object, boolean: bool, string, array, "function": "function" }
              },
              edges: {
                arrows: {
                  to: { enabled: { boolean: bool }, scaleFactor: { number }, type: { string: endPoints }, __type__: { object, boolean: bool } },
                  middle: { enabled: { boolean: bool }, scaleFactor: { number }, type: { string: endPoints }, __type__: { object, boolean: bool } },
                  from: { enabled: { boolean: bool }, scaleFactor: { number }, type: { string: endPoints }, __type__: { object, boolean: bool } },
                  __type__: { string: ["from", "to", "middle"], object }
                },
                arrowStrikethrough: { boolean: bool },
                chosen: {
                  label: { boolean: bool, "function": "function" },
                  edge: { boolean: bool, "function": "function" },
                  __type__: { object, boolean: bool }
                },
                color: {
                  color: { string },
                  highlight: { string },
                  hover: { string },
                  inherit: { string: ["from", "to", "both"], boolean: bool },
                  opacity: { number },
                  __type__: { object, string }
                },
                dashes: { boolean: bool, array },
                font: {
                  color: { string },
                  size: { number },
                  // px
                  face: { string },
                  background: { string },
                  strokeWidth: { number },
                  // px
                  strokeColor: { string },
                  align: { string: ["horizontal", "top", "middle", "bottom"] },
                  vadjust: { number },
                  multi: { boolean: bool, string },
                  bold: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  boldital: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  ital: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  mono: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                hidden: { boolean: bool },
                hoverWidth: { "function": "function", number },
                label: { string, "undefined": "undefined" },
                labelHighlightBold: { boolean: bool },
                length: { number, "undefined": "undefined" },
                physics: { boolean: bool },
                scaling: {
                  min: { number },
                  max: { number },
                  label: {
                    enabled: { boolean: bool },
                    min: { number },
                    max: { number },
                    maxVisible: { number },
                    drawThreshold: { number },
                    __type__: { object, boolean: bool }
                  },
                  customScalingFunction: { "function": "function" },
                  __type__: { object }
                },
                selectionWidth: { "function": "function", number },
                selfReferenceSize: { number },
                shadow: {
                  enabled: { boolean: bool },
                  color: { string },
                  size: { number },
                  x: { number },
                  y: { number },
                  __type__: { object, boolean: bool }
                },
                smooth: {
                  enabled: { boolean: bool },
                  type: { string: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"] },
                  roundness: { number },
                  forceDirection: { string: ["horizontal", "vertical", "none"], boolean: bool },
                  __type__: { object, boolean: bool }
                },
                title: { string, "undefined": "undefined" },
                width: { number },
                widthConstraint: {
                  maximum: { number },
                  __type__: { object, boolean: bool, number }
                },
                value: { number, "undefined": "undefined" },
                __type__: { object }
              },
              groups: {
                useDefaultGroups: { boolean: bool },
                __any__: "get from nodes, will be overwritten below",
                __type__: { object }
              },
              interaction: {
                dragNodes: { boolean: bool },
                dragView: { boolean: bool },
                hideEdgesOnDrag: { boolean: bool },
                hideNodesOnDrag: { boolean: bool },
                hover: { boolean: bool },
                keyboard: {
                  enabled: { boolean: bool },
                  speed: { x: { number }, y: { number }, zoom: { number }, __type__: { object } },
                  bindToWindow: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                multiselect: { boolean: bool },
                navigationButtons: { boolean: bool },
                selectable: { boolean: bool },
                selectConnectedEdges: { boolean: bool },
                hoverConnectedEdges: { boolean: bool },
                tooltipDelay: { number },
                zoomView: { boolean: bool },
                __type__: { object }
              },
              layout: {
                randomSeed: { "undefined": "undefined", number },
                improvedLayout: { boolean: bool },
                hierarchical: {
                  enabled: { boolean: bool },
                  levelSeparation: { number },
                  nodeSpacing: { number },
                  treeSpacing: { number },
                  blockShifting: { boolean: bool },
                  edgeMinimization: { boolean: bool },
                  parentCentralization: { boolean: bool },
                  direction: { string: ["UD", "DU", "LR", "RL"] },
                  // UD, DU, LR, RL
                  sortMethod: { string: ["hubsize", "directed"] },
                  // hubsize, directed
                  __type__: { object, boolean: bool }
                },
                __type__: { object }
              },
              manipulation: {
                enabled: { boolean: bool },
                initiallyActive: { boolean: bool },
                addNode: { boolean: bool, "function": "function" },
                addEdge: { boolean: bool, "function": "function" },
                editNode: { "function": "function" },
                editEdge: {
                  editWithoutDrag: { "function": "function" },
                  __type__: { object, boolean: bool, "function": "function" }
                },
                deleteNode: { boolean: bool, "function": "function" },
                deleteEdge: { boolean: bool, "function": "function" },
                controlNodeStyle: "get from nodes, will be overwritten below",
                __type__: { object, boolean: bool }
              },
              nodes: {
                borderWidth: { number },
                borderWidthSelected: { number, "undefined": "undefined" },
                brokenImage: { string, "undefined": "undefined" },
                chosen: {
                  label: { boolean: bool, "function": "function" },
                  node: { boolean: bool, "function": "function" },
                  __type__: { object, boolean: bool }
                },
                color: {
                  border: { string },
                  background: { string },
                  highlight: {
                    border: { string },
                    background: { string },
                    __type__: { object, string }
                  },
                  hover: {
                    border: { string },
                    background: { string },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                fixed: {
                  x: { boolean: bool },
                  y: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                font: {
                  align: { string },
                  color: { string },
                  size: { number },
                  // px
                  face: { string },
                  background: { string },
                  strokeWidth: { number },
                  // px
                  strokeColor: { string },
                  vadjust: { number },
                  multi: { boolean: bool, string },
                  bold: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  boldital: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  ital: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  mono: {
                    color: { string },
                    size: { number },
                    // px
                    face: { string },
                    mod: { string },
                    vadjust: { number },
                    __type__: { object, string }
                  },
                  __type__: { object, string }
                },
                group: { string, number, "undefined": "undefined" },
                heightConstraint: {
                  minimum: { number },
                  valign: { string },
                  __type__: { object, boolean: bool, number }
                },
                hidden: { boolean: bool },
                icon: {
                  face: { string },
                  code: { string },
                  //'\uf007',
                  size: { number },
                  //50,
                  color: { string },
                  __type__: { object }
                },
                id: { string, number },
                image: {
                  selected: { string, "undefined": "undefined" },
                  // --> URL
                  unselected: { string, "undefined": "undefined" },
                  // --> URL
                  __type__: { object, string }
                },
                label: { string, "undefined": "undefined" },
                labelHighlightBold: { boolean: bool },
                level: { number, "undefined": "undefined" },
                margin: {
                  top: { number },
                  right: { number },
                  bottom: { number },
                  left: { number },
                  __type__: { object, number }
                },
                mass: { number },
                physics: { boolean: bool },
                scaling: {
                  min: { number },
                  max: { number },
                  label: {
                    enabled: { boolean: bool },
                    min: { number },
                    max: { number },
                    maxVisible: { number },
                    drawThreshold: { number },
                    __type__: { object, boolean: bool }
                  },
                  customScalingFunction: { "function": "function" },
                  __type__: { object }
                },
                shadow: {
                  enabled: { boolean: bool },
                  color: { string },
                  size: { number },
                  x: { number },
                  y: { number },
                  __type__: { object, boolean: bool }
                },
                shape: { string: ["ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"] },
                shapeProperties: {
                  borderDashes: { boolean: bool, array },
                  borderRadius: { number },
                  interpolation: { boolean: bool },
                  useImageSize: { boolean: bool },
                  useBorderWithImage: { boolean: bool },
                  __type__: { object }
                },
                size: { number },
                title: { string, dom, "undefined": "undefined" },
                value: { number, "undefined": "undefined" },
                widthConstraint: {
                  minimum: { number },
                  maximum: { number },
                  __type__: { object, boolean: bool, number }
                },
                x: { number },
                y: { number },
                __type__: { object }
              },
              physics: {
                enabled: { boolean: bool },
                barnesHut: {
                  gravitationalConstant: { number },
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  damping: { number },
                  avoidOverlap: { number },
                  __type__: { object }
                },
                forceAtlas2Based: {
                  gravitationalConstant: { number },
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  damping: { number },
                  avoidOverlap: { number },
                  __type__: { object }
                },
                repulsion: {
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  nodeDistance: { number },
                  damping: { number },
                  __type__: { object }
                },
                hierarchicalRepulsion: {
                  centralGravity: { number },
                  springLength: { number },
                  springConstant: { number },
                  nodeDistance: { number },
                  damping: { number },
                  __type__: { object }
                },
                maxVelocity: { number },
                minVelocity: { number },
                // px/s
                solver: { string: ["barnesHut", "repulsion", "hierarchicalRepulsion", "forceAtlas2Based"] },
                stabilization: {
                  enabled: { boolean: bool },
                  iterations: { number },
                  // maximum number of iteration to stabilize
                  updateInterval: { number },
                  onlyDynamicEdges: { boolean: bool },
                  fit: { boolean: bool },
                  __type__: { object, boolean: bool }
                },
                timestep: { number },
                adaptiveTimestep: { boolean: bool },
                __type__: { object, boolean: bool }
              },
              //globals :
              autoResize: { boolean: bool },
              clickToUse: { boolean: bool },
              locale: { string },
              locales: {
                __any__: { any },
                __type__: { object }
              },
              height: { string },
              width: { string },
              __type__: { object }
            };
            allOptions.groups.__any__ = allOptions.nodes;
            allOptions.manipulation.controlNodeStyle = allOptions.nodes;
            var configureOptions = {
              nodes: {
                borderWidth: [1, 0, 10, 1],
                borderWidthSelected: [2, 0, 10, 1],
                color: {
                  border: ["color", "#2B7CE9"],
                  background: ["color", "#97C2FC"],
                  highlight: {
                    border: ["color", "#2B7CE9"],
                    background: ["color", "#D2E5FF"]
                  },
                  hover: {
                    border: ["color", "#2B7CE9"],
                    background: ["color", "#D2E5FF"]
                  }
                },
                fixed: {
                  x: false,
                  y: false
                },
                font: {
                  color: ["color", "#343434"],
                  size: [14, 0, 100, 1],
                  // px
                  face: ["arial", "verdana", "tahoma"],
                  background: ["color", "none"],
                  strokeWidth: [0, 0, 50, 1],
                  // px
                  strokeColor: ["color", "#ffffff"]
                },
                //group: 'string',
                hidden: false,
                labelHighlightBold: true,
                //icon: {
                //  face: 'string',  //'FontAwesome',
                //  code: 'string',  //'\uf007',
                //  size: [50, 0, 200, 1],  //50,
                //  color: ['color','#2B7CE9']   //'#aa00ff'
                //},
                //image: 'string', // --> URL
                physics: true,
                scaling: {
                  min: [10, 0, 200, 1],
                  max: [30, 0, 200, 1],
                  label: {
                    enabled: false,
                    min: [14, 0, 200, 1],
                    max: [30, 0, 200, 1],
                    maxVisible: [30, 0, 200, 1],
                    drawThreshold: [5, 0, 20, 1]
                  }
                },
                shadow: {
                  enabled: false,
                  color: "rgba(0,0,0,0.5)",
                  size: [10, 0, 20, 1],
                  x: [5, -30, 30, 1],
                  y: [5, -30, 30, 1]
                },
                shape: ["ellipse", "box", "circle", "database", "diamond", "dot", "square", "star", "text", "triangle", "triangleDown", "hexagon"],
                shapeProperties: {
                  borderDashes: false,
                  borderRadius: [6, 0, 20, 1],
                  interpolation: true,
                  useImageSize: false
                },
                size: [25, 0, 200, 1]
              },
              edges: {
                arrows: {
                  to: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" },
                  middle: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" },
                  from: { enabled: false, scaleFactor: [1, 0, 3, 0.05], type: "arrow" }
                },
                arrowStrikethrough: true,
                color: {
                  color: ["color", "#848484"],
                  highlight: ["color", "#848484"],
                  hover: ["color", "#848484"],
                  inherit: ["from", "to", "both", true, false],
                  opacity: [1, 0, 1, 0.05]
                },
                dashes: false,
                font: {
                  color: ["color", "#343434"],
                  size: [14, 0, 100, 1],
                  // px
                  face: ["arial", "verdana", "tahoma"],
                  background: ["color", "none"],
                  strokeWidth: [2, 0, 50, 1],
                  // px
                  strokeColor: ["color", "#ffffff"],
                  align: ["horizontal", "top", "middle", "bottom"]
                },
                hidden: false,
                hoverWidth: [1.5, 0, 5, 0.1],
                labelHighlightBold: true,
                physics: true,
                scaling: {
                  min: [1, 0, 100, 1],
                  max: [15, 0, 100, 1],
                  label: {
                    enabled: true,
                    min: [14, 0, 200, 1],
                    max: [30, 0, 200, 1],
                    maxVisible: [30, 0, 200, 1],
                    drawThreshold: [5, 0, 20, 1]
                  }
                },
                selectionWidth: [1.5, 0, 5, 0.1],
                selfReferenceSize: [20, 0, 200, 1],
                shadow: {
                  enabled: false,
                  color: "rgba(0,0,0,0.5)",
                  size: [10, 0, 20, 1],
                  x: [5, -30, 30, 1],
                  y: [5, -30, 30, 1]
                },
                smooth: {
                  enabled: true,
                  type: ["dynamic", "continuous", "discrete", "diagonalCross", "straightCross", "horizontal", "vertical", "curvedCW", "curvedCCW", "cubicBezier"],
                  forceDirection: ["horizontal", "vertical", "none"],
                  roundness: [0.5, 0, 1, 0.05]
                },
                width: [1, 0, 30, 1]
              },
              layout: {
                //randomSeed: [0, 0, 500, 1],
                //improvedLayout: true,
                hierarchical: {
                  enabled: false,
                  levelSeparation: [150, 20, 500, 5],
                  nodeSpacing: [100, 20, 500, 5],
                  treeSpacing: [200, 20, 500, 5],
                  blockShifting: true,
                  edgeMinimization: true,
                  parentCentralization: true,
                  direction: ["UD", "DU", "LR", "RL"],
                  // UD, DU, LR, RL
                  sortMethod: ["hubsize", "directed"]
                  // hubsize, directed
                }
              },
              interaction: {
                dragNodes: true,
                dragView: true,
                hideEdgesOnDrag: false,
                hideNodesOnDrag: false,
                hover: false,
                keyboard: {
                  enabled: false,
                  speed: { x: [10, 0, 40, 1], y: [10, 0, 40, 1], zoom: [0.02, 0, 0.1, 5e-3] },
                  bindToWindow: true
                },
                multiselect: false,
                navigationButtons: false,
                selectable: true,
                selectConnectedEdges: true,
                hoverConnectedEdges: true,
                tooltipDelay: [300, 0, 1e3, 25],
                zoomView: true
              },
              manipulation: {
                enabled: false,
                initiallyActive: false
              },
              physics: {
                enabled: true,
                barnesHut: {
                  //theta: [0.5, 0.1, 1, 0.05],
                  gravitationalConstant: [-2e3, -3e4, 0, 50],
                  centralGravity: [0.3, 0, 10, 0.05],
                  springLength: [95, 0, 500, 5],
                  springConstant: [0.04, 0, 1.2, 5e-3],
                  damping: [0.09, 0, 1, 0.01],
                  avoidOverlap: [0, 0, 1, 0.01]
                },
                forceAtlas2Based: {
                  //theta: [0.5, 0.1, 1, 0.05],
                  gravitationalConstant: [-50, -500, 0, 1],
                  centralGravity: [0.01, 0, 1, 5e-3],
                  springLength: [95, 0, 500, 5],
                  springConstant: [0.08, 0, 1.2, 5e-3],
                  damping: [0.4, 0, 1, 0.01],
                  avoidOverlap: [0, 0, 1, 0.01]
                },
                repulsion: {
                  centralGravity: [0.2, 0, 10, 0.05],
                  springLength: [200, 0, 500, 5],
                  springConstant: [0.05, 0, 1.2, 5e-3],
                  nodeDistance: [100, 0, 500, 5],
                  damping: [0.09, 0, 1, 0.01]
                },
                hierarchicalRepulsion: {
                  centralGravity: [0.2, 0, 10, 0.05],
                  springLength: [100, 0, 500, 5],
                  springConstant: [0.01, 0, 1.2, 5e-3],
                  nodeDistance: [120, 0, 500, 5],
                  damping: [0.09, 0, 1, 0.01]
                },
                maxVelocity: [50, 0, 150, 1],
                minVelocity: [0.1, 0.01, 0.5, 0.01],
                solver: ["barnesHut", "forceAtlas2Based", "repulsion", "hierarchicalRepulsion"],
                timestep: [0.5, 0.01, 1, 0.01]
                //adaptiveTimestep: true
              }
            };
            exports2.allOptions = allOptions;
            exports2.configureOptions = configureOptions;
          },
          /* 123 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var util = __webpack_require__(2);
            util.extend(exports2, __webpack_require__(159));
            util.extend(exports2, __webpack_require__(177));
            util.extend(exports2, __webpack_require__(181));
          },
          /* 124 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(49);
            __webpack_require__(60);
            module2.exports = __webpack_require__(136);
          },
          /* 125 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var addToUnscopables = __webpack_require__(126);
            var step = __webpack_require__(127);
            var Iterators = __webpack_require__(31);
            var toIObject = __webpack_require__(25);
            module2.exports = __webpack_require__(79)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t;
              var kind = this._k;
              var index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step(1);
              }
              if (kind == "keys") return step(0, index);
              if (kind == "values") return step(0, O[index]);
              return step(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          /* 126 */
          /***/
          function(module2, exports2) {
            module2.exports = function() {
            };
          },
          /* 127 */
          /***/
          function(module2, exports2) {
            module2.exports = function(done, value) {
              return { value, done: !!done };
            };
          },
          /* 128 */
          /***/
          function(module2, exports2) {
            module2.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          },
          /* 129 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var create = __webpack_require__(54);
            var descriptor = __webpack_require__(39);
            var setToStringTag = __webpack_require__(59);
            var IteratorPrototype = {};
            __webpack_require__(26)(IteratorPrototype, __webpack_require__(13)("iterator"), function() {
              return this;
            });
            module2.exports = function(Constructor, NAME, next) {
              Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
              setToStringTag(Constructor, NAME + " Iterator");
            };
          },
          /* 130 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var dP = __webpack_require__(20);
            var anObject = __webpack_require__(27);
            var getKeys = __webpack_require__(33);
            module2.exports = __webpack_require__(21) ? Object.defineProperties : function defineProperties(O, Properties) {
              anObject(O);
              var keys = getKeys(Properties);
              var length = keys.length;
              var i = 0;
              var P;
              while (length > i) dP.f(O, P = keys[i++], Properties[P]);
              return O;
            };
          },
          /* 131 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIObject = __webpack_require__(25);
            var toLength = __webpack_require__(132);
            var toAbsoluteIndex = __webpack_require__(133);
            module2.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el) while (length > index) {
                  value = O[index++];
                  if (value != value) return true;
                }
                else for (; length > index; index++) if (IS_INCLUDES || index in O) {
                  if (O[index] === el) return IS_INCLUDES || index || 0;
                }
                return !IS_INCLUDES && -1;
              };
            };
          },
          /* 132 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(55);
            var min = Math.min;
            module2.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          /* 133 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(55);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              index = toInteger(index);
              return index < 0 ? max(index + length, 0) : min(index, length);
            };
          },
          /* 134 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var document2 = __webpack_require__(18).document;
            module2.exports = document2 && document2.documentElement;
          },
          /* 135 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(55);
            var defined = __webpack_require__(51);
            module2.exports = function(TO_STRING) {
              return function(that, pos) {
                var s = String(defined(that));
                var i = toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
              };
            };
          },
          /* 136 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(27);
            var get = __webpack_require__(137);
            module2.exports = __webpack_require__(7).getIterator = function(it) {
              var iterFn = get(it);
              if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
              return anObject(iterFn.call(it));
            };
          },
          /* 137 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__(86);
            var ITERATOR = __webpack_require__(13)("iterator");
            var Iterators = __webpack_require__(31);
            module2.exports = __webpack_require__(7).getIteratorMethod = function(it) {
              if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          /* 138 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(139);
            var $Object = __webpack_require__(7).Object;
            module2.exports = function create(P, D) {
              return $Object.create(P, D);
            };
          },
          /* 139 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            $export($export.S, "Object", { create: __webpack_require__(54) });
          },
          /* 140 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(141);
            module2.exports = __webpack_require__(7).Object.keys;
          },
          /* 141 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toObject = __webpack_require__(41);
            var $keys = __webpack_require__(33);
            __webpack_require__(87)("keys", function() {
              return function keys(it) {
                return $keys(toObject(it));
              };
            });
          },
          /* 142 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(143), __esModule: true };
          },
          /* 143 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(60);
            __webpack_require__(49);
            module2.exports = __webpack_require__(61).f("iterator");
          },
          /* 144 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(145), __esModule: true };
          },
          /* 145 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(146);
            __webpack_require__(151);
            __webpack_require__(152);
            __webpack_require__(153);
            module2.exports = __webpack_require__(7).Symbol;
          },
          /* 146 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var global = __webpack_require__(18);
            var has = __webpack_require__(22);
            var DESCRIPTORS = __webpack_require__(21);
            var $export = __webpack_require__(17);
            var redefine = __webpack_require__(83);
            var META = __webpack_require__(147).KEY;
            var $fails = __webpack_require__(28);
            var shared = __webpack_require__(57);
            var setToStringTag = __webpack_require__(59);
            var uid = __webpack_require__(40);
            var wks = __webpack_require__(13);
            var wksExt = __webpack_require__(61);
            var wksDefine = __webpack_require__(62);
            var enumKeys = __webpack_require__(148);
            var isArray = __webpack_require__(149);
            var anObject = __webpack_require__(27);
            var toIObject = __webpack_require__(25);
            var toPrimitive = __webpack_require__(53);
            var createDesc = __webpack_require__(39);
            var _create = __webpack_require__(54);
            var gOPNExt = __webpack_require__(150);
            var $GOPD = __webpack_require__(89);
            var $DP = __webpack_require__(20);
            var $keys = __webpack_require__(33);
            var gOPD = $GOPD.f;
            var dP = $DP.f;
            var gOPN = gOPNExt.f;
            var $Symbol = global.Symbol;
            var $JSON = global.JSON;
            var _stringify = $JSON && $JSON.stringify;
            var PROTOTYPE = "prototype";
            var HIDDEN = wks("_hidden");
            var TO_PRIMITIVE = wks("toPrimitive");
            var isEnum = {}.propertyIsEnumerable;
            var SymbolRegistry = shared("symbol-registry");
            var AllSymbols = shared("symbols");
            var OPSymbols = shared("op-symbols");
            var ObjectProto = Object[PROTOTYPE];
            var USE_NATIVE = typeof $Symbol == "function";
            var QObject = global.QObject;
            var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            var setSymbolDesc = DESCRIPTORS && $fails(function() {
              return _create(dP({}, "a", {
                get: function() {
                  return dP(this, "a", { value: 7 }).a;
                }
              })).a != 7;
            }) ? function(it, key, D) {
              var protoDesc = gOPD(ObjectProto, key);
              if (protoDesc) delete ObjectProto[key];
              dP(it, key, D);
              if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
            } : dP;
            var wrap = function(tag) {
              var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
              sym._k = tag;
              return sym;
            };
            var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              return it instanceof $Symbol;
            };
            var $defineProperty = function defineProperty(it, key, D) {
              if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
              anObject(it);
              key = toPrimitive(key, true);
              anObject(D);
              if (has(AllSymbols, key)) {
                if (!D.enumerable) {
                  if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
                  it[HIDDEN][key] = true;
                } else {
                  if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
                  D = _create(D, { enumerable: createDesc(0, false) });
                }
                return setSymbolDesc(it, key, D);
              }
              return dP(it, key, D);
            };
            var $defineProperties = function defineProperties(it, P) {
              anObject(it);
              var keys = enumKeys(P = toIObject(P));
              var i = 0;
              var l = keys.length;
              var key;
              while (l > i) $defineProperty(it, key = keys[i++], P[key]);
              return it;
            };
            var $create = function create(it, P) {
              return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(key) {
              var E = isEnum.call(this, key = toPrimitive(key, true));
              if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
              return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
              it = toIObject(it);
              key = toPrimitive(key, true);
              if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
              var D = gOPD(it, key);
              if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
              return D;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(it) {
              var names = gOPN(toIObject(it));
              var result = [];
              var i = 0;
              var key;
              while (names.length > i) {
                if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
              }
              return result;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
              var IS_OP = it === ObjectProto;
              var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
              var result = [];
              var i = 0;
              var key;
              while (names.length > i) {
                if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
              }
              return result;
            };
            if (!USE_NATIVE) {
              $Symbol = function Symbol2() {
                if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
                var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
                var $set = function(value) {
                  if (this === ObjectProto) $set.call(OPSymbols, value);
                  if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                  setSymbolDesc(this, tag, createDesc(1, value));
                };
                if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
                return wrap(tag);
              };
              redefine($Symbol[PROTOTYPE], "toString", function toString() {
                return this._k;
              });
              $GOPD.f = $getOwnPropertyDescriptor;
              $DP.f = $defineProperty;
              __webpack_require__(88).f = gOPNExt.f = $getOwnPropertyNames;
              __webpack_require__(42).f = $propertyIsEnumerable;
              __webpack_require__(63).f = $getOwnPropertySymbols;
              if (DESCRIPTORS && !__webpack_require__(52)) {
                redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
              }
              wksExt.f = function(name) {
                return wrap(wks(name));
              };
            }
            $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
            for (var es6Symbols = (
              // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
              "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
            ), j = 0; es6Symbols.length > j; ) wks(es6Symbols[j++]);
            for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; ) wksDefine(wellKnownSymbols[k++]);
            $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
              // 19.4.2.1 Symbol.for(key)
              "for": function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
              },
              // 19.4.2.5 Symbol.keyFor(sym)
              keyFor: function keyFor(sym) {
                if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
                for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
              },
              useSetter: function() {
                setter = true;
              },
              useSimple: function() {
                setter = false;
              }
            });
            $export($export.S + $export.F * !USE_NATIVE, "Object", {
              // 19.1.2.2 Object.create(O [, Properties])
              create: $create,
              // 19.1.2.4 Object.defineProperty(O, P, Attributes)
              defineProperty: $defineProperty,
              // 19.1.2.3 Object.defineProperties(O, Properties)
              defineProperties: $defineProperties,
              // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
              getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
              // 19.1.2.7 Object.getOwnPropertyNames(O)
              getOwnPropertyNames: $getOwnPropertyNames,
              // 19.1.2.8 Object.getOwnPropertySymbols(O)
              getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
              var S = $Symbol();
              return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
            })), "JSON", {
              stringify: function stringify(it) {
                if (it === void 0 || isSymbol(it)) return;
                var args = [it];
                var i = 1;
                var replacer, $replacer;
                while (arguments.length > i) args.push(arguments[i++]);
                replacer = args[1];
                if (typeof replacer == "function") $replacer = replacer;
                if ($replacer || !isArray(replacer)) replacer = function(key, value) {
                  if ($replacer) value = $replacer.call(this, key, value);
                  if (!isSymbol(value)) return value;
                };
                args[1] = replacer;
                return _stringify.apply($JSON, args);
              }
            });
            $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(26)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            setToStringTag($Symbol, "Symbol");
            setToStringTag(Math, "Math", true);
            setToStringTag(global.JSON, "JSON", true);
          },
          /* 147 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var META = __webpack_require__(40)("meta");
            var isObject = __webpack_require__(32);
            var has = __webpack_require__(22);
            var setDesc = __webpack_require__(20).f;
            var id = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__webpack_require__(28)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function(it) {
              setDesc(it, META, { value: {
                i: "O" + ++id,
                // object ID
                w: {}
                // weak collections IDs
              } });
            };
            var fastKey = function(it, create) {
              if (!isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
              return it;
            };
            var meta = module2.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          /* 148 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var getKeys = __webpack_require__(33);
            var gOPS = __webpack_require__(63);
            var pIE = __webpack_require__(42);
            module2.exports = function(it) {
              var result = getKeys(it);
              var getSymbols = gOPS.f;
              if (getSymbols) {
                var symbols = getSymbols(it);
                var isEnum = pIE.f;
                var i = 0;
                var key;
                while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
              }
              return result;
            };
          },
          /* 149 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var cof = __webpack_require__(50);
            module2.exports = Array.isArray || function isArray(arg) {
              return cof(arg) == "Array";
            };
          },
          /* 150 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIObject = __webpack_require__(25);
            var gOPN = __webpack_require__(88).f;
            var toString = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
              try {
                return gOPN(it);
              } catch (e) {
                return windowNames.slice();
              }
            };
            module2.exports.f = function getOwnPropertyNames(it) {
              return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
            };
          },
          /* 151 */
          /***/
          function(module2, exports2) {
          },
          /* 152 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(62)("asyncIterator");
          },
          /* 153 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(62)("observable");
          },
          /* 154 */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(module3) {
              var require2;
              ;
              (function(global, factory) {
                true ? module3.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
              })(this, function() {
                "use strict";
                var hookCallback;
                function hooks() {
                  return hookCallback.apply(null, arguments);
                }
                function setHookCallback(callback) {
                  hookCallback = callback;
                }
                function isArray(input) {
                  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
                }
                function isObject(input) {
                  return input != null && Object.prototype.toString.call(input) === "[object Object]";
                }
                function isObjectEmpty(obj) {
                  if (Object.getOwnPropertyNames) {
                    return Object.getOwnPropertyNames(obj).length === 0;
                  } else {
                    var k;
                    for (k in obj) {
                      if (obj.hasOwnProperty(k)) {
                        return false;
                      }
                    }
                    return true;
                  }
                }
                function isUndefined(input) {
                  return input === void 0;
                }
                function isNumber(input) {
                  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
                }
                function isDate(input) {
                  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
                }
                function map(arr, fn) {
                  var res = [], i;
                  for (i = 0; i < arr.length; ++i) {
                    res.push(fn(arr[i], i));
                  }
                  return res;
                }
                function hasOwnProp(a, b) {
                  return Object.prototype.hasOwnProperty.call(a, b);
                }
                function extend(a, b) {
                  for (var i in b) {
                    if (hasOwnProp(b, i)) {
                      a[i] = b[i];
                    }
                  }
                  if (hasOwnProp(b, "toString")) {
                    a.toString = b.toString;
                  }
                  if (hasOwnProp(b, "valueOf")) {
                    a.valueOf = b.valueOf;
                  }
                  return a;
                }
                function createUTC(input, format2, locale2, strict) {
                  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
                }
                function defaultParsingFlags() {
                  return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    meridiem: null,
                    rfc2822: false,
                    weekdayMismatch: false
                  };
                }
                function getParsingFlags(m) {
                  if (m._pf == null) {
                    m._pf = defaultParsingFlags();
                  }
                  return m._pf;
                }
                var some;
                if (Array.prototype.some) {
                  some = Array.prototype.some;
                } else {
                  some = function(fun) {
                    var t = Object(this);
                    var len = t.length >>> 0;
                    for (var i = 0; i < len; i++) {
                      if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                      }
                    }
                    return false;
                  };
                }
                function isValid(m) {
                  if (m._isValid == null) {
                    var flags = getParsingFlags(m);
                    var parsedParts = some.call(flags.parsedDateParts, function(i) {
                      return i != null;
                    });
                    var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
                    if (m._strict) {
                      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
                    }
                    if (Object.isFrozen == null || !Object.isFrozen(m)) {
                      m._isValid = isNowValid;
                    } else {
                      return isNowValid;
                    }
                  }
                  return m._isValid;
                }
                function createInvalid(flags) {
                  var m = createUTC(NaN);
                  if (flags != null) {
                    extend(getParsingFlags(m), flags);
                  } else {
                    getParsingFlags(m).userInvalidated = true;
                  }
                  return m;
                }
                var momentProperties = hooks.momentProperties = [];
                function copyConfig(to2, from2) {
                  var i, prop, val;
                  if (!isUndefined(from2._isAMomentObject)) {
                    to2._isAMomentObject = from2._isAMomentObject;
                  }
                  if (!isUndefined(from2._i)) {
                    to2._i = from2._i;
                  }
                  if (!isUndefined(from2._f)) {
                    to2._f = from2._f;
                  }
                  if (!isUndefined(from2._l)) {
                    to2._l = from2._l;
                  }
                  if (!isUndefined(from2._strict)) {
                    to2._strict = from2._strict;
                  }
                  if (!isUndefined(from2._tzm)) {
                    to2._tzm = from2._tzm;
                  }
                  if (!isUndefined(from2._isUTC)) {
                    to2._isUTC = from2._isUTC;
                  }
                  if (!isUndefined(from2._offset)) {
                    to2._offset = from2._offset;
                  }
                  if (!isUndefined(from2._pf)) {
                    to2._pf = getParsingFlags(from2);
                  }
                  if (!isUndefined(from2._locale)) {
                    to2._locale = from2._locale;
                  }
                  if (momentProperties.length > 0) {
                    for (i = 0; i < momentProperties.length; i++) {
                      prop = momentProperties[i];
                      val = from2[prop];
                      if (!isUndefined(val)) {
                        to2[prop] = val;
                      }
                    }
                  }
                  return to2;
                }
                var updateInProgress = false;
                function Moment(config) {
                  copyConfig(this, config);
                  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                  if (!this.isValid()) {
                    this._d = /* @__PURE__ */ new Date(NaN);
                  }
                  if (updateInProgress === false) {
                    updateInProgress = true;
                    hooks.updateOffset(this);
                    updateInProgress = false;
                  }
                }
                function isMoment(obj) {
                  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
                }
                function absFloor(number) {
                  if (number < 0) {
                    return Math.ceil(number) || 0;
                  } else {
                    return Math.floor(number);
                  }
                }
                function toInt(argumentForCoercion) {
                  var coercedNumber = +argumentForCoercion, value = 0;
                  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                  }
                  return value;
                }
                function compareArrays(array1, array2, dontConvert) {
                  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
                  for (i = 0; i < len; i++) {
                    if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                      diffs++;
                    }
                  }
                  return diffs + lengthDiff;
                }
                function warn(msg) {
                  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
                    console.warn("Deprecation warning: " + msg);
                  }
                }
                function deprecate(msg, fn) {
                  var firstTime = true;
                  return extend(function() {
                    if (hooks.deprecationHandler != null) {
                      hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                      var args = [];
                      var arg;
                      for (var i = 0; i < arguments.length; i++) {
                        arg = "";
                        if (typeof arguments[i] === "object") {
                          arg += "\n[" + i + "] ";
                          for (var key in arguments[0]) {
                            arg += key + ": " + arguments[0][key] + ", ";
                          }
                          arg = arg.slice(0, -2);
                        } else {
                          arg = arguments[i];
                        }
                        args.push(arg);
                      }
                      warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
                      firstTime = false;
                    }
                    return fn.apply(this, arguments);
                  }, fn);
                }
                var deprecations = {};
                function deprecateSimple(name, msg) {
                  if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(name, msg);
                  }
                  if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                  }
                }
                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;
                function isFunction(input) {
                  return input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
                }
                function set(config) {
                  var prop, i;
                  for (i in config) {
                    prop = config[i];
                    if (isFunction(prop)) {
                      this[i] = prop;
                    } else {
                      this["_" + i] = prop;
                    }
                  }
                  this._config = config;
                  this._dayOfMonthOrdinalParseLenient = new RegExp(
                    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
                  );
                }
                function mergeConfigs(parentConfig, childConfig) {
                  var res = extend({}, parentConfig), prop;
                  for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                      } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                      } else {
                        delete res[prop];
                      }
                    }
                  }
                  for (prop in parentConfig) {
                    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                      res[prop] = extend({}, res[prop]);
                    }
                  }
                  return res;
                }
                function Locale(config) {
                  if (config != null) {
                    this.set(config);
                  }
                }
                var keys;
                if (Object.keys) {
                  keys = Object.keys;
                } else {
                  keys = function(obj) {
                    var i, res = [];
                    for (i in obj) {
                      if (hasOwnProp(obj, i)) {
                        res.push(i);
                      }
                    }
                    return res;
                  };
                }
                var defaultCalendar = {
                  sameDay: "[Today at] LT",
                  nextDay: "[Tomorrow at] LT",
                  nextWeek: "dddd [at] LT",
                  lastDay: "[Yesterday at] LT",
                  lastWeek: "[Last] dddd [at] LT",
                  sameElse: "L"
                };
                function calendar(key, mom, now2) {
                  var output = this._calendar[key] || this._calendar["sameElse"];
                  return isFunction(output) ? output.call(mom, now2) : output;
                }
                var defaultLongDateFormat = {
                  LTS: "h:mm:ss A",
                  LT: "h:mm A",
                  L: "MM/DD/YYYY",
                  LL: "MMMM D, YYYY",
                  LLL: "MMMM D, YYYY h:mm A",
                  LLLL: "dddd, MMMM D, YYYY h:mm A"
                };
                function longDateFormat(key) {
                  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
                  if (format2 || !formatUpper) {
                    return format2;
                  }
                  this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
                    return val.slice(1);
                  });
                  return this._longDateFormat[key];
                }
                var defaultInvalidDate = "Invalid date";
                function invalidDate() {
                  return this._invalidDate;
                }
                var defaultOrdinal = "%d";
                var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
                function ordinal(number) {
                  return this._ordinal.replace("%d", number);
                }
                var defaultRelativeTime = {
                  future: "in %s",
                  past: "%s ago",
                  s: "a few seconds",
                  ss: "%d seconds",
                  m: "a minute",
                  mm: "%d minutes",
                  h: "an hour",
                  hh: "%d hours",
                  d: "a day",
                  dd: "%d days",
                  M: "a month",
                  MM: "%d months",
                  y: "a year",
                  yy: "%d years"
                };
                function relativeTime(number, withoutSuffix, string, isFuture) {
                  var output = this._relativeTime[string];
                  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
                }
                function pastFuture(diff2, output) {
                  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
                  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
                }
                var aliases = {};
                function addUnitAlias(unit, shorthand) {
                  var lowerCase = unit.toLowerCase();
                  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
                }
                function normalizeUnits(units) {
                  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
                }
                function normalizeObjectUnits(inputObject) {
                  var normalizedInput = {}, normalizedProp, prop;
                  for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                      normalizedProp = normalizeUnits(prop);
                      if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                      }
                    }
                  }
                  return normalizedInput;
                }
                var priorities = {};
                function addUnitPriority(unit, priority) {
                  priorities[unit] = priority;
                }
                function getPrioritizedUnits(unitsObj) {
                  var units = [];
                  for (var u in unitsObj) {
                    units.push({ unit: u, priority: priorities[u] });
                  }
                  units.sort(function(a, b) {
                    return a.priority - b.priority;
                  });
                  return units;
                }
                function zeroFill(number, targetLength, forceSign) {
                  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
                  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                }
                var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
                var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
                var formatFunctions = {};
                var formatTokenFunctions = {};
                function addFormatToken(token2, padded, ordinal2, callback) {
                  var func = callback;
                  if (typeof callback === "string") {
                    func = function() {
                      return this[callback]();
                    };
                  }
                  if (token2) {
                    formatTokenFunctions[token2] = func;
                  }
                  if (padded) {
                    formatTokenFunctions[padded[0]] = function() {
                      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                  }
                  if (ordinal2) {
                    formatTokenFunctions[ordinal2] = function() {
                      return this.localeData().ordinal(func.apply(this, arguments), token2);
                    };
                  }
                }
                function removeFormattingTokens(input) {
                  if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, "");
                  }
                  return input.replace(/\\/g, "");
                }
                function makeFormatFunction(format2) {
                  var array = format2.match(formattingTokens), i, length;
                  for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                      array[i] = formatTokenFunctions[array[i]];
                    } else {
                      array[i] = removeFormattingTokens(array[i]);
                    }
                  }
                  return function(mom) {
                    var output = "", i2;
                    for (i2 = 0; i2 < length; i2++) {
                      output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
                    }
                    return output;
                  };
                }
                function formatMoment(m, format2) {
                  if (!m.isValid()) {
                    return m.localeData().invalidDate();
                  }
                  format2 = expandFormat(format2, m.localeData());
                  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
                  return formatFunctions[format2](m);
                }
                function expandFormat(format2, locale2) {
                  var i = 5;
                  function replaceLongDateFormatTokens(input) {
                    return locale2.longDateFormat(input) || input;
                  }
                  localFormattingTokens.lastIndex = 0;
                  while (i >= 0 && localFormattingTokens.test(format2)) {
                    format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                  }
                  return format2;
                }
                var match1 = /\d/;
                var match2 = /\d\d/;
                var match3 = /\d{3}/;
                var match4 = /\d{4}/;
                var match6 = /[+-]?\d{6}/;
                var match1to2 = /\d\d?/;
                var match3to4 = /\d\d\d\d?/;
                var match5to6 = /\d\d\d\d\d\d?/;
                var match1to3 = /\d{1,3}/;
                var match1to4 = /\d{1,4}/;
                var match1to6 = /[+-]?\d{1,6}/;
                var matchUnsigned = /\d+/;
                var matchSigned = /[+-]?\d+/;
                var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
                var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
                var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
                var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
                var regexes = {};
                function addRegexToken(token2, regex, strictRegex) {
                  regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
                    return isStrict && strictRegex ? strictRegex : regex;
                  };
                }
                function getParseRegexForToken(token2, config) {
                  if (!hasOwnProp(regexes, token2)) {
                    return new RegExp(unescapeFormat(token2));
                  }
                  return regexes[token2](config._strict, config._locale);
                }
                function unescapeFormat(s) {
                  return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                  }));
                }
                function regexEscape(s) {
                  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                }
                var tokens = {};
                function addParseToken(token2, callback) {
                  var i, func = callback;
                  if (typeof token2 === "string") {
                    token2 = [token2];
                  }
                  if (isNumber(callback)) {
                    func = function(input, array) {
                      array[callback] = toInt(input);
                    };
                  }
                  for (i = 0; i < token2.length; i++) {
                    tokens[token2[i]] = func;
                  }
                }
                function addWeekParseToken(token2, callback) {
                  addParseToken(token2, function(input, array, config, token3) {
                    config._w = config._w || {};
                    callback(input, config._w, config, token3);
                  });
                }
                function addTimeToArrayFromToken(token2, input, config) {
                  if (input != null && hasOwnProp(tokens, token2)) {
                    tokens[token2](input, config._a, config, token2);
                  }
                }
                var YEAR = 0;
                var MONTH = 1;
                var DATE = 2;
                var HOUR = 3;
                var MINUTE = 4;
                var SECOND = 5;
                var MILLISECOND = 6;
                var WEEK = 7;
                var WEEKDAY = 8;
                addFormatToken("Y", 0, 0, function() {
                  var y = this.year();
                  return y <= 9999 ? "" + y : "+" + y;
                });
                addFormatToken(0, ["YY", 2], 0, function() {
                  return this.year() % 100;
                });
                addFormatToken(0, ["YYYY", 4], 0, "year");
                addFormatToken(0, ["YYYYY", 5], 0, "year");
                addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
                addUnitAlias("year", "y");
                addUnitPriority("year", 1);
                addRegexToken("Y", matchSigned);
                addRegexToken("YY", match1to2, match2);
                addRegexToken("YYYY", match1to4, match4);
                addRegexToken("YYYYY", match1to6, match6);
                addRegexToken("YYYYYY", match1to6, match6);
                addParseToken(["YYYYY", "YYYYYY"], YEAR);
                addParseToken("YYYY", function(input, array) {
                  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
                });
                addParseToken("YY", function(input, array) {
                  array[YEAR] = hooks.parseTwoDigitYear(input);
                });
                addParseToken("Y", function(input, array) {
                  array[YEAR] = parseInt(input, 10);
                });
                function daysInYear(year) {
                  return isLeapYear(year) ? 366 : 365;
                }
                function isLeapYear(year) {
                  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                }
                hooks.parseTwoDigitYear = function(input) {
                  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
                };
                var getSetYear = makeGetSet("FullYear", true);
                function getIsLeapYear() {
                  return isLeapYear(this.year());
                }
                function makeGetSet(unit, keepTime) {
                  return function(value) {
                    if (value != null) {
                      set$1(this, unit, value);
                      hooks.updateOffset(this, keepTime);
                      return this;
                    } else {
                      return get(this, unit);
                    }
                  };
                }
                function get(mom, unit) {
                  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
                }
                function set$1(mom, unit, value) {
                  if (mom.isValid() && !isNaN(value)) {
                    if (unit === "FullYear" && isLeapYear(mom.year())) {
                      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
                    } else {
                      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
                    }
                  }
                }
                function stringGet(units) {
                  units = normalizeUnits(units);
                  if (isFunction(this[units])) {
                    return this[units]();
                  }
                  return this;
                }
                function stringSet(units, value) {
                  if (typeof units === "object") {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units);
                    for (var i = 0; i < prioritized.length; i++) {
                      this[prioritized[i].unit](units[prioritized[i].unit]);
                    }
                  } else {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                      return this[units](value);
                    }
                  }
                  return this;
                }
                function mod(n, x) {
                  return (n % x + x) % x;
                }
                var indexOf;
                if (Array.prototype.indexOf) {
                  indexOf = Array.prototype.indexOf;
                } else {
                  indexOf = function(o) {
                    var i;
                    for (i = 0; i < this.length; ++i) {
                      if (this[i] === o) {
                        return i;
                      }
                    }
                    return -1;
                  };
                }
                function daysInMonth(year, month) {
                  if (isNaN(year) || isNaN(month)) {
                    return NaN;
                  }
                  var modMonth = mod(month, 12);
                  year += (month - modMonth) / 12;
                  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
                }
                addFormatToken("M", ["MM", 2], "Mo", function() {
                  return this.month() + 1;
                });
                addFormatToken("MMM", 0, 0, function(format2) {
                  return this.localeData().monthsShort(this, format2);
                });
                addFormatToken("MMMM", 0, 0, function(format2) {
                  return this.localeData().months(this, format2);
                });
                addUnitAlias("month", "M");
                addUnitPriority("month", 8);
                addRegexToken("M", match1to2);
                addRegexToken("MM", match1to2, match2);
                addRegexToken("MMM", function(isStrict, locale2) {
                  return locale2.monthsShortRegex(isStrict);
                });
                addRegexToken("MMMM", function(isStrict, locale2) {
                  return locale2.monthsRegex(isStrict);
                });
                addParseToken(["M", "MM"], function(input, array) {
                  array[MONTH] = toInt(input) - 1;
                });
                addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
                  var month = config._locale.monthsParse(input, token2, config._strict);
                  if (month != null) {
                    array[MONTH] = month;
                  } else {
                    getParsingFlags(config).invalidMonth = input;
                  }
                });
                var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
                var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
                function localeMonths(m, format2) {
                  if (!m) {
                    return isArray(this._months) ? this._months : this._months["standalone"];
                  }
                  return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
                }
                var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
                function localeMonthsShort(m, format2) {
                  if (!m) {
                    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
                  }
                  return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
                }
                function handleStrictParse(monthName, format2, strict) {
                  var i, ii, mom, llc = monthName.toLocaleLowerCase();
                  if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i = 0; i < 12; ++i) {
                      mom = createUTC([2e3, i]);
                      this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
                    }
                  }
                  if (strict) {
                    if (format2 === "MMM") {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  } else {
                    if (format2 === "MMM") {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  }
                }
                function localeMonthsParse(monthName, format2, strict) {
                  var i, mom, regex;
                  if (this._monthsParseExact) {
                    return handleStrictParse.call(this, monthName, format2, strict);
                  }
                  if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                  }
                  for (i = 0; i < 12; i++) {
                    mom = createUTC([2e3, i]);
                    if (strict && !this._longMonthsParse[i]) {
                      this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                    }
                    if (!strict && !this._monthsParse[i]) {
                      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                      return i;
                    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                      return i;
                    } else if (!strict && this._monthsParse[i].test(monthName)) {
                      return i;
                    }
                  }
                }
                function setMonth(mom, value) {
                  var dayOfMonth;
                  if (!mom.isValid()) {
                    return mom;
                  }
                  if (typeof value === "string") {
                    if (/^\d+$/.test(value)) {
                      value = toInt(value);
                    } else {
                      value = mom.localeData().monthsParse(value);
                      if (!isNumber(value)) {
                        return mom;
                      }
                    }
                  }
                  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
                  return mom;
                }
                function getSetMonth(value) {
                  if (value != null) {
                    setMonth(this, value);
                    hooks.updateOffset(this, true);
                    return this;
                  } else {
                    return get(this, "Month");
                  }
                }
                function getDaysInMonth() {
                  return daysInMonth(this.year(), this.month());
                }
                var defaultMonthsShortRegex = matchWord;
                function monthsShortRegex(isStrict) {
                  if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                      return this._monthsShortStrictRegex;
                    } else {
                      return this._monthsShortRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_monthsShortRegex")) {
                      this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                  }
                }
                var defaultMonthsRegex = matchWord;
                function monthsRegex(isStrict) {
                  if (this._monthsParseExact) {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                      return this._monthsStrictRegex;
                    } else {
                      return this._monthsRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_monthsRegex")) {
                      this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                  }
                }
                function computeMonthsParse() {
                  function cmpLenRev(a, b) {
                    return b.length - a.length;
                  }
                  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
                  for (i = 0; i < 12; i++) {
                    mom = createUTC([2e3, i]);
                    shortPieces.push(this.monthsShort(mom, ""));
                    longPieces.push(this.months(mom, ""));
                    mixedPieces.push(this.months(mom, ""));
                    mixedPieces.push(this.monthsShort(mom, ""));
                  }
                  shortPieces.sort(cmpLenRev);
                  longPieces.sort(cmpLenRev);
                  mixedPieces.sort(cmpLenRev);
                  for (i = 0; i < 12; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                  }
                  for (i = 0; i < 24; i++) {
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                  }
                  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                  this._monthsShortRegex = this._monthsRegex;
                  this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                  this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                }
                function createDate(y, m, d, h, M, s, ms) {
                  var date = new Date(y, m, d, h, M, s, ms);
                  if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                  }
                  return date;
                }
                function createUTCDate(y) {
                  var date = new Date(Date.UTC.apply(null, arguments));
                  if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                  }
                  return date;
                }
                function firstWeekOffset(year, dow, doy) {
                  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
                  return -fwdlw + fwd - 1;
                }
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
                  if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                  } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                  } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                  }
                  return {
                    year: resYear,
                    dayOfYear: resDayOfYear
                  };
                }
                function weekOfYear(mom, dow, doy) {
                  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
                  if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                  } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                  } else {
                    resYear = mom.year();
                    resWeek = week;
                  }
                  return {
                    week: resWeek,
                    year: resYear
                  };
                }
                function weeksInYear(year, dow, doy) {
                  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }
                addFormatToken("w", ["ww", 2], "wo", "week");
                addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
                addUnitAlias("week", "w");
                addUnitAlias("isoWeek", "W");
                addUnitPriority("week", 5);
                addUnitPriority("isoWeek", 5);
                addRegexToken("w", match1to2);
                addRegexToken("ww", match1to2, match2);
                addRegexToken("W", match1to2);
                addRegexToken("WW", match1to2, match2);
                addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
                  week[token2.substr(0, 1)] = toInt(input);
                });
                function localeWeek(mom) {
                  return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }
                var defaultLocaleWeek = {
                  dow: 0,
                  // Sunday is the first day of the week.
                  doy: 6
                  // The week that contains Jan 1st is the first week of the year.
                };
                function localeFirstDayOfWeek() {
                  return this._week.dow;
                }
                function localeFirstDayOfYear() {
                  return this._week.doy;
                }
                function getSetWeek(input) {
                  var week = this.localeData().week(this);
                  return input == null ? week : this.add((input - week) * 7, "d");
                }
                function getSetISOWeek(input) {
                  var week = weekOfYear(this, 1, 4).week;
                  return input == null ? week : this.add((input - week) * 7, "d");
                }
                addFormatToken("d", 0, "do", "day");
                addFormatToken("dd", 0, 0, function(format2) {
                  return this.localeData().weekdaysMin(this, format2);
                });
                addFormatToken("ddd", 0, 0, function(format2) {
                  return this.localeData().weekdaysShort(this, format2);
                });
                addFormatToken("dddd", 0, 0, function(format2) {
                  return this.localeData().weekdays(this, format2);
                });
                addFormatToken("e", 0, 0, "weekday");
                addFormatToken("E", 0, 0, "isoWeekday");
                addUnitAlias("day", "d");
                addUnitAlias("weekday", "e");
                addUnitAlias("isoWeekday", "E");
                addUnitPriority("day", 11);
                addUnitPriority("weekday", 11);
                addUnitPriority("isoWeekday", 11);
                addRegexToken("d", match1to2);
                addRegexToken("e", match1to2);
                addRegexToken("E", match1to2);
                addRegexToken("dd", function(isStrict, locale2) {
                  return locale2.weekdaysMinRegex(isStrict);
                });
                addRegexToken("ddd", function(isStrict, locale2) {
                  return locale2.weekdaysShortRegex(isStrict);
                });
                addRegexToken("dddd", function(isStrict, locale2) {
                  return locale2.weekdaysRegex(isStrict);
                });
                addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
                  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
                  if (weekday != null) {
                    week.d = weekday;
                  } else {
                    getParsingFlags(config).invalidWeekday = input;
                  }
                });
                addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
                  week[token2] = toInt(input);
                });
                function parseWeekday(input, locale2) {
                  if (typeof input !== "string") {
                    return input;
                  }
                  if (!isNaN(input)) {
                    return parseInt(input, 10);
                  }
                  input = locale2.weekdaysParse(input);
                  if (typeof input === "number") {
                    return input;
                  }
                  return null;
                }
                function parseIsoWeekday(input, locale2) {
                  if (typeof input === "string") {
                    return locale2.weekdaysParse(input) % 7 || 7;
                  }
                  return isNaN(input) ? null : input;
                }
                var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
                function localeWeekdays(m, format2) {
                  if (!m) {
                    return isArray(this._weekdays) ? this._weekdays : this._weekdays["standalone"];
                  }
                  return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format2) ? "format" : "standalone"][m.day()];
                }
                var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
                function localeWeekdaysShort(m) {
                  return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                }
                var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
                function localeWeekdaysMin(m) {
                  return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                }
                function handleStrictParse$1(weekdayName, format2, strict) {
                  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                  if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];
                    for (i = 0; i < 7; ++i) {
                      mom = createUTC([2e3, 1]).day(i);
                      this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
                    }
                  }
                  if (strict) {
                    if (format2 === "dddd") {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  } else {
                    if (format2 === "dddd") {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else if (format2 === "ddd") {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    } else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                        return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                    }
                  }
                }
                function localeWeekdaysParse(weekdayName, format2, strict) {
                  var i, mom, regex;
                  if (this._weekdaysParseExact) {
                    return handleStrictParse$1.call(this, weekdayName, format2, strict);
                  }
                  if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                  }
                  for (i = 0; i < 7; i++) {
                    mom = createUTC([2e3, 1]).day(i);
                    if (strict && !this._fullWeekdaysParse[i]) {
                      this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i");
                      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i");
                      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i");
                    }
                    if (!this._weekdaysParse[i]) {
                      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                    }
                    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
                      return i;
                    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                      return i;
                    }
                  }
                }
                function getSetDayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                  if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, "d");
                  } else {
                    return day;
                  }
                }
                function getSetLocaleDayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                  return input == null ? weekday : this.add(input - weekday, "d");
                }
                function getSetISODayOfWeek(input) {
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                  } else {
                    return this.day() || 7;
                  }
                }
                var defaultWeekdaysRegex = matchWord;
                function weekdaysRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysStrictRegex;
                    } else {
                      return this._weekdaysRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                  }
                }
                var defaultWeekdaysShortRegex = matchWord;
                function weekdaysShortRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysShortStrictRegex;
                    } else {
                      return this._weekdaysShortRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                  }
                }
                var defaultWeekdaysMinRegex = matchWord;
                function weekdaysMinRegex(isStrict) {
                  if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, "_weekdaysRegex")) {
                      computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                      return this._weekdaysMinStrictRegex;
                    } else {
                      return this._weekdaysMinRegex;
                    }
                  } else {
                    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                  }
                }
                function computeWeekdaysParse() {
                  function cmpLenRev(a, b) {
                    return b.length - a.length;
                  }
                  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
                  for (i = 0; i < 7; i++) {
                    mom = createUTC([2e3, 1]).day(i);
                    minp = this.weekdaysMin(mom, "");
                    shortp = this.weekdaysShort(mom, "");
                    longp = this.weekdays(mom, "");
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                  }
                  minPieces.sort(cmpLenRev);
                  shortPieces.sort(cmpLenRev);
                  longPieces.sort(cmpLenRev);
                  mixedPieces.sort(cmpLenRev);
                  for (i = 0; i < 7; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                  }
                  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                  this._weekdaysShortRegex = this._weekdaysRegex;
                  this._weekdaysMinRegex = this._weekdaysRegex;
                  this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                  this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                  this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
                }
                function hFormat() {
                  return this.hours() % 12 || 12;
                }
                function kFormat() {
                  return this.hours() || 24;
                }
                addFormatToken("H", ["HH", 2], 0, "hour");
                addFormatToken("h", ["hh", 2], 0, hFormat);
                addFormatToken("k", ["kk", 2], 0, kFormat);
                addFormatToken("hmm", 0, 0, function() {
                  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                });
                addFormatToken("hmmss", 0, 0, function() {
                  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                });
                addFormatToken("Hmm", 0, 0, function() {
                  return "" + this.hours() + zeroFill(this.minutes(), 2);
                });
                addFormatToken("Hmmss", 0, 0, function() {
                  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                });
                function meridiem(token2, lowercase) {
                  addFormatToken(token2, 0, 0, function() {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                  });
                }
                meridiem("a", true);
                meridiem("A", false);
                addUnitAlias("hour", "h");
                addUnitPriority("hour", 13);
                function matchMeridiem(isStrict, locale2) {
                  return locale2._meridiemParse;
                }
                addRegexToken("a", matchMeridiem);
                addRegexToken("A", matchMeridiem);
                addRegexToken("H", match1to2);
                addRegexToken("h", match1to2);
                addRegexToken("k", match1to2);
                addRegexToken("HH", match1to2, match2);
                addRegexToken("hh", match1to2, match2);
                addRegexToken("kk", match1to2, match2);
                addRegexToken("hmm", match3to4);
                addRegexToken("hmmss", match5to6);
                addRegexToken("Hmm", match3to4);
                addRegexToken("Hmmss", match5to6);
                addParseToken(["H", "HH"], HOUR);
                addParseToken(["k", "kk"], function(input, array, config) {
                  var kInput = toInt(input);
                  array[HOUR] = kInput === 24 ? 0 : kInput;
                });
                addParseToken(["a", "A"], function(input, array, config) {
                  config._isPm = config._locale.isPM(input);
                  config._meridiem = input;
                });
                addParseToken(["h", "hh"], function(input, array, config) {
                  array[HOUR] = toInt(input);
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmm", function(input, array, config) {
                  var pos = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos));
                  array[MINUTE] = toInt(input.substr(pos));
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("hmmss", function(input, array, config) {
                  var pos1 = input.length - 4;
                  var pos2 = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos1));
                  array[MINUTE] = toInt(input.substr(pos1, 2));
                  array[SECOND] = toInt(input.substr(pos2));
                  getParsingFlags(config).bigHour = true;
                });
                addParseToken("Hmm", function(input, array, config) {
                  var pos = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos));
                  array[MINUTE] = toInt(input.substr(pos));
                });
                addParseToken("Hmmss", function(input, array, config) {
                  var pos1 = input.length - 4;
                  var pos2 = input.length - 2;
                  array[HOUR] = toInt(input.substr(0, pos1));
                  array[MINUTE] = toInt(input.substr(pos1, 2));
                  array[SECOND] = toInt(input.substr(pos2));
                });
                function localeIsPM(input) {
                  return (input + "").toLowerCase().charAt(0) === "p";
                }
                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
                function localeMeridiem(hours2, minutes2, isLower) {
                  if (hours2 > 11) {
                    return isLower ? "pm" : "PM";
                  } else {
                    return isLower ? "am" : "AM";
                  }
                }
                var getSetHour = makeGetSet("Hours", true);
                var baseConfig = {
                  calendar: defaultCalendar,
                  longDateFormat: defaultLongDateFormat,
                  invalidDate: defaultInvalidDate,
                  ordinal: defaultOrdinal,
                  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                  relativeTime: defaultRelativeTime,
                  months: defaultLocaleMonths,
                  monthsShort: defaultLocaleMonthsShort,
                  week: defaultLocaleWeek,
                  weekdays: defaultLocaleWeekdays,
                  weekdaysMin: defaultLocaleWeekdaysMin,
                  weekdaysShort: defaultLocaleWeekdaysShort,
                  meridiemParse: defaultLocaleMeridiemParse
                };
                var locales = {};
                var localeFamilies = {};
                var globalLocale;
                function normalizeLocale(key) {
                  return key ? key.toLowerCase().replace("_", "-") : key;
                }
                function chooseLocale(names) {
                  var i = 0, j, next, locale2, split;
                  while (i < names.length) {
                    split = normalizeLocale(names[i]).split("-");
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split("-") : null;
                    while (j > 0) {
                      locale2 = loadLocale(split.slice(0, j).join("-"));
                      if (locale2) {
                        return locale2;
                      }
                      if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                        break;
                      }
                      j--;
                    }
                    i++;
                  }
                  return null;
                }
                function loadLocale(name) {
                  var oldLocale = null;
                  if (!locales[name] && typeof module3 !== "undefined" && module3 && module3.exports) {
                    try {
                      oldLocale = globalLocale._abbr;
                      var aliasedRequire = require2;
                      !function webpackMissingModule() {
                        var e = new Error('Cannot find module "./locale"');
                        e.code = "MODULE_NOT_FOUND";
                        throw e;
                      }();
                      getSetGlobalLocale(oldLocale);
                    } catch (e) {
                    }
                  }
                  return locales[name];
                }
                function getSetGlobalLocale(key, values) {
                  var data;
                  if (key) {
                    if (isUndefined(values)) {
                      data = getLocale(key);
                    } else {
                      data = defineLocale(key, values);
                    }
                    if (data) {
                      globalLocale = data;
                    }
                  }
                  return globalLocale._abbr;
                }
                function defineLocale(name, config) {
                  if (config !== null) {
                    var parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                      deprecateSimple(
                        "defineLocaleOverride",
                        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                      );
                      parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                      if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                      } else {
                        if (!localeFamilies[config.parentLocale]) {
                          localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                          name,
                          config
                        });
                        return null;
                      }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));
                    if (localeFamilies[name]) {
                      localeFamilies[name].forEach(function(x) {
                        defineLocale(x.name, x.config);
                      });
                    }
                    getSetGlobalLocale(name);
                    return locales[name];
                  } else {
                    delete locales[name];
                    return null;
                  }
                }
                function updateLocale(name, config) {
                  if (config != null) {
                    var locale2, parentConfig = baseConfig;
                    if (locales[name] != null) {
                      parentConfig = locales[name]._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    locale2 = new Locale(config);
                    locale2.parentLocale = locales[name];
                    locales[name] = locale2;
                    getSetGlobalLocale(name);
                  } else {
                    if (locales[name] != null) {
                      if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                      } else if (locales[name] != null) {
                        delete locales[name];
                      }
                    }
                  }
                  return locales[name];
                }
                function getLocale(key) {
                  var locale2;
                  if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                  }
                  if (!key) {
                    return globalLocale;
                  }
                  if (!isArray(key)) {
                    locale2 = loadLocale(key);
                    if (locale2) {
                      return locale2;
                    }
                    key = [key];
                  }
                  return chooseLocale(key);
                }
                function listLocales() {
                  return keys(locales);
                }
                function checkOverflow(m) {
                  var overflow;
                  var a = m._a;
                  if (a && getParsingFlags(m).overflow === -2) {
                    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
                    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                      overflow = DATE;
                    }
                    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                      overflow = WEEK;
                    }
                    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                      overflow = WEEKDAY;
                    }
                    getParsingFlags(m).overflow = overflow;
                  }
                  return m;
                }
                function defaults(a, b, c) {
                  if (a != null) {
                    return a;
                  }
                  if (b != null) {
                    return b;
                  }
                  return c;
                }
                function currentDateArray(config) {
                  var nowValue = new Date(hooks.now());
                  if (config._useUTC) {
                    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                  }
                  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
                }
                function configFromArray(config) {
                  var i, date, input = [], currentDate, yearToUse;
                  if (config._d) {
                    return;
                  }
                  currentDate = currentDateArray(config);
                  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                  }
                  if (config._dayOfYear != null) {
                    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
                    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                      getParsingFlags(config)._overflowDayOfYear = true;
                    }
                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                  }
                  for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                  }
                  for (; i < 7; i++) {
                    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
                  }
                  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                  }
                  config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                  if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                  }
                  if (config._nextDay) {
                    config._a[HOUR] = 24;
                  }
                  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== config._d.getDay()) {
                    getParsingFlags(config).weekdayMismatch = true;
                  }
                }
                function dayOfYearFromWeekInfo(config) {
                  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
                  w = config._w;
                  if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;
                    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                    week = defaults(w.W, 1);
                    weekday = defaults(w.E, 1);
                    if (weekday < 1 || weekday > 7) {
                      weekdayOverflow = true;
                    }
                  } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;
                    var curWeek = weekOfYear(createLocal(), dow, doy);
                    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
                    week = defaults(w.w, curWeek.week);
                    if (w.d != null) {
                      weekday = w.d;
                      if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                      }
                    } else if (w.e != null) {
                      weekday = w.e + dow;
                      if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                      }
                    } else {
                      weekday = dow;
                    }
                  }
                  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                  } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                  } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                  }
                }
                var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
                var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
                var isoDates = [
                  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
                  ["YYYY-DDD", /\d{4}-\d{3}/],
                  ["YYYY-MM", /\d{4}-\d\d/, false],
                  ["YYYYYYMMDD", /[+-]\d{10}/],
                  ["YYYYMMDD", /\d{8}/],
                  // YYYYMM is NOT allowed by the standard
                  ["GGGG[W]WWE", /\d{4}W\d{3}/],
                  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
                  ["YYYYDDD", /\d{7}/]
                ];
                var isoTimes = [
                  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                  ["HH:mm", /\d\d:\d\d/],
                  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                  ["HHmmss", /\d\d\d\d\d\d/],
                  ["HHmm", /\d\d\d\d/],
                  ["HH", /\d\d/]
                ];
                var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
                function configFromISO(config) {
                  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
                  if (match) {
                    getParsingFlags(config).iso = true;
                    for (i = 0, l = isoDates.length; i < l; i++) {
                      if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                      }
                    }
                    if (dateFormat == null) {
                      config._isValid = false;
                      return;
                    }
                    if (match[3]) {
                      for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                          timeFormat = (match[2] || " ") + isoTimes[i][0];
                          break;
                        }
                      }
                      if (timeFormat == null) {
                        config._isValid = false;
                        return;
                      }
                    }
                    if (!allowTime && timeFormat != null) {
                      config._isValid = false;
                      return;
                    }
                    if (match[4]) {
                      if (tzRegex.exec(match[4])) {
                        tzFormat = "Z";
                      } else {
                        config._isValid = false;
                        return;
                      }
                    }
                    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
                    configFromStringAndFormat(config);
                  } else {
                    config._isValid = false;
                  }
                }
                var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
                function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                  var result = [
                    untruncateYear(yearStr),
                    defaultLocaleMonthsShort.indexOf(monthStr),
                    parseInt(dayStr, 10),
                    parseInt(hourStr, 10),
                    parseInt(minuteStr, 10)
                  ];
                  if (secondStr) {
                    result.push(parseInt(secondStr, 10));
                  }
                  return result;
                }
                function untruncateYear(yearStr) {
                  var year = parseInt(yearStr, 10);
                  if (year <= 49) {
                    return 2e3 + year;
                  } else if (year <= 999) {
                    return 1900 + year;
                  }
                  return year;
                }
                function preprocessRFC2822(s) {
                  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
                }
                function checkWeekday(weekdayStr, parsedInput, config) {
                  if (weekdayStr) {
                    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                    if (weekdayProvided !== weekdayActual) {
                      getParsingFlags(config).weekdayMismatch = true;
                      config._isValid = false;
                      return false;
                    }
                  }
                  return true;
                }
                var obsOffsets = {
                  UT: 0,
                  GMT: 0,
                  EDT: -4 * 60,
                  EST: -5 * 60,
                  CDT: -5 * 60,
                  CST: -6 * 60,
                  MDT: -6 * 60,
                  MST: -7 * 60,
                  PDT: -7 * 60,
                  PST: -8 * 60
                };
                function calculateOffset(obsOffset, militaryOffset, numOffset) {
                  if (obsOffset) {
                    return obsOffsets[obsOffset];
                  } else if (militaryOffset) {
                    return 0;
                  } else {
                    var hm = parseInt(numOffset, 10);
                    var m = hm % 100, h = (hm - m) / 100;
                    return h * 60 + m;
                  }
                }
                function configFromRFC2822(config) {
                  var match = rfc2822.exec(preprocessRFC2822(config._i));
                  if (match) {
                    var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                    if (!checkWeekday(match[1], parsedArray, config)) {
                      return;
                    }
                    config._a = parsedArray;
                    config._tzm = calculateOffset(match[8], match[9], match[10]);
                    config._d = createUTCDate.apply(null, config._a);
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    getParsingFlags(config).rfc2822 = true;
                  } else {
                    config._isValid = false;
                  }
                }
                function configFromString(config) {
                  var matched = aspNetJsonRegex.exec(config._i);
                  if (matched !== null) {
                    config._d = /* @__PURE__ */ new Date(+matched[1]);
                    return;
                  }
                  configFromISO(config);
                  if (config._isValid === false) {
                    delete config._isValid;
                  } else {
                    return;
                  }
                  configFromRFC2822(config);
                  if (config._isValid === false) {
                    delete config._isValid;
                  } else {
                    return;
                  }
                  hooks.createFromInputFallback(config);
                }
                hooks.createFromInputFallback = deprecate(
                  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
                  function(config) {
                    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
                  }
                );
                hooks.ISO_8601 = function() {
                };
                hooks.RFC_2822 = function() {
                };
                function configFromStringAndFormat(config) {
                  if (config._f === hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                  }
                  if (config._f === hooks.RFC_2822) {
                    configFromRFC2822(config);
                    return;
                  }
                  config._a = [];
                  getParsingFlags(config).empty = true;
                  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0;
                  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                  for (i = 0; i < tokens2.length; i++) {
                    token2 = tokens2[i];
                    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
                    if (parsedInput) {
                      skipped = string.substr(0, string.indexOf(parsedInput));
                      if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                      }
                      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                      totalParsedInputLength += parsedInput.length;
                    }
                    if (formatTokenFunctions[token2]) {
                      if (parsedInput) {
                        getParsingFlags(config).empty = false;
                      } else {
                        getParsingFlags(config).unusedTokens.push(token2);
                      }
                      addTimeToArrayFromToken(token2, parsedInput, config);
                    } else if (config._strict && !parsedInput) {
                      getParsingFlags(config).unusedTokens.push(token2);
                    }
                  }
                  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                  if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                  }
                  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
                    getParsingFlags(config).bigHour = void 0;
                  }
                  getParsingFlags(config).parsedDateParts = config._a.slice(0);
                  getParsingFlags(config).meridiem = config._meridiem;
                  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
                  configFromArray(config);
                  checkOverflow(config);
                }
                function meridiemFixWrap(locale2, hour, meridiem2) {
                  var isPm;
                  if (meridiem2 == null) {
                    return hour;
                  }
                  if (locale2.meridiemHour != null) {
                    return locale2.meridiemHour(hour, meridiem2);
                  } else if (locale2.isPM != null) {
                    isPm = locale2.isPM(meridiem2);
                    if (isPm && hour < 12) {
                      hour += 12;
                    }
                    if (!isPm && hour === 12) {
                      hour = 0;
                    }
                    return hour;
                  } else {
                    return hour;
                  }
                }
                function configFromStringAndArray(config) {
                  var tempConfig, bestMoment, scoreToBeat, i, currentScore;
                  if (config._f.length === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = /* @__PURE__ */ new Date(NaN);
                    return;
                  }
                  for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                      tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i];
                    configFromStringAndFormat(tempConfig);
                    if (!isValid(tempConfig)) {
                      continue;
                    }
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
                    getParsingFlags(tempConfig).score = currentScore;
                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                    }
                  }
                  extend(config, bestMoment || tempConfig);
                }
                function configFromObject(config) {
                  if (config._d) {
                    return;
                  }
                  var i = normalizeObjectUnits(config._i);
                  config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
                    return obj && parseInt(obj, 10);
                  });
                  configFromArray(config);
                }
                function createFromConfig(config) {
                  var res = new Moment(checkOverflow(prepareConfig(config)));
                  if (res._nextDay) {
                    res.add(1, "d");
                    res._nextDay = void 0;
                  }
                  return res;
                }
                function prepareConfig(config) {
                  var input = config._i, format2 = config._f;
                  config._locale = config._locale || getLocale(config._l);
                  if (input === null || format2 === void 0 && input === "") {
                    return createInvalid({ nullInput: true });
                  }
                  if (typeof input === "string") {
                    config._i = input = config._locale.preparse(input);
                  }
                  if (isMoment(input)) {
                    return new Moment(checkOverflow(input));
                  } else if (isDate(input)) {
                    config._d = input;
                  } else if (isArray(format2)) {
                    configFromStringAndArray(config);
                  } else if (format2) {
                    configFromStringAndFormat(config);
                  } else {
                    configFromInput(config);
                  }
                  if (!isValid(config)) {
                    config._d = null;
                  }
                  return config;
                }
                function configFromInput(config) {
                  var input = config._i;
                  if (isUndefined(input)) {
                    config._d = new Date(hooks.now());
                  } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                  } else if (typeof input === "string") {
                    configFromString(config);
                  } else if (isArray(input)) {
                    config._a = map(input.slice(0), function(obj) {
                      return parseInt(obj, 10);
                    });
                    configFromArray(config);
                  } else if (isObject(input)) {
                    configFromObject(config);
                  } else if (isNumber(input)) {
                    config._d = new Date(input);
                  } else {
                    hooks.createFromInputFallback(config);
                  }
                }
                function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
                  var c = {};
                  if (locale2 === true || locale2 === false) {
                    strict = locale2;
                    locale2 = void 0;
                  }
                  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
                    input = void 0;
                  }
                  c._isAMomentObject = true;
                  c._useUTC = c._isUTC = isUTC;
                  c._l = locale2;
                  c._i = input;
                  c._f = format2;
                  c._strict = strict;
                  return createFromConfig(c);
                }
                function createLocal(input, format2, locale2, strict) {
                  return createLocalOrUTC(input, format2, locale2, strict, false);
                }
                var prototypeMin = deprecate(
                  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
                  function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                    } else {
                      return createInvalid();
                    }
                  }
                );
                var prototypeMax = deprecate(
                  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
                  function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                    } else {
                      return createInvalid();
                    }
                  }
                );
                function pickBy(fn, moments) {
                  var res, i;
                  if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0];
                  }
                  if (!moments.length) {
                    return createLocal();
                  }
                  res = moments[0];
                  for (i = 1; i < moments.length; ++i) {
                    if (!moments[i].isValid() || moments[i][fn](res)) {
                      res = moments[i];
                    }
                  }
                  return res;
                }
                function min() {
                  var args = [].slice.call(arguments, 0);
                  return pickBy("isBefore", args);
                }
                function max() {
                  var args = [].slice.call(arguments, 0);
                  return pickBy("isAfter", args);
                }
                var now = function() {
                  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
                };
                var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
                function isDurationValid(m) {
                  for (var key in m) {
                    if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                      return false;
                    }
                  }
                  var unitHasDecimal = false;
                  for (var i = 0; i < ordering.length; ++i) {
                    if (m[ordering[i]]) {
                      if (unitHasDecimal) {
                        return false;
                      }
                      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                      }
                    }
                  }
                  return true;
                }
                function isValid$1() {
                  return this._isValid;
                }
                function createInvalid$1() {
                  return createDuration(NaN);
                }
                function Duration(duration) {
                  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
                  this._isValid = isDurationValid(normalizedInput);
                  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
                  minutes2 * 6e4 + // 1000 * 60
                  hours2 * 1e3 * 60 * 60;
                  this._days = +days2 + weeks2 * 7;
                  this._months = +months2 + quarters * 3 + years2 * 12;
                  this._data = {};
                  this._locale = getLocale();
                  this._bubble();
                }
                function isDuration(obj) {
                  return obj instanceof Duration;
                }
                function absRound(number) {
                  if (number < 0) {
                    return Math.round(-1 * number) * -1;
                  } else {
                    return Math.round(number);
                  }
                }
                function offset(token2, separator) {
                  addFormatToken(token2, 0, 0, function() {
                    var offset2 = this.utcOffset();
                    var sign2 = "+";
                    if (offset2 < 0) {
                      offset2 = -offset2;
                      sign2 = "-";
                    }
                    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
                  });
                }
                offset("Z", ":");
                offset("ZZ", "");
                addRegexToken("Z", matchShortOffset);
                addRegexToken("ZZ", matchShortOffset);
                addParseToken(["Z", "ZZ"], function(input, array, config) {
                  config._useUTC = true;
                  config._tzm = offsetFromString(matchShortOffset, input);
                });
                var chunkOffset = /([\+\-]|\d\d)/gi;
                function offsetFromString(matcher, string) {
                  var matches = (string || "").match(matcher);
                  if (matches === null) {
                    return null;
                  }
                  var chunk = matches[matches.length - 1] || [];
                  var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
                  var minutes2 = +(parts[1] * 60) + toInt(parts[2]);
                  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
                }
                function cloneWithOffset(input, model) {
                  var res, diff2;
                  if (model._isUTC) {
                    res = model.clone();
                    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                    res._d.setTime(res._d.valueOf() + diff2);
                    hooks.updateOffset(res, false);
                    return res;
                  } else {
                    return createLocal(input).local();
                  }
                }
                function getDateOffset(m) {
                  return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
                }
                hooks.updateOffset = function() {
                };
                function getSetOffset(input, keepLocalTime, keepMinutes) {
                  var offset2 = this._offset || 0, localAdjust;
                  if (!this.isValid()) {
                    return input != null ? this : NaN;
                  }
                  if (input != null) {
                    if (typeof input === "string") {
                      input = offsetFromString(matchShortOffset, input);
                      if (input === null) {
                        return this;
                      }
                    } else if (Math.abs(input) < 16 && !keepMinutes) {
                      input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                      localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                      this.add(localAdjust, "m");
                    }
                    if (offset2 !== input) {
                      if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(this, createDuration(input - offset2, "m"), 1, false);
                      } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                      }
                    }
                    return this;
                  } else {
                    return this._isUTC ? offset2 : getDateOffset(this);
                  }
                }
                function getSetZone(input, keepLocalTime) {
                  if (input != null) {
                    if (typeof input !== "string") {
                      input = -input;
                    }
                    this.utcOffset(input, keepLocalTime);
                    return this;
                  } else {
                    return -this.utcOffset();
                  }
                }
                function setOffsetToUTC(keepLocalTime) {
                  return this.utcOffset(0, keepLocalTime);
                }
                function setOffsetToLocal(keepLocalTime) {
                  if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;
                    if (keepLocalTime) {
                      this.subtract(getDateOffset(this), "m");
                    }
                  }
                  return this;
                }
                function setOffsetToParsedOffset() {
                  if (this._tzm != null) {
                    this.utcOffset(this._tzm, false, true);
                  } else if (typeof this._i === "string") {
                    var tZone = offsetFromString(matchOffset, this._i);
                    if (tZone != null) {
                      this.utcOffset(tZone);
                    } else {
                      this.utcOffset(0, true);
                    }
                  }
                  return this;
                }
                function hasAlignedHourOffset(input) {
                  if (!this.isValid()) {
                    return false;
                  }
                  input = input ? createLocal(input).utcOffset() : 0;
                  return (this.utcOffset() - input) % 60 === 0;
                }
                function isDaylightSavingTime() {
                  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
                }
                function isDaylightSavingTimeShifted() {
                  if (!isUndefined(this._isDSTShifted)) {
                    return this._isDSTShifted;
                  }
                  var c = {};
                  copyConfig(c, this);
                  c = prepareConfig(c);
                  if (c._a) {
                    var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                  } else {
                    this._isDSTShifted = false;
                  }
                  return this._isDSTShifted;
                }
                function isLocal() {
                  return this.isValid() ? !this._isUTC : false;
                }
                function isUtcOffset() {
                  return this.isValid() ? this._isUTC : false;
                }
                function isUtc() {
                  return this.isValid() ? this._isUTC && this._offset === 0 : false;
                }
                var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
                var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
                function createDuration(input, key) {
                  var duration = input, match = null, sign2, ret, diffRes;
                  if (isDuration(input)) {
                    duration = {
                      ms: input._milliseconds,
                      d: input._days,
                      M: input._months
                    };
                  } else if (isNumber(input)) {
                    duration = {};
                    if (key) {
                      duration[key] = input;
                    } else {
                      duration.milliseconds = input;
                    }
                  } else if (!!(match = aspNetRegex.exec(input))) {
                    sign2 = match[1] === "-" ? -1 : 1;
                    duration = {
                      y: 0,
                      d: toInt(match[DATE]) * sign2,
                      h: toInt(match[HOUR]) * sign2,
                      m: toInt(match[MINUTE]) * sign2,
                      s: toInt(match[SECOND]) * sign2,
                      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
                      // the millisecond decimal point is included in the match
                    };
                  } else if (!!(match = isoRegex.exec(input))) {
                    sign2 = match[1] === "-" ? -1 : match[1] === "+" ? 1 : 1;
                    duration = {
                      y: parseIso(match[2], sign2),
                      M: parseIso(match[3], sign2),
                      w: parseIso(match[4], sign2),
                      d: parseIso(match[5], sign2),
                      h: parseIso(match[6], sign2),
                      m: parseIso(match[7], sign2),
                      s: parseIso(match[8], sign2)
                    };
                  } else if (duration == null) {
                    duration = {};
                  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
                    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                  }
                  ret = new Duration(duration);
                  if (isDuration(input) && hasOwnProp(input, "_locale")) {
                    ret._locale = input._locale;
                  }
                  return ret;
                }
                createDuration.fn = Duration.prototype;
                createDuration.invalid = createInvalid$1;
                function parseIso(inp, sign2) {
                  var res = inp && parseFloat(inp.replace(",", "."));
                  return (isNaN(res) ? 0 : res) * sign2;
                }
                function positiveMomentsDifference(base, other) {
                  var res = { milliseconds: 0, months: 0 };
                  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                  if (base.clone().add(res.months, "M").isAfter(other)) {
                    --res.months;
                  }
                  res.milliseconds = +other - +base.clone().add(res.months, "M");
                  return res;
                }
                function momentsDifference(base, other) {
                  var res;
                  if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                  }
                  other = cloneWithOffset(other, base);
                  if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                  } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                  }
                  return res;
                }
                function createAdder(direction, name) {
                  return function(val, period) {
                    var dur, tmp;
                    if (period !== null && !isNaN(+period)) {
                      deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
                      tmp = val;
                      val = period;
                      period = tmp;
                    }
                    val = typeof val === "string" ? +val : val;
                    dur = createDuration(val, period);
                    addSubtract(this, dur, direction);
                    return this;
                  };
                }
                function addSubtract(mom, duration, isAdding, updateOffset) {
                  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
                  if (!mom.isValid()) {
                    return;
                  }
                  updateOffset = updateOffset == null ? true : updateOffset;
                  if (months2) {
                    setMonth(mom, get(mom, "Month") + months2 * isAdding);
                  }
                  if (days2) {
                    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
                  }
                  if (milliseconds2) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
                  }
                  if (updateOffset) {
                    hooks.updateOffset(mom, days2 || months2);
                  }
                }
                var add = createAdder(1, "add");
                var subtract = createAdder(-1, "subtract");
                function getCalendarFormat(myMoment, now2) {
                  var diff2 = myMoment.diff(now2, "days", true);
                  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
                }
                function calendar$1(time, formats) {
                  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse";
                  var output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
                  return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
                }
                function clone() {
                  return new Moment(this);
                }
                function isAfter(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input);
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
                  if (units === "millisecond") {
                    return this.valueOf() > localInput.valueOf();
                  } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                  }
                }
                function isBefore(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input);
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
                  if (units === "millisecond") {
                    return this.valueOf() < localInput.valueOf();
                  } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                  }
                }
                function isBetween(from2, to2, units, inclusivity) {
                  inclusivity = inclusivity || "()";
                  return (inclusivity[0] === "(" ? this.isAfter(from2, units) : !this.isBefore(from2, units)) && (inclusivity[1] === ")" ? this.isBefore(to2, units) : !this.isAfter(to2, units));
                }
                function isSame(input, units) {
                  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
                  if (!(this.isValid() && localInput.isValid())) {
                    return false;
                  }
                  units = normalizeUnits(units || "millisecond");
                  if (units === "millisecond") {
                    return this.valueOf() === localInput.valueOf();
                  } else {
                    inputMs = localInput.valueOf();
                    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                  }
                }
                function isSameOrAfter(input, units) {
                  return this.isSame(input, units) || this.isAfter(input, units);
                }
                function isSameOrBefore(input, units) {
                  return this.isSame(input, units) || this.isBefore(input, units);
                }
                function diff(input, units, asFloat) {
                  var that, zoneDelta, delta, output;
                  if (!this.isValid()) {
                    return NaN;
                  }
                  that = cloneWithOffset(input, this);
                  if (!that.isValid()) {
                    return NaN;
                  }
                  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
                  units = normalizeUnits(units);
                  switch (units) {
                    case "year":
                      output = monthDiff(this, that) / 12;
                      break;
                    case "month":
                      output = monthDiff(this, that);
                      break;
                    case "quarter":
                      output = monthDiff(this, that) / 3;
                      break;
                    case "second":
                      output = (this - that) / 1e3;
                      break;
                    // 1000
                    case "minute":
                      output = (this - that) / 6e4;
                      break;
                    // 1000 * 60
                    case "hour":
                      output = (this - that) / 36e5;
                      break;
                    // 1000 * 60 * 60
                    case "day":
                      output = (this - that - zoneDelta) / 864e5;
                      break;
                    // 1000 * 60 * 60 * 24, negate dst
                    case "week":
                      output = (this - that - zoneDelta) / 6048e5;
                      break;
                    // 1000 * 60 * 60 * 24 * 7, negate dst
                    default:
                      output = this - that;
                  }
                  return asFloat ? output : absFloor(output);
                }
                function monthDiff(a, b) {
                  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
                  if (b - anchor < 0) {
                    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
                    adjust = (b - anchor) / (anchor - anchor2);
                  } else {
                    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
                    adjust = (b - anchor) / (anchor2 - anchor);
                  }
                  return -(wholeMonthDiff + adjust) || 0;
                }
                hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
                hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                function toString() {
                  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                }
                function toISOString() {
                  if (!this.isValid()) {
                    return null;
                  }
                  var m = this.clone().utc();
                  if (m.year() < 0 || m.year() > 9999) {
                    return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                  }
                  if (isFunction(Date.prototype.toISOString)) {
                    return this.toDate().toISOString();
                  }
                  return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
                }
                function inspect() {
                  if (!this.isValid()) {
                    return "moment.invalid(/* " + this._i + " */)";
                  }
                  var func = "moment";
                  var zone = "";
                  if (!this.isLocal()) {
                    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
                    zone = "Z";
                  }
                  var prefix = "[" + func + '("]';
                  var year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
                  var datetime = "-MM-DD[T]HH:mm:ss.SSS";
                  var suffix = zone + '[")]';
                  return this.format(prefix + year + datetime + suffix);
                }
                function format(inputString) {
                  if (!inputString) {
                    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                  }
                  var output = formatMoment(this, inputString);
                  return this.localeData().postformat(output);
                }
                function from(time, withoutSuffix) {
                  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
                    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                  } else {
                    return this.localeData().invalidDate();
                  }
                }
                function fromNow(withoutSuffix) {
                  return this.from(createLocal(), withoutSuffix);
                }
                function to(time, withoutSuffix) {
                  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
                    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                  } else {
                    return this.localeData().invalidDate();
                  }
                }
                function toNow(withoutSuffix) {
                  return this.to(createLocal(), withoutSuffix);
                }
                function locale(key) {
                  var newLocaleData;
                  if (key === void 0) {
                    return this._locale._abbr;
                  } else {
                    newLocaleData = getLocale(key);
                    if (newLocaleData != null) {
                      this._locale = newLocaleData;
                    }
                    return this;
                  }
                }
                var lang = deprecate(
                  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
                  function(key) {
                    if (key === void 0) {
                      return this.localeData();
                    } else {
                      return this.locale(key);
                    }
                  }
                );
                function localeData() {
                  return this._locale;
                }
                function startOf(units) {
                  units = normalizeUnits(units);
                  switch (units) {
                    case "year":
                      this.month(0);
                    /* falls through */
                    case "quarter":
                    case "month":
                      this.date(1);
                    /* falls through */
                    case "week":
                    case "isoWeek":
                    case "day":
                    case "date":
                      this.hours(0);
                    /* falls through */
                    case "hour":
                      this.minutes(0);
                    /* falls through */
                    case "minute":
                      this.seconds(0);
                    /* falls through */
                    case "second":
                      this.milliseconds(0);
                  }
                  if (units === "week") {
                    this.weekday(0);
                  }
                  if (units === "isoWeek") {
                    this.isoWeekday(1);
                  }
                  if (units === "quarter") {
                    this.month(Math.floor(this.month() / 3) * 3);
                  }
                  return this;
                }
                function endOf(units) {
                  units = normalizeUnits(units);
                  if (units === void 0 || units === "millisecond") {
                    return this;
                  }
                  if (units === "date") {
                    units = "day";
                  }
                  return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
                }
                function valueOf() {
                  return this._d.valueOf() - (this._offset || 0) * 6e4;
                }
                function unix() {
                  return Math.floor(this.valueOf() / 1e3);
                }
                function toDate() {
                  return new Date(this.valueOf());
                }
                function toArray() {
                  var m = this;
                  return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
                }
                function toObject() {
                  var m = this;
                  return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                  };
                }
                function toJSON() {
                  return this.isValid() ? this.toISOString() : null;
                }
                function isValid$2() {
                  return isValid(this);
                }
                function parsingFlags() {
                  return extend({}, getParsingFlags(this));
                }
                function invalidAt() {
                  return getParsingFlags(this).overflow;
                }
                function creationData() {
                  return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                  };
                }
                addFormatToken(0, ["gg", 2], 0, function() {
                  return this.weekYear() % 100;
                });
                addFormatToken(0, ["GG", 2], 0, function() {
                  return this.isoWeekYear() % 100;
                });
                function addWeekYearFormatToken(token2, getter) {
                  addFormatToken(0, [token2, token2.length], 0, getter);
                }
                addWeekYearFormatToken("gggg", "weekYear");
                addWeekYearFormatToken("ggggg", "weekYear");
                addWeekYearFormatToken("GGGG", "isoWeekYear");
                addWeekYearFormatToken("GGGGG", "isoWeekYear");
                addUnitAlias("weekYear", "gg");
                addUnitAlias("isoWeekYear", "GG");
                addUnitPriority("weekYear", 1);
                addUnitPriority("isoWeekYear", 1);
                addRegexToken("G", matchSigned);
                addRegexToken("g", matchSigned);
                addRegexToken("GG", match1to2, match2);
                addRegexToken("gg", match1to2, match2);
                addRegexToken("GGGG", match1to4, match4);
                addRegexToken("gggg", match1to4, match4);
                addRegexToken("GGGGG", match1to6, match6);
                addRegexToken("ggggg", match1to6, match6);
                addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
                  week[token2.substr(0, 2)] = toInt(input);
                });
                addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
                  week[token2] = hooks.parseTwoDigitYear(input);
                });
                function getSetWeekYear(input) {
                  return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.week(),
                    this.weekday(),
                    this.localeData()._week.dow,
                    this.localeData()._week.doy
                  );
                }
                function getSetISOWeekYear(input) {
                  return getSetWeekYearHelper.call(
                    this,
                    input,
                    this.isoWeek(),
                    this.isoWeekday(),
                    1,
                    4
                  );
                }
                function getISOWeeksInYear() {
                  return weeksInYear(this.year(), 1, 4);
                }
                function getWeeksInYear() {
                  var weekInfo = this.localeData()._week;
                  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }
                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                  var weeksTarget;
                  if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                  } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                      week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                  }
                }
                function setWeekAll(weekYear, week, weekday, dow, doy) {
                  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                  this.year(date.getUTCFullYear());
                  this.month(date.getUTCMonth());
                  this.date(date.getUTCDate());
                  return this;
                }
                addFormatToken("Q", 0, "Qo", "quarter");
                addUnitAlias("quarter", "Q");
                addUnitPriority("quarter", 7);
                addRegexToken("Q", match1);
                addParseToken("Q", function(input, array) {
                  array[MONTH] = (toInt(input) - 1) * 3;
                });
                function getSetQuarter(input) {
                  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
                }
                addFormatToken("D", ["DD", 2], "Do", "date");
                addUnitAlias("date", "D");
                addUnitPriority("date", 9);
                addRegexToken("D", match1to2);
                addRegexToken("DD", match1to2, match2);
                addRegexToken("Do", function(isStrict, locale2) {
                  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
                });
                addParseToken(["D", "DD"], DATE);
                addParseToken("Do", function(input, array) {
                  array[DATE] = toInt(input.match(match1to2)[0], 10);
                });
                var getSetDayOfMonth = makeGetSet("Date", true);
                addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
                addUnitAlias("dayOfYear", "DDD");
                addUnitPriority("dayOfYear", 4);
                addRegexToken("DDD", match1to3);
                addRegexToken("DDDD", match3);
                addParseToken(["DDD", "DDDD"], function(input, array, config) {
                  config._dayOfYear = toInt(input);
                });
                function getSetDayOfYear(input) {
                  var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
                }
                addFormatToken("m", ["mm", 2], 0, "minute");
                addUnitAlias("minute", "m");
                addUnitPriority("minute", 14);
                addRegexToken("m", match1to2);
                addRegexToken("mm", match1to2, match2);
                addParseToken(["m", "mm"], MINUTE);
                var getSetMinute = makeGetSet("Minutes", false);
                addFormatToken("s", ["ss", 2], 0, "second");
                addUnitAlias("second", "s");
                addUnitPriority("second", 15);
                addRegexToken("s", match1to2);
                addRegexToken("ss", match1to2, match2);
                addParseToken(["s", "ss"], SECOND);
                var getSetSecond = makeGetSet("Seconds", false);
                addFormatToken("S", 0, 0, function() {
                  return ~~(this.millisecond() / 100);
                });
                addFormatToken(0, ["SS", 2], 0, function() {
                  return ~~(this.millisecond() / 10);
                });
                addFormatToken(0, ["SSS", 3], 0, "millisecond");
                addFormatToken(0, ["SSSS", 4], 0, function() {
                  return this.millisecond() * 10;
                });
                addFormatToken(0, ["SSSSS", 5], 0, function() {
                  return this.millisecond() * 100;
                });
                addFormatToken(0, ["SSSSSS", 6], 0, function() {
                  return this.millisecond() * 1e3;
                });
                addFormatToken(0, ["SSSSSSS", 7], 0, function() {
                  return this.millisecond() * 1e4;
                });
                addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
                  return this.millisecond() * 1e5;
                });
                addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
                  return this.millisecond() * 1e6;
                });
                addUnitAlias("millisecond", "ms");
                addUnitPriority("millisecond", 16);
                addRegexToken("S", match1to3, match1);
                addRegexToken("SS", match1to3, match2);
                addRegexToken("SSS", match1to3, match3);
                var token;
                for (token = "SSSS"; token.length <= 9; token += "S") {
                  addRegexToken(token, matchUnsigned);
                }
                function parseMs(input, array) {
                  array[MILLISECOND] = toInt(("0." + input) * 1e3);
                }
                for (token = "S"; token.length <= 9; token += "S") {
                  addParseToken(token, parseMs);
                }
                var getSetMillisecond = makeGetSet("Milliseconds", false);
                addFormatToken("z", 0, 0, "zoneAbbr");
                addFormatToken("zz", 0, 0, "zoneName");
                function getZoneAbbr() {
                  return this._isUTC ? "UTC" : "";
                }
                function getZoneName() {
                  return this._isUTC ? "Coordinated Universal Time" : "";
                }
                var proto = Moment.prototype;
                proto.add = add;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$2;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;
                proto.quarter = proto.quarters = getSetQuarter;
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.isoWeeksInYear = getISOWeeksInYear;
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;
                proto.hour = proto.hours = getSetHour;
                proto.minute = proto.minutes = getSetMinute;
                proto.second = proto.seconds = getSetSecond;
                proto.millisecond = proto.milliseconds = getSetMillisecond;
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;
                proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
                proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
                proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
                proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
                proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
                function createUnix(input) {
                  return createLocal(input * 1e3);
                }
                function createInZone() {
                  return createLocal.apply(null, arguments).parseZone();
                }
                function preParsePostFormat(string) {
                  return string;
                }
                var proto$1 = Locale.prototype;
                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;
                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;
                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;
                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;
                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;
                function get$1(format2, index, field, setter) {
                  var locale2 = getLocale();
                  var utc = createUTC().set(setter, index);
                  return locale2[field](utc, format2);
                }
                function listMonthsImpl(format2, index, field) {
                  if (isNumber(format2)) {
                    index = format2;
                    format2 = void 0;
                  }
                  format2 = format2 || "";
                  if (index != null) {
                    return get$1(format2, index, field, "month");
                  }
                  var i;
                  var out = [];
                  for (i = 0; i < 12; i++) {
                    out[i] = get$1(format2, i, field, "month");
                  }
                  return out;
                }
                function listWeekdaysImpl(localeSorted, format2, index, field) {
                  if (typeof localeSorted === "boolean") {
                    if (isNumber(format2)) {
                      index = format2;
                      format2 = void 0;
                    }
                    format2 = format2 || "";
                  } else {
                    format2 = localeSorted;
                    index = format2;
                    localeSorted = false;
                    if (isNumber(format2)) {
                      index = format2;
                      format2 = void 0;
                    }
                    format2 = format2 || "";
                  }
                  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0;
                  if (index != null) {
                    return get$1(format2, (index + shift) % 7, field, "day");
                  }
                  var i;
                  var out = [];
                  for (i = 0; i < 7; i++) {
                    out[i] = get$1(format2, (i + shift) % 7, field, "day");
                  }
                  return out;
                }
                function listMonths(format2, index) {
                  return listMonthsImpl(format2, index, "months");
                }
                function listMonthsShort(format2, index) {
                  return listMonthsImpl(format2, index, "monthsShort");
                }
                function listWeekdays(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
                }
                function listWeekdaysShort(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
                }
                function listWeekdaysMin(localeSorted, format2, index) {
                  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
                }
                getSetGlobalLocale("en", {
                  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                  ordinal: function(number) {
                    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                    return number + output;
                  }
                });
                hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
                hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
                var mathAbs = Math.abs;
                function abs() {
                  var data = this._data;
                  this._milliseconds = mathAbs(this._milliseconds);
                  this._days = mathAbs(this._days);
                  this._months = mathAbs(this._months);
                  data.milliseconds = mathAbs(data.milliseconds);
                  data.seconds = mathAbs(data.seconds);
                  data.minutes = mathAbs(data.minutes);
                  data.hours = mathAbs(data.hours);
                  data.months = mathAbs(data.months);
                  data.years = mathAbs(data.years);
                  return this;
                }
                function addSubtract$1(duration, input, value, direction) {
                  var other = createDuration(input, value);
                  duration._milliseconds += direction * other._milliseconds;
                  duration._days += direction * other._days;
                  duration._months += direction * other._months;
                  return duration._bubble();
                }
                function add$1(input, value) {
                  return addSubtract$1(this, input, value, 1);
                }
                function subtract$1(input, value) {
                  return addSubtract$1(this, input, value, -1);
                }
                function absCeil(number) {
                  if (number < 0) {
                    return Math.floor(number);
                  } else {
                    return Math.ceil(number);
                  }
                }
                function bubble() {
                  var milliseconds2 = this._milliseconds;
                  var days2 = this._days;
                  var months2 = this._months;
                  var data = this._data;
                  var seconds2, minutes2, hours2, years2, monthsFromDays;
                  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
                    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
                    days2 = 0;
                    months2 = 0;
                  }
                  data.milliseconds = milliseconds2 % 1e3;
                  seconds2 = absFloor(milliseconds2 / 1e3);
                  data.seconds = seconds2 % 60;
                  minutes2 = absFloor(seconds2 / 60);
                  data.minutes = minutes2 % 60;
                  hours2 = absFloor(minutes2 / 60);
                  data.hours = hours2 % 24;
                  days2 += absFloor(hours2 / 24);
                  monthsFromDays = absFloor(daysToMonths(days2));
                  months2 += monthsFromDays;
                  days2 -= absCeil(monthsToDays(monthsFromDays));
                  years2 = absFloor(months2 / 12);
                  months2 %= 12;
                  data.days = days2;
                  data.months = months2;
                  data.years = years2;
                  return this;
                }
                function daysToMonths(days2) {
                  return days2 * 4800 / 146097;
                }
                function monthsToDays(months2) {
                  return months2 * 146097 / 4800;
                }
                function as(units) {
                  if (!this.isValid()) {
                    return NaN;
                  }
                  var days2;
                  var months2;
                  var milliseconds2 = this._milliseconds;
                  units = normalizeUnits(units);
                  if (units === "month" || units === "year") {
                    days2 = this._days + milliseconds2 / 864e5;
                    months2 = this._months + daysToMonths(days2);
                    return units === "month" ? months2 : months2 / 12;
                  } else {
                    days2 = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                      case "week":
                        return days2 / 7 + milliseconds2 / 6048e5;
                      case "day":
                        return days2 + milliseconds2 / 864e5;
                      case "hour":
                        return days2 * 24 + milliseconds2 / 36e5;
                      case "minute":
                        return days2 * 1440 + milliseconds2 / 6e4;
                      case "second":
                        return days2 * 86400 + milliseconds2 / 1e3;
                      // Math.floor prevents floating point math errors here
                      case "millisecond":
                        return Math.floor(days2 * 864e5) + milliseconds2;
                      default:
                        throw new Error("Unknown unit " + units);
                    }
                  }
                }
                function valueOf$1() {
                  if (!this.isValid()) {
                    return NaN;
                  }
                  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
                }
                function makeAs(alias) {
                  return function() {
                    return this.as(alias);
                  };
                }
                var asMilliseconds = makeAs("ms");
                var asSeconds = makeAs("s");
                var asMinutes = makeAs("m");
                var asHours = makeAs("h");
                var asDays = makeAs("d");
                var asWeeks = makeAs("w");
                var asMonths = makeAs("M");
                var asYears = makeAs("y");
                function clone$1() {
                  return createDuration(this);
                }
                function get$2(units) {
                  units = normalizeUnits(units);
                  return this.isValid() ? this[units + "s"]() : NaN;
                }
                function makeGetter(name) {
                  return function() {
                    return this.isValid() ? this._data[name] : NaN;
                  };
                }
                var milliseconds = makeGetter("milliseconds");
                var seconds = makeGetter("seconds");
                var minutes = makeGetter("minutes");
                var hours = makeGetter("hours");
                var days = makeGetter("days");
                var months = makeGetter("months");
                var years = makeGetter("years");
                function weeks() {
                  return absFloor(this.days() / 7);
                }
                var round = Math.round;
                var thresholds = {
                  ss: 44,
                  // a few seconds to seconds
                  s: 45,
                  // seconds to minute
                  m: 45,
                  // minutes to hour
                  h: 22,
                  // hours to day
                  d: 26,
                  // days to month
                  M: 11
                  // months to year
                };
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
                  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }
                function relativeTime$1(posNegDuration, withoutSuffix, locale2) {
                  var duration = createDuration(posNegDuration).abs();
                  var seconds2 = round(duration.as("s"));
                  var minutes2 = round(duration.as("m"));
                  var hours2 = round(duration.as("h"));
                  var days2 = round(duration.as("d"));
                  var months2 = round(duration.as("M"));
                  var years2 = round(duration.as("y"));
                  var a = seconds2 <= thresholds.ss && ["s", seconds2] || seconds2 < thresholds.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds.d && ["dd", days2] || months2 <= 1 && ["M"] || months2 < thresholds.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
                  a[2] = withoutSuffix;
                  a[3] = +posNegDuration > 0;
                  a[4] = locale2;
                  return substituteTimeAgo.apply(null, a);
                }
                function getSetRelativeTimeRounding(roundingFunction) {
                  if (roundingFunction === void 0) {
                    return round;
                  }
                  if (typeof roundingFunction === "function") {
                    round = roundingFunction;
                    return true;
                  }
                  return false;
                }
                function getSetRelativeTimeThreshold(threshold, limit) {
                  if (thresholds[threshold] === void 0) {
                    return false;
                  }
                  if (limit === void 0) {
                    return thresholds[threshold];
                  }
                  thresholds[threshold] = limit;
                  if (threshold === "s") {
                    thresholds.ss = limit - 1;
                  }
                  return true;
                }
                function humanize(withSuffix) {
                  if (!this.isValid()) {
                    return this.localeData().invalidDate();
                  }
                  var locale2 = this.localeData();
                  var output = relativeTime$1(this, !withSuffix, locale2);
                  if (withSuffix) {
                    output = locale2.pastFuture(+this, output);
                  }
                  return locale2.postformat(output);
                }
                var abs$1 = Math.abs;
                function sign(x) {
                  return (x > 0) - (x < 0) || +x;
                }
                function toISOString$1() {
                  if (!this.isValid()) {
                    return this.localeData().invalidDate();
                  }
                  var seconds2 = abs$1(this._milliseconds) / 1e3;
                  var days2 = abs$1(this._days);
                  var months2 = abs$1(this._months);
                  var minutes2, hours2, years2;
                  minutes2 = absFloor(seconds2 / 60);
                  hours2 = absFloor(minutes2 / 60);
                  seconds2 %= 60;
                  minutes2 %= 60;
                  years2 = absFloor(months2 / 12);
                  months2 %= 12;
                  var Y = years2;
                  var M = months2;
                  var D = days2;
                  var h = hours2;
                  var m = minutes2;
                  var s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
                  var total = this.asSeconds();
                  if (!total) {
                    return "P0D";
                  }
                  var totalSign = total < 0 ? "-" : "";
                  var ymSign = sign(this._months) !== sign(total) ? "-" : "";
                  var daysSign = sign(this._days) !== sign(total) ? "-" : "";
                  var hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
                  return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "");
                }
                var proto$2 = Duration.prototype;
                proto$2.isValid = isValid$1;
                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.clone = clone$1;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;
                proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
                proto$2.lang = lang;
                addFormatToken("X", 0, 0, "unix");
                addFormatToken("x", 0, 0, "valueOf");
                addRegexToken("x", matchSigned);
                addRegexToken("X", matchTimestamp);
                addParseToken("X", function(input, array, config) {
                  config._d = new Date(parseFloat(input, 10) * 1e3);
                });
                addParseToken("x", function(input, array, config) {
                  config._d = new Date(toInt(input));
                });
                hooks.version = "2.19.1";
                setHookCallback(createLocal);
                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;
                return hooks;
              });
            }).call(exports2, __webpack_require__(155)(module2));
          },
          /* 155 */
          /***/
          function(module2, exports2) {
            module2.exports = function(module3) {
              if (!module3.webpackPolyfill) {
                module3.deprecate = function() {
                };
                module3.paths = [];
                if (!module3.children) module3.children = [];
                Object.defineProperty(module3, "loaded", {
                  enumerable: true,
                  get: function() {
                    return module3.l;
                  }
                });
                Object.defineProperty(module3, "id", {
                  enumerable: true,
                  get: function() {
                    return module3.i;
                  }
                });
                module3.webpackPolyfill = 1;
              }
              return module3;
            };
          },
          /* 156 */
          /***/
          function(module2, exports2) {
            function webpackEmptyContext(req) {
              throw new Error("Cannot find module '" + req + "'.");
            }
            webpackEmptyContext.keys = function() {
              return [];
            };
            webpackEmptyContext.resolve = webpackEmptyContext;
            module2.exports = webpackEmptyContext;
            webpackEmptyContext.id = 156;
          },
          /* 157 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(global) {
              var _rng;
              var globalVar = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : null;
              if (globalVar && globalVar.crypto && crypto.getRandomValues) {
                var _rnds8 = new Uint8Array(16);
                _rng = function whatwgRNG() {
                  crypto.getRandomValues(_rnds8);
                  return _rnds8;
                };
              }
              if (!_rng) {
                var _rnds = new Array(16);
                _rng = function _rng2() {
                  for (var i2 = 0, r; i2 < 16; i2++) {
                    if ((i2 & 3) === 0) r = Math.random() * 4294967296;
                    _rnds[i2] = r >>> ((i2 & 3) << 3) & 255;
                  }
                  return _rnds;
                };
              }
              var _byteToHex = [];
              var _hexToByte = {};
              for (var i = 0; i < 256; i++) {
                _byteToHex[i] = (i + 256).toString(16).substr(1);
                _hexToByte[_byteToHex[i]] = i;
              }
              function parse(s, buf, offset) {
                var i2 = buf && offset || 0, ii = 0;
                buf = buf || [];
                s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
                  if (ii < 16) {
                    buf[i2 + ii++] = _hexToByte[oct];
                  }
                });
                while (ii < 16) {
                  buf[i2 + ii++] = 0;
                }
                return buf;
              }
              function unparse(buf, offset) {
                var i2 = offset || 0, bth = _byteToHex;
                return bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + "-" + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]] + bth[buf[i2++]];
              }
              var _seedBytes = _rng();
              var _nodeId = [_seedBytes[0] | 1, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
              var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 16383;
              var _lastMSecs = 0, _lastNSecs = 0;
              function v1(options, buf, offset) {
                var i2 = buf && offset || 0;
                var b = buf || [];
                options = options || {};
                var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
                var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
                var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
                var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
                if (dt < 0 && options.clockseq === void 0) {
                  clockseq = clockseq + 1 & 16383;
                }
                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
                  nsecs = 0;
                }
                if (nsecs >= 1e4) {
                  throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                }
                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq;
                msecs += 122192928e5;
                var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
                b[i2++] = tl >>> 24 & 255;
                b[i2++] = tl >>> 16 & 255;
                b[i2++] = tl >>> 8 & 255;
                b[i2++] = tl & 255;
                var tmh = msecs / 4294967296 * 1e4 & 268435455;
                b[i2++] = tmh >>> 8 & 255;
                b[i2++] = tmh & 255;
                b[i2++] = tmh >>> 24 & 15 | 16;
                b[i2++] = tmh >>> 16 & 255;
                b[i2++] = clockseq >>> 8 | 128;
                b[i2++] = clockseq & 255;
                var node = options.node || _nodeId;
                for (var n = 0; n < 6; n++) {
                  b[i2 + n] = node[n];
                }
                return buf ? buf : unparse(b);
              }
              function v4(options, buf, offset) {
                var i2 = buf && offset || 0;
                if (typeof options == "string") {
                  buf = options == "binary" ? new Array(16) : null;
                  options = null;
                }
                options = options || {};
                var rnds = options.random || (options.rng || _rng)();
                rnds[6] = rnds[6] & 15 | 64;
                rnds[8] = rnds[8] & 63 | 128;
                if (buf) {
                  for (var ii = 0; ii < 16; ii++) {
                    buf[i2 + ii] = rnds[ii];
                  }
                }
                return buf || unparse(rnds);
              }
              var uuid = v4;
              uuid.v1 = v1;
              uuid.v4 = v4;
              uuid.parse = parse;
              uuid.unparse = unparse;
              module2.exports = uuid;
            }).call(exports2, __webpack_require__(158));
          },
          /* 158 */
          /***/
          function(module2, exports2) {
            var g;
            g = /* @__PURE__ */ function() {
              return this;
            }();
            try {
              g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module2.exports = g;
          },
          /* 159 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.util = __webpack_require__(2);
            exports2.DOMutil = __webpack_require__(14);
            exports2.DataSet = __webpack_require__(11);
            exports2.DataView = __webpack_require__(12);
            exports2.Queue = __webpack_require__(43);
            exports2.Graph3d = __webpack_require__(161);
            exports2.graph3d = {
              Camera: __webpack_require__(95),
              Filter: __webpack_require__(96),
              Point2d: __webpack_require__(91),
              Point3d: __webpack_require__(34),
              Slider: __webpack_require__(92),
              StepNumber: __webpack_require__(93)
            };
            exports2.moment = __webpack_require__(9);
            exports2.Hammer = __webpack_require__(10);
            exports2.keycharm = __webpack_require__(35);
          },
          /* 160 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var core = __webpack_require__(7);
            var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
            module2.exports = function stringify(it) {
              return $JSON.stringify.apply($JSON, arguments);
            };
          },
          /* 161 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _assign = __webpack_require__(90);
            var _assign2 = _interopRequireDefault(_assign);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Emitter = __webpack_require__(44);
            var util = __webpack_require__(2);
            var Point3d = __webpack_require__(34);
            var Point2d = __webpack_require__(91);
            var Slider = __webpack_require__(92);
            var StepNumber = __webpack_require__(93);
            var Settings = __webpack_require__(94);
            var Validator = __webpack_require__(15)["default"];
            var _require = __webpack_require__(15), printStyle = _require.printStyle;
            var _require2 = __webpack_require__(172), allOptions = _require2.allOptions;
            var DataGroup = __webpack_require__(173);
            Graph3d.STYLE = Settings.STYLE;
            var autoByDefault = void 0;
            Graph3d.DEFAULTS = {
              width: "400px",
              height: "400px",
              filterLabel: "time",
              legendLabel: "value",
              xLabel: "x",
              yLabel: "y",
              zLabel: "z",
              xValueLabel: function xValueLabel(v) {
                return v;
              },
              yValueLabel: function yValueLabel(v) {
                return v;
              },
              zValueLabel: function zValueLabel(v) {
                return v;
              },
              showXAxis: true,
              showYAxis: true,
              showZAxis: true,
              showGrid: true,
              showPerspective: true,
              showShadow: false,
              keepAspectRatio: true,
              verticalRatio: 0.5,
              // 0.1 to 1.0, where 1.0 results in a 'cube'
              dotSizeRatio: 0.02,
              // size of the dots as a fraction of the graph width
              dotSizeMinFraction: 0.5,
              // size of min-value dot as a fraction of dotSizeRatio	
              dotSizeMaxFraction: 2.5,
              // size of max-value dot as a fraction of dotSizeRatio	
              showAnimationControls: autoByDefault,
              animationInterval: 1e3,
              // milliseconds
              animationPreload: false,
              animationAutoStart: autoByDefault,
              axisColor: "#4D4D4D",
              gridColor: "#D3D3D3",
              xCenter: "55%",
              yCenter: "50%",
              style: Graph3d.STYLE.DOT,
              tooltip: false,
              tooltipStyle: {
                content: {
                  padding: "10px",
                  border: "1px solid #4d4d4d",
                  color: "#1a1a1a",
                  background: "rgba(255,255,255,0.7)",
                  borderRadius: "2px",
                  boxShadow: "5px 5px 10px rgba(128,128,128,0.5)"
                },
                line: {
                  height: "40px",
                  width: "0",
                  borderLeft: "1px solid #4d4d4d"
                },
                dot: {
                  height: "0",
                  width: "0",
                  border: "5px solid #4d4d4d",
                  borderRadius: "5px"
                }
              },
              dataColor: {
                fill: "#7DC1FF",
                stroke: "#3267D2",
                strokeWidth: 1
                // px
              },
              cameraPosition: {
                horizontal: 1,
                vertical: 0.5,
                distance: 1.7
              },
              /*
                The following fields are 'auto by default', see above.
               */
              showLegend: autoByDefault,
              // determined by graph style
              backgroundColor: autoByDefault,
              xBarWidth: autoByDefault,
              yBarWidth: autoByDefault,
              valueMin: autoByDefault,
              valueMax: autoByDefault,
              xMin: autoByDefault,
              xMax: autoByDefault,
              xStep: autoByDefault,
              yMin: autoByDefault,
              yMax: autoByDefault,
              yStep: autoByDefault,
              zMin: autoByDefault,
              zMax: autoByDefault,
              zStep: autoByDefault
            };
            function Graph3d(container, data, options) {
              if (!(this instanceof Graph3d)) {
                throw new SyntaxError("Constructor must be called with the new operator");
              }
              this.containerElement = container;
              this.dataGroup = new DataGroup();
              this.dataPoints = null;
              this.create();
              Settings.setDefaults(Graph3d.DEFAULTS, this);
              this.colX = void 0;
              this.colY = void 0;
              this.colZ = void 0;
              this.colValue = void 0;
              this.setOptions(options);
              this.setData(data);
            }
            Emitter(Graph3d.prototype);
            Graph3d.prototype._setScale = function() {
              this.scale = new Point3d(1 / this.xRange.range(), 1 / this.yRange.range(), 1 / this.zRange.range());
              if (this.keepAspectRatio) {
                if (this.scale.x < this.scale.y) {
                  this.scale.y = this.scale.x;
                } else {
                  this.scale.x = this.scale.y;
                }
              }
              this.scale.z *= this.verticalRatio;
              if (this.valueRange !== void 0) {
                this.scale.value = 1 / this.valueRange.range();
              }
              var xCenter = this.xRange.center() * this.scale.x;
              var yCenter = this.yRange.center() * this.scale.y;
              var zCenter = this.zRange.center() * this.scale.z;
              this.camera.setArmLocation(xCenter, yCenter, zCenter);
            };
            Graph3d.prototype._convert3Dto2D = function(point3d) {
              var translation = this._convertPointToTranslation(point3d);
              return this._convertTranslationToScreen(translation);
            };
            Graph3d.prototype._convertPointToTranslation = function(point3d) {
              var cameraLocation = this.camera.getCameraLocation(), cameraRotation = this.camera.getCameraRotation(), ax = point3d.x * this.scale.x, ay = point3d.y * this.scale.y, az = point3d.z * this.scale.z, cx = cameraLocation.x, cy = cameraLocation.y, cz = cameraLocation.z, sinTx = Math.sin(cameraRotation.x), cosTx = Math.cos(cameraRotation.x), sinTy = Math.sin(cameraRotation.y), cosTy = Math.cos(cameraRotation.y), sinTz = Math.sin(cameraRotation.z), cosTz = Math.cos(cameraRotation.z), dx = cosTy * (sinTz * (ay - cy) + cosTz * (ax - cx)) - sinTy * (az - cz), dy = sinTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) + cosTx * (cosTz * (ay - cy) - sinTz * (ax - cx)), dz = cosTx * (cosTy * (az - cz) + sinTy * (sinTz * (ay - cy) + cosTz * (ax - cx))) - sinTx * (cosTz * (ay - cy) - sinTz * (ax - cx));
              return new Point3d(dx, dy, dz);
            };
            Graph3d.prototype._convertTranslationToScreen = function(translation) {
              var ex = this.eye.x, ey = this.eye.y, ez = this.eye.z, dx = translation.x, dy = translation.y, dz = translation.z;
              var bx;
              var by;
              if (this.showPerspective) {
                bx = (dx - ex) * (ez / dz);
                by = (dy - ey) * (ez / dz);
              } else {
                bx = dx * -(ez / this.camera.getArmLength());
                by = dy * -(ez / this.camera.getArmLength());
              }
              return new Point2d(this.currentXCenter + bx * this.frame.canvas.clientWidth, this.currentYCenter - by * this.frame.canvas.clientWidth);
            };
            Graph3d.prototype._calcTranslations = function(points) {
              for (var i = 0; i < points.length; i++) {
                var point = points[i];
                point.trans = this._convertPointToTranslation(point.point);
                point.screen = this._convertTranslationToScreen(point.trans);
                var transBottom = this._convertPointToTranslation(point.bottom);
                point.dist = this.showPerspective ? transBottom.length() : -transBottom.z;
              }
              var sortDepth = function sortDepth2(a, b) {
                return b.dist - a.dist;
              };
              points.sort(sortDepth);
            };
            Graph3d.prototype._initializeRanges = function() {
              var dg = this.dataGroup;
              this.xRange = dg.xRange;
              this.yRange = dg.yRange;
              this.zRange = dg.zRange;
              this.valueRange = dg.valueRange;
              this.xStep = dg.xStep;
              this.yStep = dg.yStep;
              this.zStep = dg.zStep;
              this.xBarWidth = dg.xBarWidth;
              this.yBarWidth = dg.yBarWidth;
              this.colX = dg.colX;
              this.colY = dg.colY;
              this.colZ = dg.colZ;
              this.colValue = dg.colValue;
              this._setScale();
            };
            Graph3d.prototype.getDataPoints = function(data) {
              var dataPoints = [];
              for (var i = 0; i < data.length; i++) {
                var point = new Point3d();
                point.x = data[i][this.colX] || 0;
                point.y = data[i][this.colY] || 0;
                point.z = data[i][this.colZ] || 0;
                point.data = data[i];
                if (this.colValue !== void 0) {
                  point.value = data[i][this.colValue] || 0;
                }
                var obj = {};
                obj.point = point;
                obj.bottom = new Point3d(point.x, point.y, this.zRange.min);
                obj.trans = void 0;
                obj.screen = void 0;
                dataPoints.push(obj);
              }
              return dataPoints;
            };
            Graph3d.prototype._getDataPoints = function(data) {
              var x, y, i, obj;
              var dataPoints = [];
              if (this.style === Graph3d.STYLE.GRID || this.style === Graph3d.STYLE.SURFACE) {
                var dataX = this.dataGroup.getDistinctValues(this.colX, data);
                var dataY = this.dataGroup.getDistinctValues(this.colY, data);
                dataPoints = this.getDataPoints(data);
                var dataMatrix = [];
                for (i = 0; i < dataPoints.length; i++) {
                  obj = dataPoints[i];
                  var xIndex = dataX.indexOf(obj.point.x);
                  var yIndex = dataY.indexOf(obj.point.y);
                  if (dataMatrix[xIndex] === void 0) {
                    dataMatrix[xIndex] = [];
                  }
                  dataMatrix[xIndex][yIndex] = obj;
                }
                for (x = 0; x < dataMatrix.length; x++) {
                  for (y = 0; y < dataMatrix[x].length; y++) {
                    if (dataMatrix[x][y]) {
                      dataMatrix[x][y].pointRight = x < dataMatrix.length - 1 ? dataMatrix[x + 1][y] : void 0;
                      dataMatrix[x][y].pointTop = y < dataMatrix[x].length - 1 ? dataMatrix[x][y + 1] : void 0;
                      dataMatrix[x][y].pointCross = x < dataMatrix.length - 1 && y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : void 0;
                    }
                  }
                }
              } else {
                this._checkValueField(data);
                dataPoints = this.getDataPoints(data);
                if (this.style === Graph3d.STYLE.LINE) {
                  for (i = 0; i < dataPoints.length; i++) {
                    if (i > 0) {
                      dataPoints[i - 1].pointNext = dataPoints[i];
                    }
                  }
                }
              }
              return dataPoints;
            };
            Graph3d.prototype.create = function() {
              while (this.containerElement.hasChildNodes()) {
                this.containerElement.removeChild(this.containerElement.firstChild);
              }
              this.frame = document.createElement("div");
              this.frame.style.position = "relative";
              this.frame.style.overflow = "hidden";
              this.frame.canvas = document.createElement("canvas");
              this.frame.canvas.style.position = "relative";
              this.frame.appendChild(this.frame.canvas);
              {
                var noCanvas = document.createElement("DIV");
                noCanvas.style.color = "red";
                noCanvas.style.fontWeight = "bold";
                noCanvas.style.padding = "10px";
                noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
                this.frame.canvas.appendChild(noCanvas);
              }
              this.frame.filter = document.createElement("div");
              this.frame.filter.style.position = "absolute";
              this.frame.filter.style.bottom = "0px";
              this.frame.filter.style.left = "0px";
              this.frame.filter.style.width = "100%";
              this.frame.appendChild(this.frame.filter);
              var me = this;
              var onmousedown = function onmousedown2(event) {
                me._onMouseDown(event);
              };
              var ontouchstart = function ontouchstart2(event) {
                me._onTouchStart(event);
              };
              var onmousewheel = function onmousewheel2(event) {
                me._onWheel(event);
              };
              var ontooltip = function ontooltip2(event) {
                me._onTooltip(event);
              };
              var onclick = function onclick2(event) {
                me._onClick(event);
              };
              util.addEventListener(this.frame.canvas, "mousedown", onmousedown);
              util.addEventListener(this.frame.canvas, "touchstart", ontouchstart);
              util.addEventListener(this.frame.canvas, "mousewheel", onmousewheel);
              util.addEventListener(this.frame.canvas, "mousemove", ontooltip);
              util.addEventListener(this.frame.canvas, "click", onclick);
              this.containerElement.appendChild(this.frame);
            };
            Graph3d.prototype._setSize = function(width, height) {
              this.frame.style.width = width;
              this.frame.style.height = height;
              this._resizeCanvas();
            };
            Graph3d.prototype._resizeCanvas = function() {
              this.frame.canvas.style.width = "100%";
              this.frame.canvas.style.height = "100%";
              this.frame.canvas.width = this.frame.canvas.clientWidth;
              this.frame.canvas.height = this.frame.canvas.clientHeight;
              this.frame.filter.style.width = this.frame.canvas.clientWidth - 2 * 10 + "px";
            };
            Graph3d.prototype.animationStart = function() {
              if (!this.animationAutoStart || !this.dataGroup.dataFilter) return;
              if (!this.frame.filter || !this.frame.filter.slider) throw new Error("No animation available");
              this.frame.filter.slider.play();
            };
            Graph3d.prototype.animationStop = function() {
              if (!this.frame.filter || !this.frame.filter.slider) return;
              this.frame.filter.slider.stop();
            };
            Graph3d.prototype._resizeCenter = function() {
              if (this.xCenter.charAt(this.xCenter.length - 1) === "%") {
                this.currentXCenter = parseFloat(this.xCenter) / 100 * this.frame.canvas.clientWidth;
              } else {
                this.currentXCenter = parseFloat(this.xCenter);
              }
              if (this.yCenter.charAt(this.yCenter.length - 1) === "%") {
                this.currentYCenter = parseFloat(this.yCenter) / 100 * (this.frame.canvas.clientHeight - this.frame.filter.clientHeight);
              } else {
                this.currentYCenter = parseFloat(this.yCenter);
              }
            };
            Graph3d.prototype.getCameraPosition = function() {
              var pos = this.camera.getArmRotation();
              pos.distance = this.camera.getArmLength();
              return pos;
            };
            Graph3d.prototype._readData = function(data) {
              this.dataPoints = this.dataGroup.initializeData(this, data, this.style);
              this._initializeRanges();
              this._redrawFilter();
            };
            Graph3d.prototype.setData = function(data) {
              if (data === void 0 || data === null) return;
              this._readData(data);
              this.redraw();
              this.animationStart();
            };
            Graph3d.prototype.setOptions = function(options) {
              if (options === void 0) return;
              var errorFound = Validator.validate(options, allOptions);
              if (errorFound === true) {
                console.log("%cErrors have been found in the supplied options object.", printStyle);
              }
              this.animationStop();
              Settings.setOptions(options, this);
              this.setPointDrawingMethod();
              this._setSize(this.width, this.height);
              this.setData(this.dataGroup.getDataTable());
              this.animationStart();
            };
            Graph3d.prototype.setPointDrawingMethod = function() {
              var method = void 0;
              switch (this.style) {
                case Graph3d.STYLE.BAR:
                  method = Graph3d.prototype._redrawBarGraphPoint;
                  break;
                case Graph3d.STYLE.BARCOLOR:
                  method = Graph3d.prototype._redrawBarColorGraphPoint;
                  break;
                case Graph3d.STYLE.BARSIZE:
                  method = Graph3d.prototype._redrawBarSizeGraphPoint;
                  break;
                case Graph3d.STYLE.DOT:
                  method = Graph3d.prototype._redrawDotGraphPoint;
                  break;
                case Graph3d.STYLE.DOTLINE:
                  method = Graph3d.prototype._redrawDotLineGraphPoint;
                  break;
                case Graph3d.STYLE.DOTCOLOR:
                  method = Graph3d.prototype._redrawDotColorGraphPoint;
                  break;
                case Graph3d.STYLE.DOTSIZE:
                  method = Graph3d.prototype._redrawDotSizeGraphPoint;
                  break;
                case Graph3d.STYLE.SURFACE:
                  method = Graph3d.prototype._redrawSurfaceGraphPoint;
                  break;
                case Graph3d.STYLE.GRID:
                  method = Graph3d.prototype._redrawGridGraphPoint;
                  break;
                case Graph3d.STYLE.LINE:
                  method = Graph3d.prototype._redrawLineGraphPoint;
                  break;
                default:
                  throw new Error("Can not determine point drawing method for graph style '" + this.style + "'");
              }
              this._pointDrawingMethod = method;
            };
            Graph3d.prototype.redraw = function() {
              if (this.dataPoints === void 0) {
                throw new Error("Graph data not initialized");
              }
              this._resizeCanvas();
              this._resizeCenter();
              this._redrawSlider();
              this._redrawClear();
              this._redrawAxis();
              this._redrawDataGraph();
              this._redrawInfo();
              this._redrawLegend();
            };
            Graph3d.prototype._getContext = function() {
              var canvas = this.frame.canvas;
              var ctx = canvas.getContext("2d");
              ctx.lineJoin = "round";
              ctx.lineCap = "round";
              return ctx;
            };
            Graph3d.prototype._redrawClear = function() {
              var canvas = this.frame.canvas;
              var ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            };
            Graph3d.prototype._dotSize = function() {
              return this.frame.clientWidth * this.dotSizeRatio;
            };
            Graph3d.prototype._getLegendWidth = function() {
              var width;
              if (this.style === Graph3d.STYLE.DOTSIZE) {
                var dotSize = this._dotSize();
                width = dotSize * this.dotSizeMaxFraction;
              } else if (this.style === Graph3d.STYLE.BARSIZE) {
                width = this.xBarWidth;
              } else {
                width = 20;
              }
              return width;
            };
            Graph3d.prototype._redrawLegend = function() {
              if (this.showLegend !== true) {
                return;
              }
              if (this.style === Graph3d.STYLE.LINE || this.style === Graph3d.STYLE.BARSIZE) {
                return;
              }
              var isSizeLegend = this.style === Graph3d.STYLE.BARSIZE || this.style === Graph3d.STYLE.DOTSIZE;
              var isValueLegend = this.style === Graph3d.STYLE.DOTSIZE || this.style === Graph3d.STYLE.DOTCOLOR || this.style === Graph3d.STYLE.BARCOLOR;
              var height = Math.max(this.frame.clientHeight * 0.25, 100);
              var top = this.margin;
              var width = this._getLegendWidth();
              var right = this.frame.clientWidth - this.margin;
              var left = right - width;
              var bottom = top + height;
              var ctx = this._getContext();
              ctx.lineWidth = 1;
              ctx.font = "14px arial";
              if (isSizeLegend === false) {
                var ymin = 0;
                var ymax = height;
                var y;
                for (y = ymin; y < ymax; y++) {
                  var f = (y - ymin) / (ymax - ymin);
                  var hue = f * 240;
                  var color = this._hsv2rgb(hue, 1, 1);
                  ctx.strokeStyle = color;
                  ctx.beginPath();
                  ctx.moveTo(left, top + y);
                  ctx.lineTo(right, top + y);
                  ctx.stroke();
                }
                ctx.strokeStyle = this.axisColor;
                ctx.strokeRect(left, top, width, height);
              } else {
                var widthMin;
                if (this.style === Graph3d.STYLE.DOTSIZE) {
                  widthMin = width * (this.dotSizeMinFraction / this.dotSizeMaxFraction);
                } else if (this.style === Graph3d.STYLE.BARSIZE) {
                }
                ctx.strokeStyle = this.axisColor;
                ctx.fillStyle = this.dataColor.fill;
                ctx.beginPath();
                ctx.moveTo(left, top);
                ctx.lineTo(right, top);
                ctx.lineTo(left + widthMin, bottom);
                ctx.lineTo(left, bottom);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
              }
              var gridLineLen = 5;
              var legendMin = isValueLegend ? this.valueRange.min : this.zRange.min;
              var legendMax = isValueLegend ? this.valueRange.max : this.zRange.max;
              var step = new StepNumber(legendMin, legendMax, (legendMax - legendMin) / 5, true);
              step.start(true);
              var from;
              var to;
              while (!step.end()) {
                y = bottom - (step.getCurrent() - legendMin) / (legendMax - legendMin) * height;
                from = new Point2d(left - gridLineLen, y);
                to = new Point2d(left, y);
                this._line(ctx, from, to);
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.fillStyle = this.axisColor;
                ctx.fillText(step.getCurrent(), left - 2 * gridLineLen, y);
                step.next();
              }
              ctx.textAlign = "right";
              ctx.textBaseline = "top";
              var label = this.legendLabel;
              ctx.fillText(label, right, bottom + this.margin);
            };
            Graph3d.prototype._redrawFilter = function() {
              var dataFilter = this.dataGroup.dataFilter;
              var filter = this.frame.filter;
              filter.innerHTML = "";
              if (!dataFilter) {
                filter.slider = void 0;
                return;
              }
              var options = {
                "visible": this.showAnimationControls
              };
              var slider = new Slider(filter, options);
              filter.slider = slider;
              filter.style.padding = "10px";
              slider.setValues(dataFilter.values);
              slider.setPlayInterval(this.animationInterval);
              var me = this;
              var onchange = function onchange2() {
                var dataFilter2 = me.dataGroup.dataFilter;
                var index = slider.getIndex();
                dataFilter2.selectValue(index);
                me.dataPoints = dataFilter2._getDataPoints();
                me.redraw();
              };
              slider.setOnChangeCallback(onchange);
            };
            Graph3d.prototype._redrawSlider = function() {
              if (this.frame.filter.slider !== void 0) {
                this.frame.filter.slider.redraw();
              }
            };
            Graph3d.prototype._redrawInfo = function() {
              var info = this.dataGroup.getInfo();
              if (info === void 0) return;
              var ctx = this._getContext();
              ctx.font = "14px arial";
              ctx.lineStyle = "gray";
              ctx.fillStyle = "gray";
              ctx.textAlign = "left";
              ctx.textBaseline = "top";
              var x = this.margin;
              var y = this.margin;
              ctx.fillText(info, x, y);
            };
            Graph3d.prototype._line = function(ctx, from, to, strokeStyle) {
              if (strokeStyle !== void 0) {
                ctx.strokeStyle = strokeStyle;
              }
              ctx.beginPath();
              ctx.moveTo(from.x, from.y);
              ctx.lineTo(to.x, to.y);
              ctx.stroke();
            };
            Graph3d.prototype.drawAxisLabelX = function(ctx, point3d, text, armAngle, yMargin) {
              if (yMargin === void 0) {
                yMargin = 0;
              }
              var point2d = this._convert3Dto2D(point3d);
              if (Math.cos(armAngle * 2) > 0) {
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                point2d.y += yMargin;
              } else if (Math.sin(armAngle * 2) < 0) {
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
              } else {
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
              }
              ctx.fillStyle = this.axisColor;
              ctx.fillText(text, point2d.x, point2d.y);
            };
            Graph3d.prototype.drawAxisLabelY = function(ctx, point3d, text, armAngle, yMargin) {
              if (yMargin === void 0) {
                yMargin = 0;
              }
              var point2d = this._convert3Dto2D(point3d);
              if (Math.cos(armAngle * 2) < 0) {
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                point2d.y += yMargin;
              } else if (Math.sin(armAngle * 2) > 0) {
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
              } else {
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
              }
              ctx.fillStyle = this.axisColor;
              ctx.fillText(text, point2d.x, point2d.y);
            };
            Graph3d.prototype.drawAxisLabelZ = function(ctx, point3d, text, offset) {
              if (offset === void 0) {
                offset = 0;
              }
              var point2d = this._convert3Dto2D(point3d);
              ctx.textAlign = "right";
              ctx.textBaseline = "middle";
              ctx.fillStyle = this.axisColor;
              ctx.fillText(text, point2d.x - offset, point2d.y);
            };
            Graph3d.prototype._line3d = function(ctx, from, to, strokeStyle) {
              var from2d = this._convert3Dto2D(from);
              var to2d = this._convert3Dto2D(to);
              this._line(ctx, from2d, to2d, strokeStyle);
            };
            Graph3d.prototype._redrawAxis = function() {
              var ctx = this._getContext(), from, to, step, prettyStep, text, xText, yText, zText, offset, xOffset, yOffset;
              ctx.font = 24 / this.camera.getArmLength() + "px arial";
              var gridLenX = 0.025 / this.scale.x;
              var gridLenY = 0.025 / this.scale.y;
              var textMargin = 5 / this.camera.getArmLength();
              var armAngle = this.camera.getArmRotation().horizontal;
              var armVector = new Point2d(Math.cos(armAngle), Math.sin(armAngle));
              var xRange = this.xRange;
              var yRange = this.yRange;
              var zRange = this.zRange;
              var point3d;
              ctx.lineWidth = 1;
              prettyStep = this.defaultXStep === void 0;
              step = new StepNumber(xRange.min, xRange.max, this.xStep, prettyStep);
              step.start(true);
              while (!step.end()) {
                var x = step.getCurrent();
                if (this.showGrid) {
                  from = new Point3d(x, yRange.min, zRange.min);
                  to = new Point3d(x, yRange.max, zRange.min);
                  this._line3d(ctx, from, to, this.gridColor);
                } else if (this.showXAxis) {
                  from = new Point3d(x, yRange.min, zRange.min);
                  to = new Point3d(x, yRange.min + gridLenX, zRange.min);
                  this._line3d(ctx, from, to, this.axisColor);
                  from = new Point3d(x, yRange.max, zRange.min);
                  to = new Point3d(x, yRange.max - gridLenX, zRange.min);
                  this._line3d(ctx, from, to, this.axisColor);
                }
                if (this.showXAxis) {
                  yText = armVector.x > 0 ? yRange.min : yRange.max;
                  point3d = new Point3d(x, yText, zRange.min);
                  var msg = "  " + this.xValueLabel(x) + "  ";
                  this.drawAxisLabelX(ctx, point3d, msg, armAngle, textMargin);
                }
                step.next();
              }
              ctx.lineWidth = 1;
              prettyStep = this.defaultYStep === void 0;
              step = new StepNumber(yRange.min, yRange.max, this.yStep, prettyStep);
              step.start(true);
              while (!step.end()) {
                var y = step.getCurrent();
                if (this.showGrid) {
                  from = new Point3d(xRange.min, y, zRange.min);
                  to = new Point3d(xRange.max, y, zRange.min);
                  this._line3d(ctx, from, to, this.gridColor);
                } else if (this.showYAxis) {
                  from = new Point3d(xRange.min, y, zRange.min);
                  to = new Point3d(xRange.min + gridLenY, y, zRange.min);
                  this._line3d(ctx, from, to, this.axisColor);
                  from = new Point3d(xRange.max, y, zRange.min);
                  to = new Point3d(xRange.max - gridLenY, y, zRange.min);
                  this._line3d(ctx, from, to, this.axisColor);
                }
                if (this.showYAxis) {
                  xText = armVector.y > 0 ? xRange.min : xRange.max;
                  point3d = new Point3d(xText, y, zRange.min);
                  var _msg = "  " + this.yValueLabel(y) + "  ";
                  this.drawAxisLabelY(ctx, point3d, _msg, armAngle, textMargin);
                }
                step.next();
              }
              if (this.showZAxis) {
                ctx.lineWidth = 1;
                prettyStep = this.defaultZStep === void 0;
                step = new StepNumber(zRange.min, zRange.max, this.zStep, prettyStep);
                step.start(true);
                xText = armVector.x > 0 ? xRange.min : xRange.max;
                yText = armVector.y < 0 ? yRange.min : yRange.max;
                while (!step.end()) {
                  var z = step.getCurrent();
                  var from3d = new Point3d(xText, yText, z);
                  var from2d = this._convert3Dto2D(from3d);
                  to = new Point2d(from2d.x - textMargin, from2d.y);
                  this._line(ctx, from2d, to, this.axisColor);
                  var _msg2 = this.zValueLabel(z) + " ";
                  this.drawAxisLabelZ(ctx, from3d, _msg2, 5);
                  step.next();
                }
                ctx.lineWidth = 1;
                from = new Point3d(xText, yText, zRange.min);
                to = new Point3d(xText, yText, zRange.max);
                this._line3d(ctx, from, to, this.axisColor);
              }
              if (this.showXAxis) {
                var xMin2d;
                var xMax2d;
                ctx.lineWidth = 1;
                xMin2d = new Point3d(xRange.min, yRange.min, zRange.min);
                xMax2d = new Point3d(xRange.max, yRange.min, zRange.min);
                this._line3d(ctx, xMin2d, xMax2d, this.axisColor);
                xMin2d = new Point3d(xRange.min, yRange.max, zRange.min);
                xMax2d = new Point3d(xRange.max, yRange.max, zRange.min);
                this._line3d(ctx, xMin2d, xMax2d, this.axisColor);
              }
              if (this.showYAxis) {
                ctx.lineWidth = 1;
                from = new Point3d(xRange.min, yRange.min, zRange.min);
                to = new Point3d(xRange.min, yRange.max, zRange.min);
                this._line3d(ctx, from, to, this.axisColor);
                from = new Point3d(xRange.max, yRange.min, zRange.min);
                to = new Point3d(xRange.max, yRange.max, zRange.min);
                this._line3d(ctx, from, to, this.axisColor);
              }
              var xLabel = this.xLabel;
              if (xLabel.length > 0 && this.showXAxis) {
                yOffset = 0.1 / this.scale.y;
                xText = (xRange.max + 3 * xRange.min) / 4;
                yText = armVector.x > 0 ? yRange.min - yOffset : yRange.max + yOffset;
                text = new Point3d(xText, yText, zRange.min);
                this.drawAxisLabelX(ctx, text, xLabel, armAngle);
              }
              var yLabel = this.yLabel;
              if (yLabel.length > 0 && this.showYAxis) {
                xOffset = 0.1 / this.scale.x;
                xText = armVector.y > 0 ? xRange.min - xOffset : xRange.max + xOffset;
                yText = (yRange.max + 3 * yRange.min) / 4;
                text = new Point3d(xText, yText, zRange.min);
                this.drawAxisLabelY(ctx, text, yLabel, armAngle);
              }
              var zLabel = this.zLabel;
              if (zLabel.length > 0 && this.showZAxis) {
                offset = 30;
                xText = armVector.x > 0 ? xRange.min : xRange.max;
                yText = armVector.y < 0 ? yRange.min : yRange.max;
                zText = (zRange.max + 3 * zRange.min) / 4;
                text = new Point3d(xText, yText, zText);
                this.drawAxisLabelZ(ctx, text, zLabel, offset);
              }
            };
            Graph3d.prototype._hsv2rgb = function(H, S, V) {
              var R, G, B, C, Hi, X;
              C = V * S;
              Hi = Math.floor(H / 60);
              X = C * (1 - Math.abs(H / 60 % 2 - 1));
              switch (Hi) {
                case 0:
                  R = C;
                  G = X;
                  B = 0;
                  break;
                case 1:
                  R = X;
                  G = C;
                  B = 0;
                  break;
                case 2:
                  R = 0;
                  G = C;
                  B = X;
                  break;
                case 3:
                  R = 0;
                  G = X;
                  B = C;
                  break;
                case 4:
                  R = X;
                  G = 0;
                  B = C;
                  break;
                case 5:
                  R = C;
                  G = 0;
                  B = X;
                  break;
                default:
                  R = 0;
                  G = 0;
                  B = 0;
                  break;
              }
              return "RGB(" + parseInt(R * 255) + "," + parseInt(G * 255) + "," + parseInt(B * 255) + ")";
            };
            Graph3d.prototype._getStrokeWidth = function(point) {
              if (point !== void 0) {
                if (this.showPerspective) {
                  return 1 / -point.trans.z * this.dataColor.strokeWidth;
                } else {
                  return -(this.eye.z / this.camera.getArmLength()) * this.dataColor.strokeWidth;
                }
              }
              return this.dataColor.strokeWidth;
            };
            Graph3d.prototype._redrawBar = function(ctx, point, xWidth, yWidth, color, borderColor) {
              var surface;
              var me = this;
              var point3d = point.point;
              var zMin = this.zRange.min;
              var top = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, point3d.z) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, point3d.z) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, point3d.z) }];
              var bottom = [{ point: new Point3d(point3d.x - xWidth, point3d.y - yWidth, zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y - yWidth, zMin) }, { point: new Point3d(point3d.x + xWidth, point3d.y + yWidth, zMin) }, { point: new Point3d(point3d.x - xWidth, point3d.y + yWidth, zMin) }];
              top.forEach(function(obj) {
                obj.screen = me._convert3Dto2D(obj.point);
              });
              bottom.forEach(function(obj) {
                obj.screen = me._convert3Dto2D(obj.point);
              });
              var surfaces = [{ corners: top, center: Point3d.avg(bottom[0].point, bottom[2].point) }, { corners: [top[0], top[1], bottom[1], bottom[0]], center: Point3d.avg(bottom[1].point, bottom[0].point) }, { corners: [top[1], top[2], bottom[2], bottom[1]], center: Point3d.avg(bottom[2].point, bottom[1].point) }, { corners: [top[2], top[3], bottom[3], bottom[2]], center: Point3d.avg(bottom[3].point, bottom[2].point) }, { corners: [top[3], top[0], bottom[0], bottom[3]], center: Point3d.avg(bottom[0].point, bottom[3].point) }];
              point.surfaces = surfaces;
              for (var j = 0; j < surfaces.length; j++) {
                surface = surfaces[j];
                var transCenter = this._convertPointToTranslation(surface.center);
                surface.dist = this.showPerspective ? transCenter.length() : -transCenter.z;
              }
              surfaces.sort(function(a, b) {
                var diff = b.dist - a.dist;
                if (diff) return diff;
                if (a.corners === top) return 1;
                if (b.corners === top) return -1;
                return 0;
              });
              ctx.lineWidth = this._getStrokeWidth(point);
              ctx.strokeStyle = borderColor;
              ctx.fillStyle = color;
              for (var _j = 2; _j < surfaces.length; _j++) {
                surface = surfaces[_j];
                this._polygon(ctx, surface.corners);
              }
            };
            Graph3d.prototype._polygon = function(ctx, points, fillStyle, strokeStyle) {
              if (points.length < 2) {
                return;
              }
              if (fillStyle !== void 0) {
                ctx.fillStyle = fillStyle;
              }
              if (strokeStyle !== void 0) {
                ctx.strokeStyle = strokeStyle;
              }
              ctx.beginPath();
              ctx.moveTo(points[0].screen.x, points[0].screen.y);
              for (var i = 1; i < points.length; ++i) {
                var point = points[i];
                ctx.lineTo(point.screen.x, point.screen.y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            };
            Graph3d.prototype._drawCircle = function(ctx, point, color, borderColor, size) {
              var radius = this._calcRadius(point, size);
              ctx.lineWidth = this._getStrokeWidth(point);
              ctx.strokeStyle = borderColor;
              ctx.fillStyle = color;
              ctx.beginPath();
              ctx.arc(point.screen.x, point.screen.y, radius, 0, Math.PI * 2, true);
              ctx.fill();
              ctx.stroke();
            };
            Graph3d.prototype._getColorsRegular = function(point) {
              var hue = (1 - (point.point.z - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;
              var color = this._hsv2rgb(hue, 1, 1);
              var borderColor = this._hsv2rgb(hue, 1, 0.8);
              return {
                fill: color,
                border: borderColor
              };
            };
            Graph3d.prototype._getColorsColor = function(point) {
              var color, borderColor;
              if (typeof point.point.value === "string") {
                color = point.point.value;
                borderColor = point.point.value;
              } else {
                var hue = (1 - (point.point.value - this.valueRange.min) * this.scale.value) * 240;
                color = this._hsv2rgb(hue, 1, 1);
                borderColor = this._hsv2rgb(hue, 1, 0.8);
              }
              return {
                fill: color,
                border: borderColor
              };
            };
            Graph3d.prototype._getColorsSize = function() {
              return {
                fill: this.dataColor.fill,
                border: this.dataColor.stroke
              };
            };
            Graph3d.prototype._calcRadius = function(point, size) {
              if (size === void 0) {
                size = this._dotSize();
              }
              var radius;
              if (this.showPerspective) {
                radius = size / -point.trans.z;
              } else {
                radius = size * -(this.eye.z / this.camera.getArmLength());
              }
              if (radius < 0) {
                radius = 0;
              }
              return radius;
            };
            Graph3d.prototype._redrawBarGraphPoint = function(ctx, point) {
              var xWidth = this.xBarWidth / 2;
              var yWidth = this.yBarWidth / 2;
              var colors = this._getColorsRegular(point);
              this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
            };
            Graph3d.prototype._redrawBarColorGraphPoint = function(ctx, point) {
              var xWidth = this.xBarWidth / 2;
              var yWidth = this.yBarWidth / 2;
              var colors = this._getColorsColor(point);
              this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
            };
            Graph3d.prototype._redrawBarSizeGraphPoint = function(ctx, point) {
              var fraction = (point.point.value - this.valueRange.min) / this.valueRange.range();
              var xWidth = this.xBarWidth / 2 * (fraction * 0.8 + 0.2);
              var yWidth = this.yBarWidth / 2 * (fraction * 0.8 + 0.2);
              var colors = this._getColorsSize();
              this._redrawBar(ctx, point, xWidth, yWidth, colors.fill, colors.border);
            };
            Graph3d.prototype._redrawDotGraphPoint = function(ctx, point) {
              var colors = this._getColorsRegular(point);
              this._drawCircle(ctx, point, colors.fill, colors.border);
            };
            Graph3d.prototype._redrawDotLineGraphPoint = function(ctx, point) {
              var from = this._convert3Dto2D(point.bottom);
              ctx.lineWidth = 1;
              this._line(ctx, from, point.screen, this.gridColor);
              this._redrawDotGraphPoint(ctx, point);
            };
            Graph3d.prototype._redrawDotColorGraphPoint = function(ctx, point) {
              var colors = this._getColorsColor(point);
              this._drawCircle(ctx, point, colors.fill, colors.border);
            };
            Graph3d.prototype._redrawDotSizeGraphPoint = function(ctx, point) {
              var dotSize = this._dotSize();
              var fraction = (point.point.value - this.valueRange.min) / this.valueRange.range();
              var sizeMin = dotSize * this.dotSizeMinFraction;
              var sizeRange = dotSize * this.dotSizeMaxFraction - sizeMin;
              var size = sizeMin + sizeRange * fraction;
              var colors = this._getColorsSize();
              this._drawCircle(ctx, point, colors.fill, colors.border, size);
            };
            Graph3d.prototype._redrawSurfaceGraphPoint = function(ctx, point) {
              var right = point.pointRight;
              var top = point.pointTop;
              var cross = point.pointCross;
              if (point === void 0 || right === void 0 || top === void 0 || cross === void 0) {
                return;
              }
              var topSideVisible = true;
              var fillStyle;
              var strokeStyle;
              if (this.showGrayBottom || this.showShadow) {
                var aDiff = Point3d.subtract(cross.trans, point.trans);
                var bDiff = Point3d.subtract(top.trans, right.trans);
                var crossproduct = Point3d.crossProduct(aDiff, bDiff);
                var len = crossproduct.length();
                topSideVisible = crossproduct.z > 0;
              }
              if (topSideVisible) {
                var zAvg = (point.point.z + right.point.z + top.point.z + cross.point.z) / 4;
                var h = (1 - (zAvg - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;
                var s = 1;
                var v;
                if (this.showShadow) {
                  v = Math.min(1 + crossproduct.x / len / 2, 1);
                  fillStyle = this._hsv2rgb(h, s, v);
                  strokeStyle = fillStyle;
                } else {
                  v = 1;
                  fillStyle = this._hsv2rgb(h, s, v);
                  strokeStyle = this.axisColor;
                }
              } else {
                fillStyle = "gray";
                strokeStyle = this.axisColor;
              }
              ctx.lineWidth = this._getStrokeWidth(point);
              var points = [point, right, cross, top];
              this._polygon(ctx, points, fillStyle, strokeStyle);
            };
            Graph3d.prototype._drawGridLine = function(ctx, from, to) {
              if (from === void 0 || to === void 0) {
                return;
              }
              var zAvg = (from.point.z + to.point.z) / 2;
              var h = (1 - (zAvg - this.zRange.min) * this.scale.z / this.verticalRatio) * 240;
              ctx.lineWidth = this._getStrokeWidth(from) * 2;
              ctx.strokeStyle = this._hsv2rgb(h, 1, 1);
              this._line(ctx, from.screen, to.screen);
            };
            Graph3d.prototype._redrawGridGraphPoint = function(ctx, point) {
              this._drawGridLine(ctx, point, point.pointRight);
              this._drawGridLine(ctx, point, point.pointTop);
            };
            Graph3d.prototype._redrawLineGraphPoint = function(ctx, point) {
              if (point.pointNext === void 0) {
                return;
              }
              ctx.lineWidth = this._getStrokeWidth(point);
              ctx.strokeStyle = this.dataColor.stroke;
              this._line(ctx, point.screen, point.pointNext.screen);
            };
            Graph3d.prototype._redrawDataGraph = function() {
              var ctx = this._getContext();
              var i;
              if (this.dataPoints === void 0 || this.dataPoints.length <= 0) return;
              this._calcTranslations(this.dataPoints);
              for (i = 0; i < this.dataPoints.length; i++) {
                var point = this.dataPoints[i];
                this._pointDrawingMethod.call(this, ctx, point);
              }
            };
            Graph3d.prototype._storeMousePosition = function(event) {
              this.startMouseX = getMouseX(event);
              this.startMouseY = getMouseY(event);
              this._startCameraOffset = this.camera.getOffset();
            };
            Graph3d.prototype._onMouseDown = function(event) {
              event = event || window.event;
              if (this.leftButtonDown) {
                this._onMouseUp(event);
              }
              this.leftButtonDown = event.which ? event.which === 1 : event.button === 1;
              if (!this.leftButtonDown && !this.touchDown) return;
              this._storeMousePosition(event);
              this.startStart = new Date(this.start);
              this.startEnd = new Date(this.end);
              this.startArmRotation = this.camera.getArmRotation();
              this.frame.style.cursor = "move";
              var me = this;
              this.onmousemove = function(event2) {
                me._onMouseMove(event2);
              };
              this.onmouseup = function(event2) {
                me._onMouseUp(event2);
              };
              util.addEventListener(document, "mousemove", me.onmousemove);
              util.addEventListener(document, "mouseup", me.onmouseup);
              util.preventDefault(event);
            };
            Graph3d.prototype._onMouseMove = function(event) {
              this.moving = true;
              event = event || window.event;
              var diffX = parseFloat(getMouseX(event)) - this.startMouseX;
              var diffY = parseFloat(getMouseY(event)) - this.startMouseY;
              if (event && event.ctrlKey === true) {
                var scaleX = this.frame.clientWidth * 0.5;
                var scaleY = this.frame.clientHeight * 0.5;
                var offXNew = (this._startCameraOffset.x || 0) - diffX / scaleX * this.camera.armLength * 0.8;
                var offYNew = (this._startCameraOffset.y || 0) + diffY / scaleY * this.camera.armLength * 0.8;
                this.camera.setOffset(offXNew, offYNew);
                this._storeMousePosition(event);
              } else {
                var horizontalNew = this.startArmRotation.horizontal + diffX / 200;
                var verticalNew = this.startArmRotation.vertical + diffY / 200;
                var snapAngle = 4;
                var snapValue = Math.sin(snapAngle / 360 * 2 * Math.PI);
                if (Math.abs(Math.sin(horizontalNew)) < snapValue) {
                  horizontalNew = Math.round(horizontalNew / Math.PI) * Math.PI - 1e-3;
                }
                if (Math.abs(Math.cos(horizontalNew)) < snapValue) {
                  horizontalNew = (Math.round(horizontalNew / Math.PI - 0.5) + 0.5) * Math.PI - 1e-3;
                }
                if (Math.abs(Math.sin(verticalNew)) < snapValue) {
                  verticalNew = Math.round(verticalNew / Math.PI) * Math.PI;
                }
                if (Math.abs(Math.cos(verticalNew)) < snapValue) {
                  verticalNew = (Math.round(verticalNew / Math.PI - 0.5) + 0.5) * Math.PI;
                }
                this.camera.setArmRotation(horizontalNew, verticalNew);
              }
              this.redraw();
              var parameters = this.getCameraPosition();
              this.emit("cameraPositionChange", parameters);
              util.preventDefault(event);
            };
            Graph3d.prototype._onMouseUp = function(event) {
              this.frame.style.cursor = "auto";
              this.leftButtonDown = false;
              util.removeEventListener(document, "mousemove", this.onmousemove);
              util.removeEventListener(document, "mouseup", this.onmouseup);
              util.preventDefault(event);
            };
            Graph3d.prototype._onClick = function(event) {
              if (!this.onclick_callback) return;
              if (!this.moving) {
                var boundingRect = this.frame.getBoundingClientRect();
                var mouseX = getMouseX(event) - boundingRect.left;
                var mouseY = getMouseY(event) - boundingRect.top;
                var dataPoint = this._dataPointFromXY(mouseX, mouseY);
                if (dataPoint) this.onclick_callback(dataPoint.point.data);
              } else {
                this.moving = false;
              }
              util.preventDefault(event);
            };
            Graph3d.prototype._onTooltip = function(event) {
              var delay = 300;
              var boundingRect = this.frame.getBoundingClientRect();
              var mouseX = getMouseX(event) - boundingRect.left;
              var mouseY = getMouseY(event) - boundingRect.top;
              if (!this.showTooltip) {
                return;
              }
              if (this.tooltipTimeout) {
                clearTimeout(this.tooltipTimeout);
              }
              if (this.leftButtonDown) {
                this._hideTooltip();
                return;
              }
              if (this.tooltip && this.tooltip.dataPoint) {
                var dataPoint = this._dataPointFromXY(mouseX, mouseY);
                if (dataPoint !== this.tooltip.dataPoint) {
                  if (dataPoint) {
                    this._showTooltip(dataPoint);
                  } else {
                    this._hideTooltip();
                  }
                }
              } else {
                var me = this;
                this.tooltipTimeout = setTimeout(function() {
                  me.tooltipTimeout = null;
                  var dataPoint2 = me._dataPointFromXY(mouseX, mouseY);
                  if (dataPoint2) {
                    me._showTooltip(dataPoint2);
                  }
                }, delay);
              }
            };
            Graph3d.prototype._onTouchStart = function(event) {
              this.touchDown = true;
              var me = this;
              this.ontouchmove = function(event2) {
                me._onTouchMove(event2);
              };
              this.ontouchend = function(event2) {
                me._onTouchEnd(event2);
              };
              util.addEventListener(document, "touchmove", me.ontouchmove);
              util.addEventListener(document, "touchend", me.ontouchend);
              this._onMouseDown(event);
            };
            Graph3d.prototype._onTouchMove = function(event) {
              this._onMouseMove(event);
            };
            Graph3d.prototype._onTouchEnd = function(event) {
              this.touchDown = false;
              util.removeEventListener(document, "touchmove", this.ontouchmove);
              util.removeEventListener(document, "touchend", this.ontouchend);
              this._onMouseUp(event);
            };
            Graph3d.prototype._onWheel = function(event) {
              if (!event)
                event = window.event;
              var delta = 0;
              if (event.wheelDelta) {
                delta = event.wheelDelta / 120;
              } else if (event.detail) {
                delta = -event.detail / 3;
              }
              if (delta) {
                var oldLength = this.camera.getArmLength();
                var newLength = oldLength * (1 - delta / 10);
                this.camera.setArmLength(newLength);
                this.redraw();
                this._hideTooltip();
              }
              var parameters = this.getCameraPosition();
              this.emit("cameraPositionChange", parameters);
              util.preventDefault(event);
            };
            Graph3d.prototype._insideTriangle = function(point, triangle) {
              var a = triangle[0], b = triangle[1], c = triangle[2];
              function sign(x) {
                return x > 0 ? 1 : x < 0 ? -1 : 0;
              }
              var as = sign((b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x));
              var bs = sign((c.x - b.x) * (point.y - b.y) - (c.y - b.y) * (point.x - b.x));
              var cs = sign((a.x - c.x) * (point.y - c.y) - (a.y - c.y) * (point.x - c.x));
              return (as == 0 || bs == 0 || as == bs) && (bs == 0 || cs == 0 || bs == cs) && (as == 0 || cs == 0 || as == cs);
            };
            Graph3d.prototype._dataPointFromXY = function(x, y) {
              var i, distMax = 100, dataPoint = null, closestDataPoint = null, closestDist = null, center = new Point2d(x, y);
              if (this.style === Graph3d.STYLE.BAR || this.style === Graph3d.STYLE.BARCOLOR || this.style === Graph3d.STYLE.BARSIZE) {
                for (i = this.dataPoints.length - 1; i >= 0; i--) {
                  dataPoint = this.dataPoints[i];
                  var surfaces = dataPoint.surfaces;
                  if (surfaces) {
                    for (var s = surfaces.length - 1; s >= 0; s--) {
                      var surface = surfaces[s];
                      var corners = surface.corners;
                      var triangle1 = [corners[0].screen, corners[1].screen, corners[2].screen];
                      var triangle2 = [corners[2].screen, corners[3].screen, corners[0].screen];
                      if (this._insideTriangle(center, triangle1) || this._insideTriangle(center, triangle2)) {
                        return dataPoint;
                      }
                    }
                  }
                }
              } else {
                for (i = 0; i < this.dataPoints.length; i++) {
                  dataPoint = this.dataPoints[i];
                  var point = dataPoint.screen;
                  if (point) {
                    var distX = Math.abs(x - point.x);
                    var distY = Math.abs(y - point.y);
                    var dist = Math.sqrt(distX * distX + distY * distY);
                    if ((closestDist === null || dist < closestDist) && dist < distMax) {
                      closestDist = dist;
                      closestDataPoint = dataPoint;
                    }
                  }
                }
              }
              return closestDataPoint;
            };
            Graph3d.prototype.hasBars = function(style) {
              return style == Graph3d.STYLE.BAR || style == Graph3d.STYLE.BARCOLOR || style == Graph3d.STYLE.BARSIZE;
            };
            Graph3d.prototype._showTooltip = function(dataPoint) {
              var content, line, dot;
              if (!this.tooltip) {
                content = document.createElement("div");
                (0, _assign2["default"])(content.style, {}, this.tooltipStyle.content);
                content.style.position = "absolute";
                line = document.createElement("div");
                (0, _assign2["default"])(line.style, {}, this.tooltipStyle.line);
                line.style.position = "absolute";
                dot = document.createElement("div");
                (0, _assign2["default"])(dot.style, {}, this.tooltipStyle.dot);
                dot.style.position = "absolute";
                this.tooltip = {
                  dataPoint: null,
                  dom: {
                    content,
                    line,
                    dot
                  }
                };
              } else {
                content = this.tooltip.dom.content;
                line = this.tooltip.dom.line;
                dot = this.tooltip.dom.dot;
              }
              this._hideTooltip();
              this.tooltip.dataPoint = dataPoint;
              if (typeof this.showTooltip === "function") {
                content.innerHTML = this.showTooltip(dataPoint.point);
              } else {
                content.innerHTML = "<table><tr><td>" + this.xLabel + ":</td><td>" + dataPoint.point.x + "</td></tr><tr><td>" + this.yLabel + ":</td><td>" + dataPoint.point.y + "</td></tr><tr><td>" + this.zLabel + ":</td><td>" + dataPoint.point.z + "</td></tr></table>";
              }
              content.style.left = "0";
              content.style.top = "0";
              this.frame.appendChild(content);
              this.frame.appendChild(line);
              this.frame.appendChild(dot);
              var contentWidth = content.offsetWidth;
              var contentHeight = content.offsetHeight;
              var lineHeight = line.offsetHeight;
              var dotWidth = dot.offsetWidth;
              var dotHeight = dot.offsetHeight;
              var left = dataPoint.screen.x - contentWidth / 2;
              left = Math.min(Math.max(left, 10), this.frame.clientWidth - 10 - contentWidth);
              line.style.left = dataPoint.screen.x + "px";
              line.style.top = dataPoint.screen.y - lineHeight + "px";
              content.style.left = left + "px";
              content.style.top = dataPoint.screen.y - lineHeight - contentHeight + "px";
              dot.style.left = dataPoint.screen.x - dotWidth / 2 + "px";
              dot.style.top = dataPoint.screen.y - dotHeight / 2 + "px";
            };
            Graph3d.prototype._hideTooltip = function() {
              if (this.tooltip) {
                this.tooltip.dataPoint = null;
                for (var prop in this.tooltip.dom) {
                  if (this.tooltip.dom.hasOwnProperty(prop)) {
                    var elem = this.tooltip.dom[prop];
                    if (elem && elem.parentNode) {
                      elem.parentNode.removeChild(elem);
                    }
                  }
                }
              }
            };
            function getMouseX(event) {
              if ("clientX" in event) return event.clientX;
              return event.targetTouches[0] && event.targetTouches[0].clientX || 0;
            }
            function getMouseY(event) {
              if ("clientY" in event) return event.clientY;
              return event.targetTouches[0] && event.targetTouches[0].clientY || 0;
            }
            Graph3d.prototype.setCameraPosition = function(pos) {
              Settings.setCameraPosition(pos, this);
              this.redraw();
            };
            Graph3d.prototype.setSize = function(width, height) {
              this._setSize(width, height);
              this.redraw();
            };
            module2.exports = Graph3d;
          },
          /* 162 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(163);
            module2.exports = __webpack_require__(7).Object.assign;
          },
          /* 163 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            $export($export.S + $export.F, "Object", { assign: __webpack_require__(164) });
          },
          /* 164 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var getKeys = __webpack_require__(33);
            var gOPS = __webpack_require__(63);
            var pIE = __webpack_require__(42);
            var toObject = __webpack_require__(41);
            var IObject = __webpack_require__(78);
            var $assign = Object.assign;
            module2.exports = !$assign || __webpack_require__(28)(function() {
              var A = {};
              var B = {};
              var S = Symbol();
              var K = "abcdefghijklmnopqrst";
              A[S] = 7;
              K.split("").forEach(function(k) {
                B[k] = k;
              });
              return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
            }) ? function assign(target, source) {
              var T = toObject(target);
              var aLen = arguments.length;
              var index = 1;
              var getSymbols = gOPS.f;
              var isEnum = pIE.f;
              while (aLen > index) {
                var S = IObject(arguments[index++]);
                var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
                var length = keys.length;
                var j = 0;
                var key;
                while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
              }
              return T;
            } : $assign;
          },
          /* 165 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(166), __esModule: true };
          },
          /* 166 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(167);
            module2.exports = __webpack_require__(7).Math.sign;
          },
          /* 167 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            $export($export.S, "Math", { sign: __webpack_require__(168) });
          },
          /* 168 */
          /***/
          function(module2, exports2) {
            module2.exports = Math.sign || function sign(x) {
              return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
            };
          },
          /* 169 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(170), __esModule: true };
          },
          /* 170 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(171);
            var $Object = __webpack_require__(7).Object;
            module2.exports = function defineProperty(it, key, desc) {
              return $Object.defineProperty(it, key, desc);
            };
          },
          /* 171 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            $export($export.S + $export.F * !__webpack_require__(21), "Object", { defineProperty: __webpack_require__(20).f });
          },
          /* 172 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var string = "string";
            var bool = "boolean";
            var number = "number";
            var object = "object";
            var colorOptions = {
              fill: { string },
              stroke: { string },
              strokeWidth: { number },
              __type__: { string, object, "undefined": "undefined" }
            };
            var allOptions = {
              animationAutoStart: { boolean: bool, "undefined": "undefined" },
              animationInterval: { number },
              animationPreload: { boolean: bool },
              axisColor: { string },
              backgroundColor: colorOptions,
              xBarWidth: { number, "undefined": "undefined" },
              yBarWidth: { number, "undefined": "undefined" },
              cameraPosition: {
                distance: { number },
                horizontal: { number },
                vertical: { number },
                __type__: { object }
              },
              xCenter: { string },
              yCenter: { string },
              dataColor: colorOptions,
              dotSizeMinFraction: { number },
              dotSizeMaxFraction: { number },
              dotSizeRatio: { number },
              filterLabel: { string },
              gridColor: { string },
              onclick: { "function": "function" },
              keepAspectRatio: { boolean: bool },
              xLabel: { string },
              yLabel: { string },
              zLabel: { string },
              legendLabel: { string },
              xMin: { number, "undefined": "undefined" },
              yMin: { number, "undefined": "undefined" },
              zMin: { number, "undefined": "undefined" },
              xMax: { number, "undefined": "undefined" },
              yMax: { number, "undefined": "undefined" },
              zMax: { number, "undefined": "undefined" },
              showAnimationControls: { boolean: bool, "undefined": "undefined" },
              showGrid: { boolean: bool },
              showLegend: { boolean: bool, "undefined": "undefined" },
              showPerspective: { boolean: bool },
              showShadow: { boolean: bool },
              showXAxis: { boolean: bool },
              showYAxis: { boolean: bool },
              showZAxis: { boolean: bool },
              xStep: { number, "undefined": "undefined" },
              yStep: { number, "undefined": "undefined" },
              zStep: { number, "undefined": "undefined" },
              style: {
                number,
                // TODO: either Graph3d.DEFAULT has string, or number allowed in documentation
                string: ["bar", "bar-color", "bar-size", "dot", "dot-line", "dot-color", "dot-size", "line", "grid", "surface"]
              },
              tooltip: { boolean: bool, "function": "function" },
              tooltipStyle: {
                content: {
                  color: { string },
                  background: { string },
                  border: { string },
                  borderRadius: { string },
                  boxShadow: { string },
                  padding: { string },
                  __type__: { object }
                },
                line: {
                  borderLeft: { string },
                  height: { string },
                  width: { string },
                  __type__: { object }
                },
                dot: {
                  border: { string },
                  borderRadius: { string },
                  height: { string },
                  width: { string },
                  __type__: { object }
                },
                __type__: { object }
              },
              xValueLabel: { "function": "function" },
              yValueLabel: { "function": "function" },
              zValueLabel: { "function": "function" },
              valueMax: { number, "undefined": "undefined" },
              valueMin: { number, "undefined": "undefined" },
              verticalRatio: { number },
              //globals :
              height: { string },
              width: { string },
              __type__: { object }
            };
            exports2.allOptions = allOptions;
          },
          /* 173 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Range = __webpack_require__(174);
            var Filter = __webpack_require__(96);
            var Settings = __webpack_require__(94);
            var Point3d = __webpack_require__(34);
            function DataGroup() {
              this.dataTable = null;
            }
            DataGroup.prototype.initializeData = function(graph3d, rawData, style) {
              if (rawData === void 0) return;
              if (Array.isArray(rawData)) {
                rawData = new DataSet(rawData);
              }
              var data;
              if (rawData instanceof DataSet || rawData instanceof DataView) {
                data = rawData.get();
              } else {
                throw new Error("Array, DataSet, or DataView expected");
              }
              if (data.length == 0) return;
              this.style = style;
              if (this.dataSet) {
                this.dataSet.off("*", this._onChange);
              }
              this.dataSet = rawData;
              this.dataTable = data;
              var me = this;
              this._onChange = function() {
                graph3d.setData(me.dataSet);
              };
              this.dataSet.on("*", this._onChange);
              this.colX = "x";
              this.colY = "y";
              this.colZ = "z";
              var withBars = graph3d.hasBars(style);
              if (withBars) {
                if (graph3d.defaultXBarWidth !== void 0) {
                  this.xBarWidth = graph3d.defaultXBarWidth;
                } else {
                  this.xBarWidth = this.getSmallestDifference(data, this.colX) || 1;
                }
                if (graph3d.defaultYBarWidth !== void 0) {
                  this.yBarWidth = graph3d.defaultYBarWidth;
                } else {
                  this.yBarWidth = this.getSmallestDifference(data, this.colY) || 1;
                }
              }
              this._initializeRange(data, this.colX, graph3d, withBars);
              this._initializeRange(data, this.colY, graph3d, withBars);
              this._initializeRange(data, this.colZ, graph3d, false);
              if (data[0].hasOwnProperty("style")) {
                this.colValue = "style";
                var valueRange = this.getColumnRange(data, this.colValue);
                this._setRangeDefaults(valueRange, graph3d.defaultValueMin, graph3d.defaultValueMax);
                this.valueRange = valueRange;
              }
              var table = this.getDataTable();
              if (table[0].hasOwnProperty("filter")) {
                if (this.dataFilter === void 0) {
                  this.dataFilter = new Filter(this, "filter", graph3d);
                  this.dataFilter.setOnLoadCallback(function() {
                    graph3d.redraw();
                  });
                }
              }
              var dataPoints;
              if (this.dataFilter) {
                dataPoints = this.dataFilter._getDataPoints();
              } else {
                dataPoints = this._getDataPoints(this.getDataTable());
              }
              return dataPoints;
            };
            DataGroup.prototype._collectRangeSettings = function(column, graph3d) {
              var index = ["x", "y", "z"].indexOf(column);
              if (index == -1) {
                throw new Error("Column '" + column + "' invalid");
              }
              var upper = column.toUpperCase();
              return {
                barWidth: this[column + "BarWidth"],
                min: graph3d["default" + upper + "Min"],
                max: graph3d["default" + upper + "Max"],
                step: graph3d["default" + upper + "Step"],
                range_label: column + "Range",
                // Name of instance field to write to
                step_label: column + "Step"
                // Name of instance field to write to
              };
            };
            DataGroup.prototype._initializeRange = function(data, column, graph3d, withBars) {
              var NUMSTEPS = 5;
              var settings = this._collectRangeSettings(column, graph3d);
              var range = this.getColumnRange(data, column);
              if (withBars && column != "z") {
                range.expand(settings.barWidth / 2);
              }
              this._setRangeDefaults(range, settings.min, settings.max);
              this[settings.range_label] = range;
              this[settings.step_label] = settings.step !== void 0 ? settings.step : range.range() / NUMSTEPS;
            };
            DataGroup.prototype.getDistinctValues = function(column, data) {
              if (data === void 0) {
                data = this.dataTable;
              }
              var values = [];
              for (var i = 0; i < data.length; i++) {
                var value = data[i][column] || 0;
                if (values.indexOf(value) === -1) {
                  values.push(value);
                }
              }
              return values.sort(function(a, b) {
                return a - b;
              });
            };
            DataGroup.prototype.getSmallestDifference = function(data, column) {
              var values = this.getDistinctValues(data, column);
              var smallest_diff = null;
              for (var i = 1; i < values.length; i++) {
                var diff = values[i] - values[i - 1];
                if (smallest_diff == null || smallest_diff > diff) {
                  smallest_diff = diff;
                }
              }
              return smallest_diff;
            };
            DataGroup.prototype.getColumnRange = function(data, column) {
              var range = new Range();
              for (var i = 0; i < data.length; i++) {
                var item = data[i][column];
                range.adjust(item);
              }
              return range;
            };
            DataGroup.prototype.getNumberOfRows = function() {
              return this.dataTable.length;
            };
            DataGroup.prototype._setRangeDefaults = function(range, defaultMin, defaultMax) {
              if (defaultMin !== void 0) {
                range.min = defaultMin;
              }
              if (defaultMax !== void 0) {
                range.max = defaultMax;
              }
              if (range.max <= range.min) range.max = range.min + 1;
            };
            DataGroup.prototype.getDataTable = function() {
              return this.dataTable;
            };
            DataGroup.prototype.getDataSet = function() {
              return this.dataSet;
            };
            DataGroup.prototype.getDataPoints = function(data) {
              var dataPoints = [];
              for (var i = 0; i < data.length; i++) {
                var point = new Point3d();
                point.x = data[i][this.colX] || 0;
                point.y = data[i][this.colY] || 0;
                point.z = data[i][this.colZ] || 0;
                point.data = data[i];
                if (this.colValue !== void 0) {
                  point.value = data[i][this.colValue] || 0;
                }
                var obj = {};
                obj.point = point;
                obj.bottom = new Point3d(point.x, point.y, this.zRange.min);
                obj.trans = void 0;
                obj.screen = void 0;
                dataPoints.push(obj);
              }
              return dataPoints;
            };
            DataGroup.prototype.initDataAsMatrix = function(data) {
              var x, y, i, obj;
              var dataX = this.getDistinctValues(this.colX, data);
              var dataY = this.getDistinctValues(this.colY, data);
              var dataPoints = this.getDataPoints(data);
              var dataMatrix = [];
              for (i = 0; i < dataPoints.length; i++) {
                obj = dataPoints[i];
                var xIndex = dataX.indexOf(obj.point.x);
                var yIndex = dataY.indexOf(obj.point.y);
                if (dataMatrix[xIndex] === void 0) {
                  dataMatrix[xIndex] = [];
                }
                dataMatrix[xIndex][yIndex] = obj;
              }
              for (x = 0; x < dataMatrix.length; x++) {
                for (y = 0; y < dataMatrix[x].length; y++) {
                  if (dataMatrix[x][y]) {
                    dataMatrix[x][y].pointRight = x < dataMatrix.length - 1 ? dataMatrix[x + 1][y] : void 0;
                    dataMatrix[x][y].pointTop = y < dataMatrix[x].length - 1 ? dataMatrix[x][y + 1] : void 0;
                    dataMatrix[x][y].pointCross = x < dataMatrix.length - 1 && y < dataMatrix[x].length - 1 ? dataMatrix[x + 1][y + 1] : void 0;
                  }
                }
              }
              return dataPoints;
            };
            DataGroup.prototype.getInfo = function() {
              var dataFilter = this.dataFilter;
              if (!dataFilter) return void 0;
              return dataFilter.getLabel() + ": " + dataFilter.getSelectedValue();
            };
            DataGroup.prototype.reload = function() {
              if (this.dataTable) {
                this.setData(this.dataTable);
              }
            };
            DataGroup.prototype._getDataPoints = function(data) {
              var dataPoints = [];
              if (this.style === Settings.STYLE.GRID || this.style === Settings.STYLE.SURFACE) {
                dataPoints = this.initDataAsMatrix(data);
              } else {
                this._checkValueField(data);
                dataPoints = this.getDataPoints(data);
                if (this.style === Settings.STYLE.LINE) {
                  for (var i = 0; i < dataPoints.length; i++) {
                    if (i > 0) {
                      dataPoints[i - 1].pointNext = dataPoints[i];
                    }
                  }
                }
              }
              return dataPoints;
            };
            DataGroup.prototype._checkValueField = function(data) {
              var hasValueField = this.style === Settings.STYLE.BARCOLOR || this.style === Settings.STYLE.BARSIZE || this.style === Settings.STYLE.DOTCOLOR || this.style === Settings.STYLE.DOTSIZE;
              if (!hasValueField) {
                return;
              }
              if (this.colValue === void 0) {
                throw new Error("Expected data to have  field 'style'  for graph style '" + this.style + "'");
              }
              if (data[0][this.colValue] === void 0) {
                throw new Error("Expected data to have  field '" + this.colValue + "'  for graph style '" + this.style + "'");
              }
            };
            module2.exports = DataGroup;
          },
          /* 174 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function Range() {
              this.min = void 0;
              this.max = void 0;
            }
            Range.prototype.adjust = function(value) {
              if (value === void 0) return;
              if (this.min === void 0 || this.min > value) {
                this.min = value;
              }
              if (this.max === void 0 || this.max < value) {
                this.max = value;
              }
            };
            Range.prototype.combine = function(range) {
              this.add(range.min);
              this.add(range.max);
            };
            Range.prototype.expand = function(val) {
              if (val === void 0) {
                return;
              }
              var newMin = this.min - val;
              var newMax = this.max + val;
              if (newMin > newMax) {
                throw new Error("Passed expansion value makes range invalid");
              }
              this.min = newMin;
              this.max = newMax;
            };
            Range.prototype.range = function() {
              return this.max - this.min;
            };
            Range.prototype.center = function() {
              return (this.min + this.max) / 2;
            };
            module2.exports = Range;
          },
          /* 175 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(factory) {
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof exports2 === "object") {
                module2.exports = factory();
              } else {
                window.propagating = factory();
              }
            })(function() {
              var _firstTarget = null;
              return function propagating(hammer, options) {
                var _options = options || {
                  preventDefault: false
                };
                if (hammer.Manager) {
                  var Hammer = hammer;
                  var PropagatingHammer = function(element2, options2) {
                    var o = Object.create(_options);
                    if (options2) Hammer.assign(o, options2);
                    return propagating(new Hammer(element2, o), o);
                  };
                  Hammer.assign(PropagatingHammer, Hammer);
                  PropagatingHammer.Manager = function(element2, options2) {
                    var o = Object.create(_options);
                    if (options2) Hammer.assign(o, options2);
                    return propagating(new Hammer.Manager(element2, o), o);
                  };
                  return PropagatingHammer;
                }
                var wrapper = Object.create(hammer);
                var element = hammer.element;
                if (!element.hammer) element.hammer = [];
                element.hammer.push(wrapper);
                hammer.on("hammer.input", function(event) {
                  if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {
                    event.preventDefault();
                  }
                  if (event.isFirst) {
                    _firstTarget = event.target;
                  }
                });
                wrapper._handlers = {};
                wrapper.on = function(events, handler) {
                  split(events).forEach(function(event) {
                    var _handlers = wrapper._handlers[event];
                    if (!_handlers) {
                      wrapper._handlers[event] = _handlers = [];
                      hammer.on(event, propagatedHandler);
                    }
                    _handlers.push(handler);
                  });
                  return wrapper;
                };
                wrapper.off = function(events, handler) {
                  split(events).forEach(function(event) {
                    var _handlers = wrapper._handlers[event];
                    if (_handlers) {
                      _handlers = handler ? _handlers.filter(function(h) {
                        return h !== handler;
                      }) : [];
                      if (_handlers.length > 0) {
                        wrapper._handlers[event] = _handlers;
                      } else {
                        hammer.off(event, propagatedHandler);
                        delete wrapper._handlers[event];
                      }
                    }
                  });
                  return wrapper;
                };
                wrapper.emit = function(eventType, event) {
                  _firstTarget = event.target;
                  hammer.emit(eventType, event);
                };
                wrapper.destroy = function() {
                  var hammers = hammer.element.hammer;
                  var idx = hammers.indexOf(wrapper);
                  if (idx !== -1) hammers.splice(idx, 1);
                  if (!hammers.length) delete hammer.element.hammer;
                  wrapper._handlers = {};
                  hammer.destroy();
                };
                function split(events) {
                  return events.match(/[^ ]+/g);
                }
                function propagatedHandler(event) {
                  if (event.type !== "hammer.input") {
                    if (!event.srcEvent._handled) {
                      event.srcEvent._handled = {};
                    }
                    if (event.srcEvent._handled[event.type]) {
                      return;
                    } else {
                      event.srcEvent._handled[event.type] = true;
                    }
                  }
                  var stopped = false;
                  event.stopPropagation = function() {
                    stopped = true;
                  };
                  var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
                  if (typeof srcStop == "function") {
                    event.srcEvent.stopPropagation = function() {
                      srcStop();
                      event.stopPropagation();
                    };
                  }
                  event.firstTarget = _firstTarget;
                  var elem = _firstTarget;
                  while (elem && !stopped) {
                    var elemHammer = elem.hammer;
                    if (elemHammer) {
                      var _handlers;
                      for (var k = 0; k < elemHammer.length; k++) {
                        _handlers = elemHammer[k]._handlers[event.type];
                        if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
                          _handlers[i](event);
                        }
                      }
                    }
                    elem = elem.parentNode;
                  }
                }
                return wrapper;
              };
            });
          },
          /* 176 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            (function(window2, document2, exportName, undefined2) {
              "use strict";
              var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
              var TEST_ELEMENT = document2.createElement("div");
              var TYPE_FUNCTION = "function";
              var round = Math.round;
              var abs = Math.abs;
              var now = Date.now;
              function setTimeoutContext(fn, timeout, context) {
                return setTimeout(bindFn(fn, context), timeout);
              }
              function invokeArrayArg(arg, fn, context) {
                if (Array.isArray(arg)) {
                  each(arg, context[fn], context);
                  return true;
                }
                return false;
              }
              function each(obj, iterator, context) {
                var i;
                if (!obj) {
                  return;
                }
                if (obj.forEach) {
                  obj.forEach(iterator, context);
                } else if (obj.length !== undefined2) {
                  i = 0;
                  while (i < obj.length) {
                    iterator.call(context, obj[i], i, obj);
                    i++;
                  }
                } else {
                  for (i in obj) {
                    obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
                  }
                }
              }
              function deprecate(method, name, message) {
                var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
                return function() {
                  var e = new Error("get-stack-trace");
                  var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
                  var log = window2.console && (window2.console.warn || window2.console.log);
                  if (log) {
                    log.call(window2.console, deprecationMessage, stack);
                  }
                  return method.apply(this, arguments);
                };
              }
              var assign;
              if (typeof Object.assign !== "function") {
                assign = function assign2(target) {
                  if (target === undefined2 || target === null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                  }
                  var output = Object(target);
                  for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined2 && source !== null) {
                      for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                        }
                      }
                    }
                  }
                  return output;
                };
              } else {
                assign = Object.assign;
              }
              var extend = deprecate(function extend2(dest, src, merge2) {
                var keys = Object.keys(src);
                var i = 0;
                while (i < keys.length) {
                  if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
                    dest[keys[i]] = src[keys[i]];
                  }
                  i++;
                }
                return dest;
              }, "extend", "Use `assign`.");
              var merge = deprecate(function merge2(dest, src) {
                return extend(dest, src, true);
              }, "merge", "Use `assign`.");
              function inherit(child, base, properties) {
                var baseP = base.prototype, childP;
                childP = child.prototype = Object.create(baseP);
                childP.constructor = child;
                childP._super = baseP;
                if (properties) {
                  assign(childP, properties);
                }
              }
              function bindFn(fn, context) {
                return function boundFn() {
                  return fn.apply(context, arguments);
                };
              }
              function boolOrFn(val, args) {
                if (typeof val == TYPE_FUNCTION) {
                  return val.apply(args ? args[0] || undefined2 : undefined2, args);
                }
                return val;
              }
              function ifUndefined(val1, val2) {
                return val1 === undefined2 ? val2 : val1;
              }
              function addEventListeners(target, types, handler) {
                each(splitStr(types), function(type) {
                  target.addEventListener(type, handler, false);
                });
              }
              function removeEventListeners(target, types, handler) {
                each(splitStr(types), function(type) {
                  target.removeEventListener(type, handler, false);
                });
              }
              function hasParent(node, parent) {
                while (node) {
                  if (node == parent) {
                    return true;
                  }
                  node = node.parentNode;
                }
                return false;
              }
              function inStr(str, find) {
                return str.indexOf(find) > -1;
              }
              function splitStr(str) {
                return str.trim().split(/\s+/g);
              }
              function inArray(src, find, findByKey) {
                if (src.indexOf && !findByKey) {
                  return src.indexOf(find);
                } else {
                  var i = 0;
                  while (i < src.length) {
                    if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                      return i;
                    }
                    i++;
                  }
                  return -1;
                }
              }
              function toArray(obj) {
                return Array.prototype.slice.call(obj, 0);
              }
              function uniqueArray(src, key, sort) {
                var results = [];
                var values = [];
                var i = 0;
                while (i < src.length) {
                  var val = key ? src[i][key] : src[i];
                  if (inArray(values, val) < 0) {
                    results.push(src[i]);
                  }
                  values[i] = val;
                  i++;
                }
                if (sort) {
                  if (!key) {
                    results = results.sort();
                  } else {
                    results = results.sort(function sortUniqueArray(a, b) {
                      return a[key] > b[key];
                    });
                  }
                }
                return results;
              }
              function prefixed(obj, property) {
                var prefix, prop;
                var camelProp = property[0].toUpperCase() + property.slice(1);
                var i = 0;
                while (i < VENDOR_PREFIXES.length) {
                  prefix = VENDOR_PREFIXES[i];
                  prop = prefix ? prefix + camelProp : property;
                  if (prop in obj) {
                    return prop;
                  }
                  i++;
                }
                return undefined2;
              }
              var _uniqueId = 1;
              function uniqueId() {
                return _uniqueId++;
              }
              function getWindowForElement(element) {
                var doc = element.ownerDocument || element;
                return doc.defaultView || doc.parentWindow || window2;
              }
              var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
              var SUPPORT_TOUCH = "ontouchstart" in window2;
              var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
              var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
              var INPUT_TYPE_TOUCH = "touch";
              var INPUT_TYPE_PEN = "pen";
              var INPUT_TYPE_MOUSE = "mouse";
              var INPUT_TYPE_KINECT = "kinect";
              var COMPUTE_INTERVAL = 25;
              var INPUT_START = 1;
              var INPUT_MOVE = 2;
              var INPUT_END = 4;
              var INPUT_CANCEL = 8;
              var DIRECTION_NONE = 1;
              var DIRECTION_LEFT = 2;
              var DIRECTION_RIGHT = 4;
              var DIRECTION_UP = 8;
              var DIRECTION_DOWN = 16;
              var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
              var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
              var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
              var PROPS_XY = ["x", "y"];
              var PROPS_CLIENT_XY = ["clientX", "clientY"];
              function Input(manager, callback) {
                var self2 = this;
                this.manager = manager;
                this.callback = callback;
                this.element = manager.element;
                this.target = manager.options.inputTarget;
                this.domHandler = function(ev) {
                  if (boolOrFn(manager.options.enable, [manager])) {
                    self2.handler(ev);
                  }
                };
                this.init();
              }
              Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function() {
                },
                /**
                 * bind the events
                 */
                init: function() {
                  this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                  this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                  this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function() {
                  this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                  this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                  this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
              };
              function createInputInstance(manager) {
                var Type;
                var inputClass = manager.options.inputClass;
                if (inputClass) {
                  Type = inputClass;
                } else if (SUPPORT_POINTER_EVENTS) {
                  Type = PointerEventInput;
                } else if (SUPPORT_ONLY_TOUCH) {
                  Type = TouchInput;
                } else if (!SUPPORT_TOUCH) {
                  Type = MouseInput;
                } else {
                  Type = TouchMouseInput;
                }
                return new Type(manager, inputHandler);
              }
              function inputHandler(manager, eventType, input) {
                var pointersLen = input.pointers.length;
                var changedPointersLen = input.changedPointers.length;
                var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
                var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
                input.isFirst = !!isFirst;
                input.isFinal = !!isFinal;
                if (isFirst) {
                  manager.session = {};
                }
                input.eventType = eventType;
                computeInputData(manager, input);
                manager.emit("hammer.input", input);
                manager.recognize(input);
                manager.session.prevInput = input;
              }
              function computeInputData(manager, input) {
                var session = manager.session;
                var pointers = input.pointers;
                var pointersLength = pointers.length;
                if (!session.firstInput) {
                  session.firstInput = simpleCloneInputData(input);
                }
                if (pointersLength > 1 && !session.firstMultiple) {
                  session.firstMultiple = simpleCloneInputData(input);
                } else if (pointersLength === 1) {
                  session.firstMultiple = false;
                }
                var firstInput = session.firstInput;
                var firstMultiple = session.firstMultiple;
                var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
                var center = input.center = getCenter(pointers);
                input.timeStamp = now();
                input.deltaTime = input.timeStamp - firstInput.timeStamp;
                input.angle = getAngle(offsetCenter, center);
                input.distance = getDistance(offsetCenter, center);
                computeDeltaXY(session, input);
                input.offsetDirection = getDirection(input.deltaX, input.deltaY);
                var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
                input.overallVelocityX = overallVelocity.x;
                input.overallVelocityY = overallVelocity.y;
                input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
                input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
                input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
                input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
                computeIntervalInputData(session, input);
                var target = manager.element;
                if (hasParent(input.srcEvent.target, target)) {
                  target = input.srcEvent.target;
                }
                input.target = target;
              }
              function computeDeltaXY(session, input) {
                var center = input.center;
                var offset = session.offsetDelta || {};
                var prevDelta = session.prevDelta || {};
                var prevInput = session.prevInput || {};
                if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                  prevDelta = session.prevDelta = {
                    x: prevInput.deltaX || 0,
                    y: prevInput.deltaY || 0
                  };
                  offset = session.offsetDelta = {
                    x: center.x,
                    y: center.y
                  };
                }
                input.deltaX = prevDelta.x + (center.x - offset.x);
                input.deltaY = prevDelta.y + (center.y - offset.y);
              }
              function computeIntervalInputData(session, input) {
                var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
                if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
                  var deltaX = input.deltaX - last.deltaX;
                  var deltaY = input.deltaY - last.deltaY;
                  var v = getVelocity(deltaTime, deltaX, deltaY);
                  velocityX = v.x;
                  velocityY = v.y;
                  velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
                  direction = getDirection(deltaX, deltaY);
                  session.lastInterval = input;
                } else {
                  velocity = last.velocity;
                  velocityX = last.velocityX;
                  velocityY = last.velocityY;
                  direction = last.direction;
                }
                input.velocity = velocity;
                input.velocityX = velocityX;
                input.velocityY = velocityY;
                input.direction = direction;
              }
              function simpleCloneInputData(input) {
                var pointers = [];
                var i = 0;
                while (i < input.pointers.length) {
                  pointers[i] = {
                    clientX: round(input.pointers[i].clientX),
                    clientY: round(input.pointers[i].clientY)
                  };
                  i++;
                }
                return {
                  timeStamp: now(),
                  pointers,
                  center: getCenter(pointers),
                  deltaX: input.deltaX,
                  deltaY: input.deltaY
                };
              }
              function getCenter(pointers) {
                var pointersLength = pointers.length;
                if (pointersLength === 1) {
                  return {
                    x: round(pointers[0].clientX),
                    y: round(pointers[0].clientY)
                  };
                }
                var x = 0, y = 0, i = 0;
                while (i < pointersLength) {
                  x += pointers[i].clientX;
                  y += pointers[i].clientY;
                  i++;
                }
                return {
                  x: round(x / pointersLength),
                  y: round(y / pointersLength)
                };
              }
              function getVelocity(deltaTime, x, y) {
                return {
                  x: x / deltaTime || 0,
                  y: y / deltaTime || 0
                };
              }
              function getDirection(x, y) {
                if (x === y) {
                  return DIRECTION_NONE;
                }
                if (abs(x) >= abs(y)) {
                  return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                }
                return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              }
              function getDistance(p1, p2, props) {
                if (!props) {
                  props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.sqrt(x * x + y * y);
              }
              function getAngle(p1, p2, props) {
                if (!props) {
                  props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.atan2(y, x) * 180 / Math.PI;
              }
              function getRotation(start, end) {
                return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
              }
              function getScale(start, end) {
                return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
              }
              var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
              };
              var MOUSE_ELEMENT_EVENTS = "mousedown";
              var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
              function MouseInput() {
                this.evEl = MOUSE_ELEMENT_EVENTS;
                this.evWin = MOUSE_WINDOW_EVENTS;
                this.pressed = false;
                Input.apply(this, arguments);
              }
              inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                  var eventType = MOUSE_INPUT_MAP[ev.type];
                  if (eventType & INPUT_START && ev.button === 0) {
                    this.pressed = true;
                  }
                  if (eventType & INPUT_MOVE && ev.which !== 1) {
                    eventType = INPUT_END;
                  }
                  if (!this.pressed) {
                    return;
                  }
                  if (eventType & INPUT_END) {
                    this.pressed = false;
                  }
                  this.callback(this.manager, eventType, {
                    pointers: [ev],
                    changedPointers: [ev],
                    pointerType: INPUT_TYPE_MOUSE,
                    srcEvent: ev
                  });
                }
              });
              var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
              };
              var IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT
                // see https://twitter.com/jacobrossi/status/480596438489890816
              };
              var POINTER_ELEMENT_EVENTS = "pointerdown";
              var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
              if (window2.MSPointerEvent && !window2.PointerEvent) {
                POINTER_ELEMENT_EVENTS = "MSPointerDown";
                POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
              }
              function PointerEventInput() {
                this.evEl = POINTER_ELEMENT_EVENTS;
                this.evWin = POINTER_WINDOW_EVENTS;
                Input.apply(this, arguments);
                this.store = this.manager.session.pointerEvents = [];
              }
              inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                  var store = this.store;
                  var removePointer = false;
                  var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
                  var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                  var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                  var isTouch = pointerType == INPUT_TYPE_TOUCH;
                  var storeIndex = inArray(store, ev.pointerId, "pointerId");
                  if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                    if (storeIndex < 0) {
                      store.push(ev);
                      storeIndex = store.length - 1;
                    }
                  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                    removePointer = true;
                  }
                  if (storeIndex < 0) {
                    return;
                  }
                  store[storeIndex] = ev;
                  this.callback(this.manager, eventType, {
                    pointers: store,
                    changedPointers: [ev],
                    pointerType,
                    srcEvent: ev
                  });
                  if (removePointer) {
                    store.splice(storeIndex, 1);
                  }
                }
              });
              var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
              };
              var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
              var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
              function SingleTouchInput() {
                this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
                this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
                this.started = false;
                Input.apply(this, arguments);
              }
              inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                  var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                  if (type === INPUT_START) {
                    this.started = true;
                  }
                  if (!this.started) {
                    return;
                  }
                  var touches = normalizeSingleTouches.call(this, ev, type);
                  if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                    this.started = false;
                  }
                  this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                  });
                }
              });
              function normalizeSingleTouches(ev, type) {
                var all = toArray(ev.touches);
                var changed = toArray(ev.changedTouches);
                if (type & (INPUT_END | INPUT_CANCEL)) {
                  all = uniqueArray(all.concat(changed), "identifier", true);
                }
                return [all, changed];
              }
              var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
              };
              var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
              function TouchInput() {
                this.evTarget = TOUCH_TARGET_EVENTS;
                this.targetIds = {};
                Input.apply(this, arguments);
              }
              inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                  var type = TOUCH_INPUT_MAP[ev.type];
                  var touches = getTouches.call(this, ev, type);
                  if (!touches) {
                    return;
                  }
                  this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                  });
                }
              });
              function getTouches(ev, type) {
                var allTouches = toArray(ev.touches);
                var targetIds = this.targetIds;
                if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                  targetIds[allTouches[0].identifier] = true;
                  return [allTouches, allTouches];
                }
                var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
                targetTouches = allTouches.filter(function(touch) {
                  return hasParent(touch.target, target);
                });
                if (type === INPUT_START) {
                  i = 0;
                  while (i < targetTouches.length) {
                    targetIds[targetTouches[i].identifier] = true;
                    i++;
                  }
                }
                i = 0;
                while (i < changedTouches.length) {
                  if (targetIds[changedTouches[i].identifier]) {
                    changedTargetTouches.push(changedTouches[i]);
                  }
                  if (type & (INPUT_END | INPUT_CANCEL)) {
                    delete targetIds[changedTouches[i].identifier];
                  }
                  i++;
                }
                if (!changedTargetTouches.length) {
                  return;
                }
                return [
                  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                  uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
                  changedTargetTouches
                ];
              }
              var DEDUP_TIMEOUT = 2500;
              var DEDUP_DISTANCE = 25;
              function TouchMouseInput() {
                Input.apply(this, arguments);
                var handler = bindFn(this.handler, this);
                this.touch = new TouchInput(this.manager, handler);
                this.mouse = new MouseInput(this.manager, handler);
                this.primaryTouch = null;
                this.lastTouches = [];
              }
              inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                  var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                  if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                    return;
                  }
                  if (isTouch) {
                    recordTouches.call(this, inputEvent, inputData);
                  } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                    return;
                  }
                  this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                  this.touch.destroy();
                  this.mouse.destroy();
                }
              });
              function recordTouches(eventType, eventData) {
                if (eventType & INPUT_START) {
                  this.primaryTouch = eventData.changedPointers[0].identifier;
                  setLastTouch.call(this, eventData);
                } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                  setLastTouch.call(this, eventData);
                }
              }
              function setLastTouch(eventData) {
                var touch = eventData.changedPointers[0];
                if (touch.identifier === this.primaryTouch) {
                  var lastTouch = { x: touch.clientX, y: touch.clientY };
                  this.lastTouches.push(lastTouch);
                  var lts = this.lastTouches;
                  var removeLastTouch = function() {
                    var i = lts.indexOf(lastTouch);
                    if (i > -1) {
                      lts.splice(i, 1);
                    }
                  };
                  setTimeout(removeLastTouch, DEDUP_TIMEOUT);
                }
              }
              function isSyntheticEvent(eventData) {
                var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
                for (var i = 0; i < this.lastTouches.length; i++) {
                  var t = this.lastTouches[i];
                  var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
                  if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                    return true;
                  }
                }
                return false;
              }
              var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
              var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
              var TOUCH_ACTION_COMPUTE = "compute";
              var TOUCH_ACTION_AUTO = "auto";
              var TOUCH_ACTION_MANIPULATION = "manipulation";
              var TOUCH_ACTION_NONE = "none";
              var TOUCH_ACTION_PAN_X = "pan-x";
              var TOUCH_ACTION_PAN_Y = "pan-y";
              var TOUCH_ACTION_MAP = getTouchActionProps();
              function TouchAction(manager, value) {
                this.manager = manager;
                this.set(value);
              }
              TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function(value) {
                  if (value == TOUCH_ACTION_COMPUTE) {
                    value = this.compute();
                  }
                  if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                    this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                  }
                  this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function() {
                  this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function() {
                  var actions = [];
                  each(this.manager.recognizers, function(recognizer) {
                    if (boolOrFn(recognizer.options.enable, [recognizer])) {
                      actions = actions.concat(recognizer.getTouchAction());
                    }
                  });
                  return cleanTouchActions(actions.join(" "));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function(input) {
                  var srcEvent = input.srcEvent;
                  var direction = input.offsetDirection;
                  if (this.manager.session.prevented) {
                    srcEvent.preventDefault();
                    return;
                  }
                  var actions = this.actions;
                  var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
                  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
                  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
                  if (hasNone) {
                    var isTapPointer = input.pointers.length === 1;
                    var isTapMovement = input.distance < 2;
                    var isTapTouchTime = input.deltaTime < 250;
                    if (isTapPointer && isTapMovement && isTapTouchTime) {
                      return;
                    }
                  }
                  if (hasPanX && hasPanY) {
                    return;
                  }
                  if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                    return this.preventSrc(srcEvent);
                  }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function(srcEvent) {
                  this.manager.session.prevented = true;
                  srcEvent.preventDefault();
                }
              };
              function cleanTouchActions(actions) {
                if (inStr(actions, TOUCH_ACTION_NONE)) {
                  return TOUCH_ACTION_NONE;
                }
                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                if (hasPanX && hasPanY) {
                  return TOUCH_ACTION_NONE;
                }
                if (hasPanX || hasPanY) {
                  return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
                }
                if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                  return TOUCH_ACTION_MANIPULATION;
                }
                return TOUCH_ACTION_AUTO;
              }
              function getTouchActionProps() {
                if (!NATIVE_TOUCH_ACTION) {
                  return false;
                }
                var touchMap = {};
                var cssSupports = window2.CSS && window2.CSS.supports;
                ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
                  touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
                });
                return touchMap;
              }
              var STATE_POSSIBLE = 1;
              var STATE_BEGAN = 2;
              var STATE_CHANGED = 4;
              var STATE_ENDED = 8;
              var STATE_RECOGNIZED = STATE_ENDED;
              var STATE_CANCELLED = 16;
              var STATE_FAILED = 32;
              function Recognizer(options) {
                this.options = assign({}, this.defaults, options || {});
                this.id = uniqueId();
                this.manager = null;
                this.options.enable = ifUndefined(this.options.enable, true);
                this.state = STATE_POSSIBLE;
                this.simultaneous = {};
                this.requireFail = [];
              }
              Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function(options) {
                  assign(this.options, options);
                  this.manager && this.manager.touchAction.update();
                  return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
                    return this;
                  }
                  var simultaneous = this.simultaneous;
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  if (!simultaneous[otherRecognizer.id]) {
                    simultaneous[otherRecognizer.id] = otherRecognizer;
                    otherRecognizer.recognizeWith(this);
                  }
                  return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
                    return this;
                  }
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  delete this.simultaneous[otherRecognizer.id];
                  return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
                    return this;
                  }
                  var requireFail = this.requireFail;
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  if (inArray(requireFail, otherRecognizer) === -1) {
                    requireFail.push(otherRecognizer);
                    otherRecognizer.requireFailure(this);
                  }
                  return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function(otherRecognizer) {
                  if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
                    return this;
                  }
                  otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                  var index = inArray(this.requireFail, otherRecognizer);
                  if (index > -1) {
                    this.requireFail.splice(index, 1);
                  }
                  return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function() {
                  return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function(otherRecognizer) {
                  return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function(input) {
                  var self2 = this;
                  var state = this.state;
                  function emit(event) {
                    self2.manager.emit(event, input);
                  }
                  if (state < STATE_ENDED) {
                    emit(self2.options.event + stateStr(state));
                  }
                  emit(self2.options.event);
                  if (input.additionalEvent) {
                    emit(input.additionalEvent);
                  }
                  if (state >= STATE_ENDED) {
                    emit(self2.options.event + stateStr(state));
                  }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function(input) {
                  if (this.canEmit()) {
                    return this.emit(input);
                  }
                  this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function() {
                  var i = 0;
                  while (i < this.requireFail.length) {
                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                      return false;
                    }
                    i++;
                  }
                  return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function(inputData) {
                  var inputDataClone = assign({}, inputData);
                  if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                    this.reset();
                    this.state = STATE_FAILED;
                    return;
                  }
                  if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                    this.state = STATE_POSSIBLE;
                  }
                  this.state = this.process(inputDataClone);
                  if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                    this.tryEmit(inputDataClone);
                  }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function(inputData) {
                },
                // jshint ignore:line
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function() {
                },
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function() {
                }
              };
              function stateStr(state) {
                if (state & STATE_CANCELLED) {
                  return "cancel";
                } else if (state & STATE_ENDED) {
                  return "end";
                } else if (state & STATE_CHANGED) {
                  return "move";
                } else if (state & STATE_BEGAN) {
                  return "start";
                }
                return "";
              }
              function directionStr(direction) {
                if (direction == DIRECTION_DOWN) {
                  return "down";
                } else if (direction == DIRECTION_UP) {
                  return "up";
                } else if (direction == DIRECTION_LEFT) {
                  return "left";
                } else if (direction == DIRECTION_RIGHT) {
                  return "right";
                }
                return "";
              }
              function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
                var manager = recognizer.manager;
                if (manager) {
                  return manager.get(otherRecognizer);
                }
                return otherRecognizer;
              }
              function AttrRecognizer() {
                Recognizer.apply(this, arguments);
              }
              inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                  /**
                   * @type {Number}
                   * @default 1
                   */
                  pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function(input) {
                  var optionPointers = this.options.pointers;
                  return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function(input) {
                  var state = this.state;
                  var eventType = input.eventType;
                  var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                  var isValid = this.attrTest(input);
                  if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                    return state | STATE_CANCELLED;
                  } else if (isRecognized || isValid) {
                    if (eventType & INPUT_END) {
                      return state | STATE_ENDED;
                    } else if (!(state & STATE_BEGAN)) {
                      return STATE_BEGAN;
                    }
                    return state | STATE_CHANGED;
                  }
                  return STATE_FAILED;
                }
              });
              function PanRecognizer() {
                AttrRecognizer.apply(this, arguments);
                this.pX = null;
                this.pY = null;
              }
              inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                  event: "pan",
                  threshold: 10,
                  pointers: 1,
                  direction: DIRECTION_ALL
                },
                getTouchAction: function() {
                  var direction = this.options.direction;
                  var actions = [];
                  if (direction & DIRECTION_HORIZONTAL) {
                    actions.push(TOUCH_ACTION_PAN_Y);
                  }
                  if (direction & DIRECTION_VERTICAL) {
                    actions.push(TOUCH_ACTION_PAN_X);
                  }
                  return actions;
                },
                directionTest: function(input) {
                  var options = this.options;
                  var hasMoved = true;
                  var distance = input.distance;
                  var direction = input.direction;
                  var x = input.deltaX;
                  var y = input.deltaY;
                  if (!(direction & options.direction)) {
                    if (options.direction & DIRECTION_HORIZONTAL) {
                      direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                      hasMoved = x != this.pX;
                      distance = Math.abs(input.deltaX);
                    } else {
                      direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                      hasMoved = y != this.pY;
                      distance = Math.abs(input.deltaY);
                    }
                  }
                  input.direction = direction;
                  return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function(input) {
                  return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function(input) {
                  this.pX = input.deltaX;
                  this.pY = input.deltaY;
                  var direction = directionStr(input.direction);
                  if (direction) {
                    input.additionalEvent = this.options.event + direction;
                  }
                  this._super.emit.call(this, input);
                }
              });
              function PinchRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                  event: "pinch",
                  threshold: 0,
                  pointers: 2
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_NONE];
                },
                attrTest: function(input) {
                  return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function(input) {
                  if (input.scale !== 1) {
                    var inOut = input.scale < 1 ? "in" : "out";
                    input.additionalEvent = this.options.event + inOut;
                  }
                  this._super.emit.call(this, input);
                }
              });
              function PressRecognizer() {
                Recognizer.apply(this, arguments);
                this._timer = null;
                this._input = null;
              }
              inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                  event: "press",
                  pointers: 1,
                  time: 251,
                  // minimal time of the pointer to be pressed
                  threshold: 9
                  // a minimal movement is ok, but keep it low
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_AUTO];
                },
                process: function(input) {
                  var options = this.options;
                  var validPointers = input.pointers.length === options.pointers;
                  var validMovement = input.distance < options.threshold;
                  var validTime = input.deltaTime > options.time;
                  this._input = input;
                  if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                    this.reset();
                  } else if (input.eventType & INPUT_START) {
                    this.reset();
                    this._timer = setTimeoutContext(function() {
                      this.state = STATE_RECOGNIZED;
                      this.tryEmit();
                    }, options.time, this);
                  } else if (input.eventType & INPUT_END) {
                    return STATE_RECOGNIZED;
                  }
                  return STATE_FAILED;
                },
                reset: function() {
                  clearTimeout(this._timer);
                },
                emit: function(input) {
                  if (this.state !== STATE_RECOGNIZED) {
                    return;
                  }
                  if (input && input.eventType & INPUT_END) {
                    this.manager.emit(this.options.event + "up", input);
                  } else {
                    this._input.timeStamp = now();
                    this.manager.emit(this.options.event, this._input);
                  }
                }
              });
              function RotateRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                  event: "rotate",
                  threshold: 0,
                  pointers: 2
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_NONE];
                },
                attrTest: function(input) {
                  return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
              });
              function SwipeRecognizer() {
                AttrRecognizer.apply(this, arguments);
              }
              inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                  event: "swipe",
                  threshold: 10,
                  velocity: 0.3,
                  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                  pointers: 1
                },
                getTouchAction: function() {
                  return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function(input) {
                  var direction = this.options.direction;
                  var velocity;
                  if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                    velocity = input.overallVelocity;
                  } else if (direction & DIRECTION_HORIZONTAL) {
                    velocity = input.overallVelocityX;
                  } else if (direction & DIRECTION_VERTICAL) {
                    velocity = input.overallVelocityY;
                  }
                  return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function(input) {
                  var direction = directionStr(input.offsetDirection);
                  if (direction) {
                    this.manager.emit(this.options.event + direction, input);
                  }
                  this.manager.emit(this.options.event, input);
                }
              });
              function TapRecognizer() {
                Recognizer.apply(this, arguments);
                this.pTime = false;
                this.pCenter = false;
                this._timer = null;
                this._input = null;
                this.count = 0;
              }
              inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                  event: "tap",
                  pointers: 1,
                  taps: 1,
                  interval: 300,
                  // max time between the multi-tap taps
                  time: 250,
                  // max time of the pointer to be down (like finger on the screen)
                  threshold: 9,
                  // a minimal movement is ok, but keep it low
                  posThreshold: 10
                  // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function() {
                  return [TOUCH_ACTION_MANIPULATION];
                },
                process: function(input) {
                  var options = this.options;
                  var validPointers = input.pointers.length === options.pointers;
                  var validMovement = input.distance < options.threshold;
                  var validTouchTime = input.deltaTime < options.time;
                  this.reset();
                  if (input.eventType & INPUT_START && this.count === 0) {
                    return this.failTimeout();
                  }
                  if (validMovement && validTouchTime && validPointers) {
                    if (input.eventType != INPUT_END) {
                      return this.failTimeout();
                    }
                    var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                    var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                    this.pTime = input.timeStamp;
                    this.pCenter = input.center;
                    if (!validMultiTap || !validInterval) {
                      this.count = 1;
                    } else {
                      this.count += 1;
                    }
                    this._input = input;
                    var tapCount = this.count % options.taps;
                    if (tapCount === 0) {
                      if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                      } else {
                        this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                      }
                    }
                  }
                  return STATE_FAILED;
                },
                failTimeout: function() {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_FAILED;
                  }, this.options.interval, this);
                  return STATE_FAILED;
                },
                reset: function() {
                  clearTimeout(this._timer);
                },
                emit: function() {
                  if (this.state == STATE_RECOGNIZED) {
                    this._input.tapCount = this.count;
                    this.manager.emit(this.options.event, this._input);
                  }
                }
              });
              function Hammer(element, options) {
                options = options || {};
                options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
                return new Manager(element, options);
              }
              Hammer.VERSION = "2.0.7";
              Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                  // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                  [RotateRecognizer, { enable: false }],
                  [PinchRecognizer, { enable: false }, ["rotate"]],
                  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
                  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
                  [TapRecognizer],
                  [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
                  [PressRecognizer]
                ],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                  /**
                   * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                   * @type {String}
                   * @default 'none'
                   */
                  userSelect: "none",
                  /**
                   * Disable the Windows Phone grippers when pressing an element.
                   * @type {String}
                   * @default 'none'
                   */
                  touchSelect: "none",
                  /**
                   * Disables the default callout shown when you touch and hold a touch target.
                   * On iOS, when you touch and hold a touch target such as a link, Safari displays
                   * a callout containing information about the link. This property allows you to disable that callout.
                   * @type {String}
                   * @default 'none'
                   */
                  touchCallout: "none",
                  /**
                   * Specifies whether zooming is enabled. Used by IE10>
                   * @type {String}
                   * @default 'none'
                   */
                  contentZooming: "none",
                  /**
                   * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                   * @type {String}
                   * @default 'none'
                   */
                  userDrag: "none",
                  /**
                   * Overrides the highlight color shown when the user taps a link or a JavaScript
                   * clickable element in iOS. This property obeys the alpha value, if specified.
                   * @type {String}
                   * @default 'rgba(0,0,0,0)'
                   */
                  tapHighlightColor: "rgba(0,0,0,0)"
                }
              };
              var STOP = 1;
              var FORCED_STOP = 2;
              function Manager(element, options) {
                this.options = assign({}, Hammer.defaults, options || {});
                this.options.inputTarget = this.options.inputTarget || element;
                this.handlers = {};
                this.session = {};
                this.recognizers = [];
                this.oldCssProps = {};
                this.element = element;
                this.input = createInputInstance(this);
                this.touchAction = new TouchAction(this, this.options.touchAction);
                toggleCssProps(this, true);
                each(this.options.recognizers, function(item) {
                  var recognizer = this.add(new item[0](item[1]));
                  item[2] && recognizer.recognizeWith(item[2]);
                  item[3] && recognizer.requireFailure(item[3]);
                }, this);
              }
              Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function(options) {
                  assign(this.options, options);
                  if (options.touchAction) {
                    this.touchAction.update();
                  }
                  if (options.inputTarget) {
                    this.input.destroy();
                    this.input.target = options.inputTarget;
                    this.input.init();
                  }
                  return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function(force) {
                  this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function(inputData) {
                  var session = this.session;
                  if (session.stopped) {
                    return;
                  }
                  this.touchAction.preventDefaults(inputData);
                  var recognizer;
                  var recognizers = this.recognizers;
                  var curRecognizer = session.curRecognizer;
                  if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                    curRecognizer = session.curRecognizer = null;
                  }
                  var i = 0;
                  while (i < recognizers.length) {
                    recognizer = recognizers[i];
                    if (session.stopped !== FORCED_STOP && // 1
                    (!curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) {
                      recognizer.recognize(inputData);
                    } else {
                      recognizer.reset();
                    }
                    if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                      curRecognizer = session.curRecognizer = recognizer;
                    }
                    i++;
                  }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function(recognizer) {
                  if (recognizer instanceof Recognizer) {
                    return recognizer;
                  }
                  var recognizers = this.recognizers;
                  for (var i = 0; i < recognizers.length; i++) {
                    if (recognizers[i].options.event == recognizer) {
                      return recognizers[i];
                    }
                  }
                  return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function(recognizer) {
                  if (invokeArrayArg(recognizer, "add", this)) {
                    return this;
                  }
                  var existing = this.get(recognizer.options.event);
                  if (existing) {
                    this.remove(existing);
                  }
                  this.recognizers.push(recognizer);
                  recognizer.manager = this;
                  this.touchAction.update();
                  return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function(recognizer) {
                  if (invokeArrayArg(recognizer, "remove", this)) {
                    return this;
                  }
                  recognizer = this.get(recognizer);
                  if (recognizer) {
                    var recognizers = this.recognizers;
                    var index = inArray(recognizers, recognizer);
                    if (index !== -1) {
                      recognizers.splice(index, 1);
                      this.touchAction.update();
                    }
                  }
                  return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function(events, handler) {
                  if (events === undefined2) {
                    return;
                  }
                  if (handler === undefined2) {
                    return;
                  }
                  var handlers = this.handlers;
                  each(splitStr(events), function(event) {
                    handlers[event] = handlers[event] || [];
                    handlers[event].push(handler);
                  });
                  return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function(events, handler) {
                  if (events === undefined2) {
                    return;
                  }
                  var handlers = this.handlers;
                  each(splitStr(events), function(event) {
                    if (!handler) {
                      delete handlers[event];
                    } else {
                      handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                    }
                  });
                  return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function(event, data) {
                  if (this.options.domEvents) {
                    triggerDomEvent(event, data);
                  }
                  var handlers = this.handlers[event] && this.handlers[event].slice();
                  if (!handlers || !handlers.length) {
                    return;
                  }
                  data.type = event;
                  data.preventDefault = function() {
                    data.srcEvent.preventDefault();
                  };
                  var i = 0;
                  while (i < handlers.length) {
                    handlers[i](data);
                    i++;
                  }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function() {
                  this.element && toggleCssProps(this, false);
                  this.handlers = {};
                  this.session = {};
                  this.input.destroy();
                  this.element = null;
                }
              };
              function toggleCssProps(manager, add) {
                var element = manager.element;
                if (!element.style) {
                  return;
                }
                var prop;
                each(manager.options.cssProps, function(value, name) {
                  prop = prefixed(element.style, name);
                  if (add) {
                    manager.oldCssProps[prop] = element.style[prop];
                    element.style[prop] = value;
                  } else {
                    element.style[prop] = manager.oldCssProps[prop] || "";
                  }
                });
                if (!add) {
                  manager.oldCssProps = {};
                }
              }
              function triggerDomEvent(event, data) {
                var gestureEvent = document2.createEvent("Event");
                gestureEvent.initEvent(event, true, true);
                gestureEvent.gesture = data;
                data.target.dispatchEvent(gestureEvent);
              }
              assign(Hammer, {
                INPUT_START,
                INPUT_MOVE,
                INPUT_END,
                INPUT_CANCEL,
                STATE_POSSIBLE,
                STATE_BEGAN,
                STATE_CHANGED,
                STATE_ENDED,
                STATE_RECOGNIZED,
                STATE_CANCELLED,
                STATE_FAILED,
                DIRECTION_NONE,
                DIRECTION_LEFT,
                DIRECTION_RIGHT,
                DIRECTION_UP,
                DIRECTION_DOWN,
                DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL,
                DIRECTION_ALL,
                Manager,
                Input,
                TouchAction,
                TouchInput,
                MouseInput,
                PointerEventInput,
                TouchMouseInput,
                SingleTouchInput,
                Recognizer,
                AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each,
                merge,
                extend,
                assign,
                inherit,
                bindFn,
                prefixed
              });
              var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
              freeGlobal.Hammer = Hammer;
              if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return Hammer;
                }).call(exports2, __webpack_require__, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof module2 != "undefined" && module2.exports) {
                module2.exports = Hammer;
              } else {
                window2[exportName] = Hammer;
              }
            })(window, document, "Hammer");
          },
          /* 177 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.util = __webpack_require__(2);
            exports2.DOMutil = __webpack_require__(14);
            exports2.DataSet = __webpack_require__(11);
            exports2.DataView = __webpack_require__(12);
            exports2.Queue = __webpack_require__(43);
            exports2.Timeline = __webpack_require__(178);
            exports2.Graph2d = __webpack_require__(180);
            exports2.timeline = {
              Core: __webpack_require__(65),
              DateUtil: __webpack_require__(36),
              Range: __webpack_require__(64),
              stack: __webpack_require__(100),
              TimeStep: __webpack_require__(66),
              components: {
                items: {
                  Item: __webpack_require__(38),
                  BackgroundItem: __webpack_require__(103),
                  BoxItem: __webpack_require__(101),
                  PointItem: __webpack_require__(102),
                  RangeItem: __webpack_require__(70)
                },
                BackgroundGroup: __webpack_require__(69),
                Component: __webpack_require__(16),
                CurrentTime: __webpack_require__(67),
                CustomTime: __webpack_require__(46),
                DataAxis: __webpack_require__(107),
                DataScale: __webpack_require__(108),
                GraphGroup: __webpack_require__(109),
                Group: __webpack_require__(68),
                ItemSet: __webpack_require__(99),
                Legend: __webpack_require__(112),
                LineGraph: __webpack_require__(106),
                TimeAxis: __webpack_require__(45)
              }
            };
            exports2.moment = __webpack_require__(9);
            exports2.Hammer = __webpack_require__(10);
            exports2.keycharm = __webpack_require__(35);
          },
          /* 178 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var moment = __webpack_require__(9);
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Range = __webpack_require__(64);
            var Core = __webpack_require__(65);
            var TimeAxis = __webpack_require__(45);
            var CurrentTime = __webpack_require__(67);
            var CustomTime = __webpack_require__(46);
            var ItemSet = __webpack_require__(99);
            var printStyle = __webpack_require__(15).printStyle;
            var allOptions = __webpack_require__(105).allOptions;
            var configureOptions = __webpack_require__(105).configureOptions;
            var Configurator = __webpack_require__(71)["default"];
            var Validator = __webpack_require__(15)["default"];
            function Timeline(container, items, groups, options) {
              if (!(this instanceof Timeline)) {
                throw new SyntaxError("Constructor must be called with the new operator");
              }
              if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
                var forthArgument = options;
                options = groups;
                groups = forthArgument;
              }
              if (options && options.throttleRedraw) {
                console.warn('Timeline option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.');
              }
              var me = this;
              this.defaultOptions = {
                start: null,
                end: null,
                autoResize: true,
                orientation: {
                  axis: "bottom",
                  // axis orientation: 'bottom', 'top', or 'both'
                  item: "bottom"
                  // not relevant
                },
                moment,
                width: null,
                height: null,
                maxHeight: null,
                minHeight: null
              };
              this.options = util.deepExtend({}, this.defaultOptions);
              this._create(container);
              if (!options || options && typeof options.rtl == "undefined") {
                this.dom.root.style.visibility = "hidden";
                var directionFromDom, domNode = this.dom.root;
                while (!directionFromDom && domNode) {
                  directionFromDom = window.getComputedStyle(domNode, null).direction;
                  domNode = domNode.parentElement;
                }
                this.options.rtl = directionFromDom && directionFromDom.toLowerCase() == "rtl";
              } else {
                this.options.rtl = options.rtl;
              }
              this.options.rollingMode = options && options.rollingMode;
              this.options.onInitialDrawComplete = options && options.onInitialDrawComplete;
              this.components = [];
              this.body = {
                dom: this.dom,
                domProps: this.props,
                emitter: {
                  on: this.on.bind(this),
                  off: this.off.bind(this),
                  emit: this.emit.bind(this)
                },
                hiddenDates: [],
                util: {
                  getScale: function getScale() {
                    return me.timeAxis.step.scale;
                  },
                  getStep: function getStep() {
                    return me.timeAxis.step.step;
                  },
                  toScreen: me._toScreen.bind(me),
                  toGlobalScreen: me._toGlobalScreen.bind(me),
                  // this refers to the root.width
                  toTime: me._toTime.bind(me),
                  toGlobalTime: me._toGlobalTime.bind(me)
                }
              };
              this.range = new Range(this.body, this.options);
              this.components.push(this.range);
              this.body.range = this.range;
              this.timeAxis = new TimeAxis(this.body, this.options);
              this.timeAxis2 = null;
              this.components.push(this.timeAxis);
              this.currentTime = new CurrentTime(this.body, this.options);
              this.components.push(this.currentTime);
              this.itemSet = new ItemSet(this.body, this.options);
              this.components.push(this.itemSet);
              this.itemsData = null;
              this.groupsData = null;
              this.dom.root.onclick = function(event) {
                me.emit("click", me.getEventProperties(event));
              };
              this.dom.root.ondblclick = function(event) {
                me.emit("doubleClick", me.getEventProperties(event));
              };
              this.dom.root.oncontextmenu = function(event) {
                me.emit("contextmenu", me.getEventProperties(event));
              };
              this.dom.root.onmouseover = function(event) {
                me.emit("mouseOver", me.getEventProperties(event));
              };
              if (window.PointerEvent) {
                this.dom.root.onpointerdown = function(event) {
                  me.emit("mouseDown", me.getEventProperties(event));
                };
                this.dom.root.onpointermove = function(event) {
                  me.emit("mouseMove", me.getEventProperties(event));
                };
                this.dom.root.onpointerup = function(event) {
                  me.emit("mouseUp", me.getEventProperties(event));
                };
              } else {
                this.dom.root.onmousemove = function(event) {
                  me.emit("mouseMove", me.getEventProperties(event));
                };
                this.dom.root.onmousedown = function(event) {
                  me.emit("mouseDown", me.getEventProperties(event));
                };
                this.dom.root.onmouseup = function(event) {
                  me.emit("mouseUp", me.getEventProperties(event));
                };
              }
              this.initialFitDone = false;
              this.on("changed", function() {
                if (this.itemsData == null || this.options.rollingMode) return;
                if (!me.initialFitDone) {
                  me.initialFitDone = true;
                  if (me.options.start != void 0 || me.options.end != void 0) {
                    if (me.options.start == void 0 || me.options.end == void 0) {
                      var range = me.getItemRange();
                    }
                    var start = me.options.start != void 0 ? me.options.start : range.min;
                    var end = me.options.end != void 0 ? me.options.end : range.max;
                    me.setWindow(start, end, { animation: false });
                  } else {
                    me.fit({ animation: false });
                  }
                }
                if (!me.initialDrawDone && me.initialRangeChangeDone) {
                  me.initialDrawDone = true;
                  me.dom.root.style.visibility = "visible";
                  if (me.options.onInitialDrawComplete) {
                    setTimeout(function() {
                      return me.options.onInitialDrawComplete();
                    }, 0);
                  }
                }
              });
              if (options) {
                this.setOptions(options);
              }
              if (groups) {
                this.setGroups(groups);
              }
              if (items) {
                this.setItems(items);
              }
              this._redraw();
            }
            Timeline.prototype = new Core();
            Timeline.prototype._createConfigurator = function() {
              return new Configurator(this, this.dom.container, configureOptions);
            };
            Timeline.prototype.redraw = function() {
              this.itemSet && this.itemSet.markDirty({ refreshItems: true });
              this._redraw();
            };
            Timeline.prototype.setOptions = function(options) {
              var errorFound = Validator.validate(options, allOptions);
              if (errorFound === true) {
                console.log("%cErrors have been found in the supplied options object.", printStyle);
              }
              Core.prototype.setOptions.call(this, options);
              if ("type" in options) {
                if (options.type !== this.options.type) {
                  this.options.type = options.type;
                  var itemsData = this.itemsData;
                  if (itemsData) {
                    var selection = this.getSelection();
                    this.setItems(null);
                    this.setItems(itemsData);
                    this.setSelection(selection);
                  }
                }
              }
            };
            Timeline.prototype.setItems = function(items) {
              var newDataSet;
              if (!items) {
                newDataSet = null;
              } else if (items instanceof DataSet || items instanceof DataView) {
                newDataSet = items;
              } else {
                newDataSet = new DataSet(items, {
                  type: {
                    start: "Date",
                    end: "Date"
                  }
                });
              }
              this.itemsData = newDataSet;
              this.itemSet && this.itemSet.setItems(newDataSet);
            };
            Timeline.prototype.setGroups = function(groups) {
              var newDataSet;
              if (!groups) {
                newDataSet = null;
              } else {
                var filter = function filter2(group) {
                  return group.visible !== false;
                };
                if (groups instanceof DataSet || groups instanceof DataView) {
                  newDataSet = new DataView(groups, { filter });
                } else {
                  newDataSet = new DataSet(groups.filter(filter));
                }
              }
              this.groupsData = newDataSet;
              this.itemSet.setGroups(newDataSet);
            };
            Timeline.prototype.setData = function(data) {
              if (data && data.groups) {
                this.setGroups(data.groups);
              }
              if (data && data.items) {
                this.setItems(data.items);
              }
            };
            Timeline.prototype.setSelection = function(ids, options) {
              this.itemSet && this.itemSet.setSelection(ids);
              if (options && options.focus) {
                this.focus(ids, options);
              }
            };
            Timeline.prototype.getSelection = function() {
              return this.itemSet && this.itemSet.getSelection() || [];
            };
            Timeline.prototype.focus = function(id, options) {
              if (!this.itemsData || id == void 0) return;
              var ids = Array.isArray(id) ? id : [id];
              var itemsData = this.itemsData.getDataSet().get(ids, {
                type: {
                  start: "Date",
                  end: "Date"
                }
              });
              var start = null;
              var end = null;
              itemsData.forEach(function(itemData) {
                var s = itemData.start.valueOf();
                var e = "end" in itemData ? itemData.end.valueOf() : itemData.start.valueOf();
                if (start === null || s < start) {
                  start = s;
                }
                if (end === null || e > end) {
                  end = e;
                }
              });
              if (start !== null && end !== null) {
                var me = this;
                var item = this.itemSet.items[ids[0]];
                var startPos = this._getScrollTop() * -1;
                var initialVerticalScroll = null;
                var verticalAnimationFrame = function verticalAnimationFrame2(ease, willDraw, done) {
                  var verticalScroll = getItemVerticalScroll(me, item);
                  if (!initialVerticalScroll) {
                    initialVerticalScroll = verticalScroll;
                  }
                  if (initialVerticalScroll.itemTop == verticalScroll.itemTop && !initialVerticalScroll.shouldScroll) {
                    return;
                  } else if (initialVerticalScroll.itemTop != verticalScroll.itemTop && verticalScroll.shouldScroll) {
                    initialVerticalScroll = verticalScroll;
                    startPos = me._getScrollTop() * -1;
                  }
                  var from = startPos;
                  var to = initialVerticalScroll.scrollOffset;
                  var scrollTop = done ? to : from + (to - from) * ease;
                  me._setScrollTop(-scrollTop);
                  if (!willDraw) {
                    me._redraw();
                  }
                };
                var setFinalVerticalPosition = function setFinalVerticalPosition2() {
                  var finalVerticalScroll = getItemVerticalScroll(me, item);
                  if (finalVerticalScroll.shouldScroll && finalVerticalScroll.itemTop != initialVerticalScroll.itemTop) {
                    me._setScrollTop(-finalVerticalScroll.scrollOffset);
                    me._redraw();
                  }
                };
                var finalVerticalCallback = function finalVerticalCallback2() {
                  setFinalVerticalPosition();
                  setTimeout(setFinalVerticalPosition, 100);
                };
                var middle = (start + end) / 2;
                var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);
                var animation = options && options.animation !== void 0 ? options.animation : true;
                if (!animation) {
                  initialVerticalScroll = { shouldScroll: false, scrollOffset: -1, itemTop: -1 };
                }
                this.range.setRange(middle - interval / 2, middle + interval / 2, { animation }, finalVerticalCallback, verticalAnimationFrame);
              }
            };
            Timeline.prototype.fit = function(options, callback) {
              var animation = options && options.animation !== void 0 ? options.animation : true;
              var range;
              var dataset = this.itemsData && this.itemsData.getDataSet();
              if (dataset.length === 1 && dataset.get()[0].end === void 0) {
                range = this.getDataRange();
                this.moveTo(range.min.valueOf(), { animation }, callback);
              } else {
                range = this.getItemRange();
                this.range.setRange(range.min, range.max, { animation }, callback);
              }
            };
            function getStart(item) {
              return util.convert(item.data.start, "Date").valueOf();
            }
            function getEnd(item) {
              var end = item.data.end != void 0 ? item.data.end : item.data.start;
              return util.convert(end, "Date").valueOf();
            }
            function getItemVerticalScroll(timeline, item) {
              var leftHeight = timeline.props.leftContainer.height;
              var contentHeight = timeline.props.left.height;
              var group = item.parent;
              var offset = group.top;
              var shouldScroll = true;
              var orientation = timeline.timeAxis.options.orientation.axis;
              var itemTop = function itemTop2() {
                if (orientation == "bottom") {
                  return group.height - item.top - item.height;
                } else {
                  return item.top;
                }
              };
              var currentScrollHeight = timeline._getScrollTop() * -1;
              var targetOffset = offset + itemTop();
              var height = item.height;
              if (targetOffset < currentScrollHeight) {
                if (offset + leftHeight <= offset + itemTop() + height) {
                  offset += itemTop() - timeline.itemSet.options.margin.item.vertical;
                }
              } else if (targetOffset + height > currentScrollHeight + leftHeight) {
                offset += itemTop() + height - leftHeight + timeline.itemSet.options.margin.item.vertical;
              } else {
                shouldScroll = false;
              }
              offset = Math.min(offset, contentHeight - leftHeight);
              return { shouldScroll, scrollOffset: offset, itemTop: targetOffset };
            }
            Timeline.prototype.getItemRange = function() {
              var range = this.getDataRange();
              var min = range.min !== null ? range.min.valueOf() : null;
              var max = range.max !== null ? range.max.valueOf() : null;
              var minItem = null;
              var maxItem = null;
              if (min != null && max != null) {
                var interval = max - min;
                if (interval <= 0) {
                  interval = 10;
                }
                var factor = interval / this.props.center.width;
                var redrawQueue = {};
                var redrawQueueLength = 0;
                util.forEach(this.itemSet.items, function(item, key) {
                  if (item.groupShowing) {
                    var returnQueue = true;
                    redrawQueue[key] = item.redraw(returnQueue);
                    redrawQueueLength = redrawQueue[key].length;
                  }
                });
                var needRedraw = redrawQueueLength > 0;
                if (needRedraw) {
                  for (var i = 0; i < redrawQueueLength; i++) {
                    util.forEach(redrawQueue, function(fns) {
                      fns[i]();
                    });
                  }
                }
                util.forEach(this.itemSet.items, (function(item) {
                  var start = getStart(item);
                  var end = getEnd(item);
                  var startSide;
                  var endSide;
                  if (this.options.rtl) {
                    startSide = start - (item.getWidthRight() + 10) * factor;
                    endSide = end + (item.getWidthLeft() + 10) * factor;
                  } else {
                    startSide = start - (item.getWidthLeft() + 10) * factor;
                    endSide = end + (item.getWidthRight() + 10) * factor;
                  }
                  if (startSide < min) {
                    min = startSide;
                    minItem = item;
                  }
                  if (endSide > max) {
                    max = endSide;
                    maxItem = item;
                  }
                }).bind(this));
                if (minItem && maxItem) {
                  var lhs = minItem.getWidthLeft() + 10;
                  var rhs = maxItem.getWidthRight() + 10;
                  var delta = this.props.center.width - lhs - rhs;
                  if (delta > 0) {
                    if (this.options.rtl) {
                      min = getStart(minItem) - rhs * interval / delta;
                      max = getEnd(maxItem) + lhs * interval / delta;
                    } else {
                      min = getStart(minItem) - lhs * interval / delta;
                      max = getEnd(maxItem) + rhs * interval / delta;
                    }
                  }
                }
              }
              return {
                min: min != null ? new Date(min) : null,
                max: max != null ? new Date(max) : null
              };
            };
            Timeline.prototype.getDataRange = function() {
              var min = null;
              var max = null;
              var dataset = this.itemsData && this.itemsData.getDataSet();
              if (dataset) {
                dataset.forEach(function(item) {
                  var start = util.convert(item.start, "Date").valueOf();
                  var end = util.convert(item.end != void 0 ? item.end : item.start, "Date").valueOf();
                  if (min === null || start < min) {
                    min = start;
                  }
                  if (max === null || end > max) {
                    max = end;
                  }
                });
              }
              return {
                min: min != null ? new Date(min) : null,
                max: max != null ? new Date(max) : null
              };
            };
            Timeline.prototype.getEventProperties = function(event) {
              var clientX = event.center ? event.center.x : event.clientX;
              var clientY = event.center ? event.center.y : event.clientY;
              var x;
              if (this.options.rtl) {
                x = util.getAbsoluteRight(this.dom.centerContainer) - clientX;
              } else {
                x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
              }
              var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);
              var item = this.itemSet.itemFromTarget(event);
              var group = this.itemSet.groupFromTarget(event);
              var customTime = CustomTime.customTimeFromTarget(event);
              var snap = this.itemSet.options.snap || null;
              var scale = this.body.util.getScale();
              var step = this.body.util.getStep();
              var time = this._toTime(x);
              var snappedTime = snap ? snap(time, scale, step) : time;
              var element = util.getTarget(event);
              var what = null;
              if (item != null) {
                what = "item";
              } else if (customTime != null) {
                what = "custom-time";
              } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
                what = "axis";
              } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
                what = "axis";
              } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
                what = "group-label";
              } else if (util.hasParent(element, this.currentTime.bar)) {
                what = "current-time";
              } else if (util.hasParent(element, this.dom.center)) {
                what = "background";
              }
              return {
                event,
                item: item ? item.id : null,
                group: group ? group.groupId : null,
                what,
                pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
                pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
                x,
                y,
                time,
                snappedTime
              };
            };
            Timeline.prototype.toggleRollingMode = function() {
              if (this.range.rolling) {
                this.range.stopRolling();
              } else {
                if (this.options.rollingMode == void 0) {
                  this.setOptions(this.options);
                }
                this.range.startRolling();
              }
            };
            module2.exports = Timeline;
          },
          /* 179 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(10);
            var hammerUtil = __webpack_require__(37);
            var util = __webpack_require__(2);
            var ColorPicker = function() {
              function ColorPicker2() {
                var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                (0, _classCallCheck3["default"])(this, ColorPicker2);
                this.pixelRatio = pixelRatio;
                this.generated = false;
                this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
                this.r = 289 * 0.49;
                this.color = { r: 255, g: 255, b: 255, a: 1 };
                this.hueCircle = void 0;
                this.initialColor = { r: 255, g: 255, b: 255, a: 1 };
                this.previousColor = void 0;
                this.applied = false;
                this.updateCallback = function() {
                };
                this.closeCallback = function() {
                };
                this._create();
              }
              (0, _createClass3["default"])(ColorPicker2, [{
                key: "insertTo",
                value: function insertTo(container) {
                  if (this.hammer !== void 0) {
                    this.hammer.destroy();
                    this.hammer = void 0;
                  }
                  this.container = container;
                  this.container.appendChild(this.frame);
                  this._bindHammer();
                  this._setSize();
                }
                /**
                 * the callback is executed on apply and save. Bind it to the application
                 * @param {function} callback
                 */
              }, {
                key: "setUpdateCallback",
                value: function setUpdateCallback(callback) {
                  if (typeof callback === "function") {
                    this.updateCallback = callback;
                  } else {
                    throw new Error("Function attempted to set as colorPicker update callback is not a function.");
                  }
                }
                /**
                 * the callback is executed on apply and save. Bind it to the application
                 * @param {function} callback
                 */
              }, {
                key: "setCloseCallback",
                value: function setCloseCallback(callback) {
                  if (typeof callback === "function") {
                    this.closeCallback = callback;
                  } else {
                    throw new Error("Function attempted to set as colorPicker closing callback is not a function.");
                  }
                }
                /**
                 *
                 * @param {string} color
                 * @returns {String}
                 * @private
                 */
              }, {
                key: "_isColorString",
                value: function _isColorString(color) {
                  var htmlColors = { black: "#000000", navy: "#000080", darkblue: "#00008B", mediumblue: "#0000CD", blue: "#0000FF", darkgreen: "#006400", green: "#008000", teal: "#008080", darkcyan: "#008B8B", deepskyblue: "#00BFFF", darkturquoise: "#00CED1", mediumspringgreen: "#00FA9A", lime: "#00FF00", springgreen: "#00FF7F", aqua: "#00FFFF", cyan: "#00FFFF", midnightblue: "#191970", dodgerblue: "#1E90FF", lightseagreen: "#20B2AA", forestgreen: "#228B22", seagreen: "#2E8B57", darkslategray: "#2F4F4F", limegreen: "#32CD32", mediumseagreen: "#3CB371", turquoise: "#40E0D0", royalblue: "#4169E1", steelblue: "#4682B4", darkslateblue: "#483D8B", mediumturquoise: "#48D1CC", indigo: "#4B0082", darkolivegreen: "#556B2F", cadetblue: "#5F9EA0", cornflowerblue: "#6495ED", mediumaquamarine: "#66CDAA", dimgray: "#696969", slateblue: "#6A5ACD", olivedrab: "#6B8E23", slategray: "#708090", lightslategray: "#778899", mediumslateblue: "#7B68EE", lawngreen: "#7CFC00", chartreuse: "#7FFF00", aquamarine: "#7FFFD4", maroon: "#800000", purple: "#800080", olive: "#808000", gray: "#808080", skyblue: "#87CEEB", lightskyblue: "#87CEFA", blueviolet: "#8A2BE2", darkred: "#8B0000", darkmagenta: "#8B008B", saddlebrown: "#8B4513", darkseagreen: "#8FBC8F", lightgreen: "#90EE90", mediumpurple: "#9370D8", darkviolet: "#9400D3", palegreen: "#98FB98", darkorchid: "#9932CC", yellowgreen: "#9ACD32", sienna: "#A0522D", brown: "#A52A2A", darkgray: "#A9A9A9", lightblue: "#ADD8E6", greenyellow: "#ADFF2F", paleturquoise: "#AFEEEE", lightsteelblue: "#B0C4DE", powderblue: "#B0E0E6", firebrick: "#B22222", darkgoldenrod: "#B8860B", mediumorchid: "#BA55D3", rosybrown: "#BC8F8F", darkkhaki: "#BDB76B", silver: "#C0C0C0", mediumvioletred: "#C71585", indianred: "#CD5C5C", peru: "#CD853F", chocolate: "#D2691E", tan: "#D2B48C", lightgrey: "#D3D3D3", palevioletred: "#D87093", thistle: "#D8BFD8", orchid: "#DA70D6", goldenrod: "#DAA520", crimson: "#DC143C", gainsboro: "#DCDCDC", plum: "#DDA0DD", burlywood: "#DEB887", lightcyan: "#E0FFFF", lavender: "#E6E6FA", darksalmon: "#E9967A", violet: "#EE82EE", palegoldenrod: "#EEE8AA", lightcoral: "#F08080", khaki: "#F0E68C", aliceblue: "#F0F8FF", honeydew: "#F0FFF0", azure: "#F0FFFF", sandybrown: "#F4A460", wheat: "#F5DEB3", beige: "#F5F5DC", whitesmoke: "#F5F5F5", mintcream: "#F5FFFA", ghostwhite: "#F8F8FF", salmon: "#FA8072", antiquewhite: "#FAEBD7", linen: "#FAF0E6", lightgoldenrodyellow: "#FAFAD2", oldlace: "#FDF5E6", red: "#FF0000", fuchsia: "#FF00FF", magenta: "#FF00FF", deeppink: "#FF1493", orangered: "#FF4500", tomato: "#FF6347", hotpink: "#FF69B4", coral: "#FF7F50", darkorange: "#FF8C00", lightsalmon: "#FFA07A", orange: "#FFA500", lightpink: "#FFB6C1", pink: "#FFC0CB", gold: "#FFD700", peachpuff: "#FFDAB9", navajowhite: "#FFDEAD", moccasin: "#FFE4B5", bisque: "#FFE4C4", mistyrose: "#FFE4E1", blanchedalmond: "#FFEBCD", papayawhip: "#FFEFD5", lavenderblush: "#FFF0F5", seashell: "#FFF5EE", cornsilk: "#FFF8DC", lemonchiffon: "#FFFACD", floralwhite: "#FFFAF0", snow: "#FFFAFA", yellow: "#FFFF00", lightyellow: "#FFFFE0", ivory: "#FFFFF0", white: "#FFFFFF" };
                  if (typeof color === "string") {
                    return htmlColors[color];
                  }
                }
                /**
                 * Set the color of the colorPicker
                 * Supported formats:
                 * 'red'                   --> HTML color string
                 * '#ffffff'               --> hex string
                 * 'rbg(255,255,255)'      --> rgb string
                 * 'rgba(255,255,255,1.0)' --> rgba string
                 * {r:255,g:255,b:255}     --> rgb object
                 * {r:255,g:255,b:255,a:1.0} --> rgba object
                 * @param {string|Object} color
                 * @param {boolean} [setInitial=true]
                 */
              }, {
                key: "setColor",
                value: function setColor(color) {
                  var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (color === "none") {
                    return;
                  }
                  var rgba = void 0;
                  var htmlColor = this._isColorString(color);
                  if (htmlColor !== void 0) {
                    color = htmlColor;
                  }
                  if (util.isString(color) === true) {
                    if (util.isValidRGB(color) === true) {
                      var rgbaArray = color.substr(4).substr(0, color.length - 5).split(",");
                      rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1 };
                    } else if (util.isValidRGBA(color) === true) {
                      var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(",");
                      rgba = { r: _rgbaArray[0], g: _rgbaArray[1], b: _rgbaArray[2], a: _rgbaArray[3] };
                    } else if (util.isValidHex(color) === true) {
                      var rgbObj = util.hexToRGB(color);
                      rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1 };
                    }
                  } else {
                    if (color instanceof Object) {
                      if (color.r !== void 0 && color.g !== void 0 && color.b !== void 0) {
                        var alpha = color.a !== void 0 ? color.a : "1.0";
                        rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
                      }
                    }
                  }
                  if (rgba === void 0) {
                    throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + (0, _stringify2["default"])(color));
                  } else {
                    this._setColor(rgba, setInitial);
                  }
                }
                /**
                 * this shows the color picker.
                 * The hue circle is constructed once and stored.
                 */
              }, {
                key: "show",
                value: function show() {
                  if (this.closeCallback !== void 0) {
                    this.closeCallback();
                    this.closeCallback = void 0;
                  }
                  this.applied = false;
                  this.frame.style.display = "block";
                  this._generateHueCircle();
                }
                // ------------------------------------------ PRIVATE ----------------------------- //
                /**
                 * Hide the picker. Is called by the cancel button.
                 * Optional boolean to store the previous color for easy access later on.
                 * @param {boolean} [storePrevious=true]
                 * @private
                 */
              }, {
                key: "_hide",
                value: function _hide() {
                  var _this = this;
                  var storePrevious = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  if (storePrevious === true) {
                    this.previousColor = util.extend({}, this.color);
                  }
                  if (this.applied === true) {
                    this.updateCallback(this.initialColor);
                  }
                  this.frame.style.display = "none";
                  setTimeout(function() {
                    if (_this.closeCallback !== void 0) {
                      _this.closeCallback();
                      _this.closeCallback = void 0;
                    }
                  }, 0);
                }
                /**
                 * bound to the save button. Saves and hides.
                 * @private
                 */
              }, {
                key: "_save",
                value: function _save() {
                  this.updateCallback(this.color);
                  this.applied = false;
                  this._hide();
                }
                /**
                 * Bound to apply button. Saves but does not close. Is undone by the cancel button.
                 * @private
                 */
              }, {
                key: "_apply",
                value: function _apply() {
                  this.applied = true;
                  this.updateCallback(this.color);
                  this._updatePicker(this.color);
                }
                /**
                 * load the color from the previous session.
                 * @private
                 */
              }, {
                key: "_loadLast",
                value: function _loadLast() {
                  if (this.previousColor !== void 0) {
                    this.setColor(this.previousColor, false);
                  } else {
                    alert("There is no last color to load...");
                  }
                }
                /**
                 * set the color, place the picker
                 * @param {Object} rgba
                 * @param {boolean} [setInitial=true]
                 * @private
                 */
              }, {
                key: "_setColor",
                value: function _setColor(rgba) {
                  var setInitial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (setInitial === true) {
                    this.initialColor = util.extend({}, rgba);
                  }
                  this.color = rgba;
                  var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
                  var angleConvert = 2 * Math.PI;
                  var radius = this.r * hsv.s;
                  var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
                  var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);
                  this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + "px";
                  this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + "px";
                  this._updatePicker(rgba);
                }
                /**
                 * bound to opacity control
                 * @param {number} value
                 * @private
                 */
              }, {
                key: "_setOpacity",
                value: function _setOpacity(value) {
                  this.color.a = value / 100;
                  this._updatePicker(this.color);
                }
                /**
                 * bound to brightness control
                 * @param {number} value
                 * @private
                 */
              }, {
                key: "_setBrightness",
                value: function _setBrightness(value) {
                  var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
                  hsv.v = value / 100;
                  var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
                  rgba["a"] = this.color.a;
                  this.color = rgba;
                  this._updatePicker();
                }
                /**
                 * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
                 * @param {Object} rgba
                 * @private
                 */
              }, {
                key: "_updatePicker",
                value: function _updatePicker() {
                  var rgba = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.color;
                  var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
                  var ctx = this.colorPickerCanvas.getContext("2d");
                  if (this.pixelRation === void 0) {
                    this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                  }
                  ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                  var w = this.colorPickerCanvas.clientWidth;
                  var h = this.colorPickerCanvas.clientHeight;
                  ctx.clearRect(0, 0, w, h);
                  ctx.putImageData(this.hueCircle, 0, 0);
                  ctx.fillStyle = "rgba(0,0,0," + (1 - hsv.v) + ")";
                  ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
                  ctx.fill();
                  this.brightnessRange.value = 100 * hsv.v;
                  this.opacityRange.value = 100 * rgba.a;
                  this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
                  this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
                }
                /**
                 * used by create to set the size of the canvas.
                 * @private
                 */
              }, {
                key: "_setSize",
                value: function _setSize() {
                  this.colorPickerCanvas.style.width = "100%";
                  this.colorPickerCanvas.style.height = "100%";
                  this.colorPickerCanvas.width = 289 * this.pixelRatio;
                  this.colorPickerCanvas.height = 289 * this.pixelRatio;
                }
                /**
                 * create all dom elements
                 * TODO: cleanup, lots of similar dom elements
                 * @private
                 */
              }, {
                key: "_create",
                value: function _create() {
                  this.frame = document.createElement("div");
                  this.frame.className = "vis-color-picker";
                  this.colorPickerDiv = document.createElement("div");
                  this.colorPickerSelector = document.createElement("div");
                  this.colorPickerSelector.className = "vis-selector";
                  this.colorPickerDiv.appendChild(this.colorPickerSelector);
                  this.colorPickerCanvas = document.createElement("canvas");
                  this.colorPickerDiv.appendChild(this.colorPickerCanvas);
                  if (!this.colorPickerCanvas.getContext) {
                    var noCanvas = document.createElement("DIV");
                    noCanvas.style.color = "red";
                    noCanvas.style.fontWeight = "bold";
                    noCanvas.style.padding = "10px";
                    noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
                    this.colorPickerCanvas.appendChild(noCanvas);
                  } else {
                    var ctx = this.colorPickerCanvas.getContext("2d");
                    this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                    this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                  }
                  this.colorPickerDiv.className = "vis-color";
                  this.opacityDiv = document.createElement("div");
                  this.opacityDiv.className = "vis-opacity";
                  this.brightnessDiv = document.createElement("div");
                  this.brightnessDiv.className = "vis-brightness";
                  this.arrowDiv = document.createElement("div");
                  this.arrowDiv.className = "vis-arrow";
                  this.opacityRange = document.createElement("input");
                  try {
                    this.opacityRange.type = "range";
                    this.opacityRange.min = "0";
                    this.opacityRange.max = "100";
                  } catch (err) {
                  }
                  this.opacityRange.value = "100";
                  this.opacityRange.className = "vis-range";
                  this.brightnessRange = document.createElement("input");
                  try {
                    this.brightnessRange.type = "range";
                    this.brightnessRange.min = "0";
                    this.brightnessRange.max = "100";
                  } catch (err) {
                  }
                  this.brightnessRange.value = "100";
                  this.brightnessRange.className = "vis-range";
                  this.opacityDiv.appendChild(this.opacityRange);
                  this.brightnessDiv.appendChild(this.brightnessRange);
                  var me = this;
                  this.opacityRange.onchange = function() {
                    me._setOpacity(this.value);
                  };
                  this.opacityRange.oninput = function() {
                    me._setOpacity(this.value);
                  };
                  this.brightnessRange.onchange = function() {
                    me._setBrightness(this.value);
                  };
                  this.brightnessRange.oninput = function() {
                    me._setBrightness(this.value);
                  };
                  this.brightnessLabel = document.createElement("div");
                  this.brightnessLabel.className = "vis-label vis-brightness";
                  this.brightnessLabel.innerHTML = "brightness:";
                  this.opacityLabel = document.createElement("div");
                  this.opacityLabel.className = "vis-label vis-opacity";
                  this.opacityLabel.innerHTML = "opacity:";
                  this.newColorDiv = document.createElement("div");
                  this.newColorDiv.className = "vis-new-color";
                  this.newColorDiv.innerHTML = "new";
                  this.initialColorDiv = document.createElement("div");
                  this.initialColorDiv.className = "vis-initial-color";
                  this.initialColorDiv.innerHTML = "initial";
                  this.cancelButton = document.createElement("div");
                  this.cancelButton.className = "vis-button vis-cancel";
                  this.cancelButton.innerHTML = "cancel";
                  this.cancelButton.onclick = this._hide.bind(this, false);
                  this.applyButton = document.createElement("div");
                  this.applyButton.className = "vis-button vis-apply";
                  this.applyButton.innerHTML = "apply";
                  this.applyButton.onclick = this._apply.bind(this);
                  this.saveButton = document.createElement("div");
                  this.saveButton.className = "vis-button vis-save";
                  this.saveButton.innerHTML = "save";
                  this.saveButton.onclick = this._save.bind(this);
                  this.loadButton = document.createElement("div");
                  this.loadButton.className = "vis-button vis-load";
                  this.loadButton.innerHTML = "load last";
                  this.loadButton.onclick = this._loadLast.bind(this);
                  this.frame.appendChild(this.colorPickerDiv);
                  this.frame.appendChild(this.arrowDiv);
                  this.frame.appendChild(this.brightnessLabel);
                  this.frame.appendChild(this.brightnessDiv);
                  this.frame.appendChild(this.opacityLabel);
                  this.frame.appendChild(this.opacityDiv);
                  this.frame.appendChild(this.newColorDiv);
                  this.frame.appendChild(this.initialColorDiv);
                  this.frame.appendChild(this.cancelButton);
                  this.frame.appendChild(this.applyButton);
                  this.frame.appendChild(this.saveButton);
                  this.frame.appendChild(this.loadButton);
                }
                /**
                 * bind hammer to the color picker
                 * @private
                 */
              }, {
                key: "_bindHammer",
                value: function _bindHammer() {
                  var _this2 = this;
                  this.drag = {};
                  this.pinch = {};
                  this.hammer = new Hammer(this.colorPickerCanvas);
                  this.hammer.get("pinch").set({ enable: true });
                  hammerUtil.onTouch(this.hammer, function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("tap", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panstart", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panmove", function(event) {
                    _this2._moveSelector(event);
                  });
                  this.hammer.on("panend", function(event) {
                    _this2._moveSelector(event);
                  });
                }
                /**
                 * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
                 * @private
                 */
              }, {
                key: "_generateHueCircle",
                value: function _generateHueCircle() {
                  if (this.generated === false) {
                    var ctx = this.colorPickerCanvas.getContext("2d");
                    if (this.pixelRation === void 0) {
                      this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
                    }
                    ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                    var w = this.colorPickerCanvas.clientWidth;
                    var h = this.colorPickerCanvas.clientHeight;
                    ctx.clearRect(0, 0, w, h);
                    var x = void 0, y = void 0, hue = void 0, sat = void 0;
                    this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
                    this.r = 0.49 * w;
                    var angleConvert = 2 * Math.PI / 360;
                    var hfac = 1 / 360;
                    var sfac = 1 / this.r;
                    var rgb = void 0;
                    for (hue = 0; hue < 360; hue++) {
                      for (sat = 0; sat < this.r; sat++) {
                        x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
                        y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
                        rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
                        ctx.fillStyle = "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
                      }
                    }
                    ctx.strokeStyle = "rgba(0,0,0,1)";
                    ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
                    ctx.stroke();
                    this.hueCircle = ctx.getImageData(0, 0, w, h);
                  }
                  this.generated = true;
                }
                /**
                 * move the selector. This is called by hammer functions.
                 *
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_moveSelector",
                value: function _moveSelector(event) {
                  var rect = this.colorPickerDiv.getBoundingClientRect();
                  var left = event.center.x - rect.left;
                  var top = event.center.y - rect.top;
                  var centerY = 0.5 * this.colorPickerDiv.clientHeight;
                  var centerX = 0.5 * this.colorPickerDiv.clientWidth;
                  var x = left - centerX;
                  var y = top - centerY;
                  var angle = Math.atan2(x, y);
                  var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);
                  var newTop = Math.cos(angle) * radius + centerY;
                  var newLeft = Math.sin(angle) * radius + centerX;
                  this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + "px";
                  this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + "px";
                  var h = angle / (2 * Math.PI);
                  h = h < 0 ? h + 1 : h;
                  var s = radius / this.r;
                  var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
                  hsv.h = h;
                  hsv.s = s;
                  var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
                  rgba["a"] = this.color.a;
                  this.color = rgba;
                  this.initialColorDiv.style.backgroundColor = "rgba(" + this.initialColor.r + "," + this.initialColor.g + "," + this.initialColor.b + "," + this.initialColor.a + ")";
                  this.newColorDiv.style.backgroundColor = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + this.color.a + ")";
                }
              }]);
              return ColorPicker2;
            }();
            exports2["default"] = ColorPicker;
          },
          /* 180 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var moment = __webpack_require__(9);
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Range = __webpack_require__(64);
            var Core = __webpack_require__(65);
            var TimeAxis = __webpack_require__(45);
            var CurrentTime = __webpack_require__(67);
            var CustomTime = __webpack_require__(46);
            var LineGraph = __webpack_require__(106);
            var printStyle = __webpack_require__(15).printStyle;
            var allOptions = __webpack_require__(113).allOptions;
            var configureOptions = __webpack_require__(113).configureOptions;
            var Configurator = __webpack_require__(71)["default"];
            var Validator = __webpack_require__(15)["default"];
            function Graph2d(container, items, groups, options) {
              if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
                var forthArgument = options;
                options = groups;
                groups = forthArgument;
              }
              if (options && options.throttleRedraw) {
                console.warn('Graph2d option "throttleRedraw" is DEPRICATED and no longer supported. It will be removed in the next MAJOR release.');
              }
              var me = this;
              this.defaultOptions = {
                start: null,
                end: null,
                autoResize: true,
                orientation: {
                  axis: "bottom",
                  // axis orientation: 'bottom', 'top', or 'both'
                  item: "bottom"
                  // not relevant for Graph2d
                },
                moment,
                width: null,
                height: null,
                maxHeight: null,
                minHeight: null
              };
              this.options = util.deepExtend({}, this.defaultOptions);
              this._create(container);
              this.components = [];
              this.body = {
                dom: this.dom,
                domProps: this.props,
                emitter: {
                  on: this.on.bind(this),
                  off: this.off.bind(this),
                  emit: this.emit.bind(this)
                },
                hiddenDates: [],
                util: {
                  toScreen: me._toScreen.bind(me),
                  toGlobalScreen: me._toGlobalScreen.bind(me),
                  // this refers to the root.width
                  toTime: me._toTime.bind(me),
                  toGlobalTime: me._toGlobalTime.bind(me)
                }
              };
              this.range = new Range(this.body);
              this.components.push(this.range);
              this.body.range = this.range;
              this.timeAxis = new TimeAxis(this.body);
              this.components.push(this.timeAxis);
              this.currentTime = new CurrentTime(this.body);
              this.components.push(this.currentTime);
              this.linegraph = new LineGraph(this.body);
              this.components.push(this.linegraph);
              this.itemsData = null;
              this.groupsData = null;
              this.on("tap", function(event) {
                me.emit("click", me.getEventProperties(event));
              });
              this.on("doubletap", function(event) {
                me.emit("doubleClick", me.getEventProperties(event));
              });
              this.dom.root.oncontextmenu = function(event) {
                me.emit("contextmenu", me.getEventProperties(event));
              };
              if (options) {
                this.setOptions(options);
              }
              if (groups) {
                this.setGroups(groups);
              }
              if (items) {
                this.setItems(items);
              }
              this._redraw();
            }
            Graph2d.prototype = new Core();
            Graph2d.prototype.setOptions = function(options) {
              var errorFound = Validator.validate(options, allOptions);
              if (errorFound === true) {
                console.log("%cErrors have been found in the supplied options object.", printStyle);
              }
              Core.prototype.setOptions.call(this, options);
            };
            Graph2d.prototype.setItems = function(items) {
              var initialLoad = this.itemsData == null;
              var newDataSet;
              if (!items) {
                newDataSet = null;
              } else if (items instanceof DataSet || items instanceof DataView) {
                newDataSet = items;
              } else {
                newDataSet = new DataSet(items, {
                  type: {
                    start: "Date",
                    end: "Date"
                  }
                });
              }
              this.itemsData = newDataSet;
              this.linegraph && this.linegraph.setItems(newDataSet);
              if (initialLoad) {
                if (this.options.start != void 0 || this.options.end != void 0) {
                  var start = this.options.start != void 0 ? this.options.start : null;
                  var end = this.options.end != void 0 ? this.options.end : null;
                  this.setWindow(start, end, { animation: false });
                } else {
                  this.fit({ animation: false });
                }
              }
            };
            Graph2d.prototype.setGroups = function(groups) {
              var newDataSet;
              if (!groups) {
                newDataSet = null;
              } else if (groups instanceof DataSet || groups instanceof DataView) {
                newDataSet = groups;
              } else {
                newDataSet = new DataSet(groups);
              }
              this.groupsData = newDataSet;
              this.linegraph.setGroups(newDataSet);
            };
            Graph2d.prototype.getLegend = function(groupId, width, height) {
              if (width === void 0) {
                width = 15;
              }
              if (height === void 0) {
                height = 15;
              }
              if (this.linegraph.groups[groupId] !== void 0) {
                return this.linegraph.groups[groupId].getLegend(width, height);
              } else {
                return "cannot find group:'" + groupId + "'";
              }
            };
            Graph2d.prototype.isGroupVisible = function(groupId) {
              if (this.linegraph.groups[groupId] !== void 0) {
                return this.linegraph.groups[groupId].visible && (this.linegraph.options.groups.visibility[groupId] === void 0 || this.linegraph.options.groups.visibility[groupId] == true);
              } else {
                return false;
              }
            };
            Graph2d.prototype.getDataRange = function() {
              var min = null;
              var max = null;
              for (var groupId in this.linegraph.groups) {
                if (this.linegraph.groups.hasOwnProperty(groupId)) {
                  if (this.linegraph.groups[groupId].visible == true) {
                    for (var i = 0; i < this.linegraph.groups[groupId].itemsData.length; i++) {
                      var item = this.linegraph.groups[groupId].itemsData[i];
                      var value = util.convert(item.x, "Date").valueOf();
                      min = min == null ? value : min > value ? value : min;
                      max = max == null ? value : max < value ? value : max;
                    }
                  }
                }
              }
              return {
                min: min != null ? new Date(min) : null,
                max: max != null ? new Date(max) : null
              };
            };
            Graph2d.prototype.getEventProperties = function(event) {
              var clientX = event.center ? event.center.x : event.clientX;
              var clientY = event.center ? event.center.y : event.clientY;
              var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
              var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);
              var time = this._toTime(x);
              var customTime = CustomTime.customTimeFromTarget(event);
              var element = util.getTarget(event);
              var what = null;
              if (util.hasParent(element, this.timeAxis.dom.foreground)) {
                what = "axis";
              } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
                what = "axis";
              } else if (util.hasParent(element, this.linegraph.yAxisLeft.dom.frame)) {
                what = "data-axis";
              } else if (util.hasParent(element, this.linegraph.yAxisRight.dom.frame)) {
                what = "data-axis";
              } else if (util.hasParent(element, this.linegraph.legendLeft.dom.frame)) {
                what = "legend";
              } else if (util.hasParent(element, this.linegraph.legendRight.dom.frame)) {
                what = "legend";
              } else if (customTime != null) {
                what = "custom-time";
              } else if (util.hasParent(element, this.currentTime.bar)) {
                what = "current-time";
              } else if (util.hasParent(element, this.dom.center)) {
                what = "background";
              }
              var value = [];
              var yAxisLeft = this.linegraph.yAxisLeft;
              var yAxisRight = this.linegraph.yAxisRight;
              if (!yAxisLeft.hidden && this.itemsData.length > 0) {
                value.push(yAxisLeft.screenToValue(y));
              }
              if (!yAxisRight.hidden && this.itemsData.length > 0) {
                value.push(yAxisRight.screenToValue(y));
              }
              return {
                event,
                what,
                pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
                pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
                x,
                y,
                time,
                value
              };
            };
            Graph2d.prototype._createConfigurator = function() {
              return new Configurator(this, this.dom.container, configureOptions);
            };
            module2.exports = Graph2d;
          },
          /* 181 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.util = __webpack_require__(2);
            exports2.DOMutil = __webpack_require__(14);
            exports2.DataSet = __webpack_require__(11);
            exports2.DataView = __webpack_require__(12);
            exports2.Queue = __webpack_require__(43);
            exports2.Network = __webpack_require__(182);
            exports2.network = {
              Images: __webpack_require__(116),
              dotparser: __webpack_require__(114),
              gephiParser: __webpack_require__(115),
              allOptions: __webpack_require__(122)
            };
            exports2.network.convertDot = function(input) {
              return exports2.network.dotparser.DOTToGraph(input);
            };
            exports2.network.convertGephi = function(input, options) {
              return exports2.network.gephiParser.parseGephi(input, options);
            };
            exports2.moment = __webpack_require__(9);
            exports2.Hammer = __webpack_require__(10);
            exports2.keycharm = __webpack_require__(35);
          },
          /* 182 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            __webpack_require__(183);
            var Emitter = __webpack_require__(44);
            var util = __webpack_require__(2);
            var dotparser = __webpack_require__(114);
            var gephiParser = __webpack_require__(115);
            var Activator = __webpack_require__(97);
            var locales = __webpack_require__(184);
            var Images = __webpack_require__(116)["default"];
            var Groups = __webpack_require__(186)["default"];
            var NodesHandler = __webpack_require__(187)["default"];
            var EdgesHandler = __webpack_require__(214)["default"];
            var PhysicsEngine = __webpack_require__(220)["default"];
            var ClusterEngine = __webpack_require__(227)["default"];
            var CanvasRenderer = __webpack_require__(229)["default"];
            var Canvas = __webpack_require__(230)["default"];
            var View = __webpack_require__(231)["default"];
            var InteractionHandler = __webpack_require__(232)["default"];
            var SelectionHandler = __webpack_require__(234)["default"];
            var LayoutEngine = __webpack_require__(235)["default"];
            var ManipulationSystem = __webpack_require__(237)["default"];
            var Configurator = __webpack_require__(71)["default"];
            var Validator = __webpack_require__(15)["default"];
            var _require = __webpack_require__(15), printStyle = _require.printStyle;
            var _require2 = __webpack_require__(122), allOptions = _require2.allOptions, configureOptions = _require2.configureOptions;
            var KamadaKawai = __webpack_require__(238)["default"];
            function Network(container, data, options) {
              var _this = this;
              if (!(this instanceof Network)) {
                throw new SyntaxError("Constructor must be called with the new operator");
              }
              this.options = {};
              this.defaultOptions = {
                locale: "en",
                locales,
                clickToUse: false
              };
              util.extend(this.options, this.defaultOptions);
              this.body = {
                container,
                // See comment above for following fields
                nodes: {},
                nodeIndices: [],
                edges: {},
                edgeIndices: [],
                emitter: {
                  on: this.on.bind(this),
                  off: this.off.bind(this),
                  emit: this.emit.bind(this),
                  once: this.once.bind(this)
                },
                eventListeners: {
                  onTap: function onTap() {
                  },
                  onTouch: function onTouch() {
                  },
                  onDoubleTap: function onDoubleTap() {
                  },
                  onHold: function onHold() {
                  },
                  onDragStart: function onDragStart() {
                  },
                  onDrag: function onDrag() {
                  },
                  onDragEnd: function onDragEnd() {
                  },
                  onMouseWheel: function onMouseWheel() {
                  },
                  onPinch: function onPinch() {
                  },
                  onMouseMove: function onMouseMove() {
                  },
                  onRelease: function onRelease() {
                  },
                  onContext: function onContext() {
                  }
                },
                data: {
                  nodes: null,
                  // A DataSet or DataView
                  edges: null
                  // A DataSet or DataView
                },
                functions: {
                  createNode: function createNode() {
                  },
                  createEdge: function createEdge() {
                  },
                  getPointer: function getPointer() {
                  }
                },
                modules: {},
                view: {
                  scale: 1,
                  translation: { x: 0, y: 0 }
                }
              };
              this.bindEventListeners();
              this.images = new Images(function() {
                return _this.body.emitter.emit("_requestRedraw");
              });
              this.groups = new Groups();
              this.canvas = new Canvas(this.body);
              this.selectionHandler = new SelectionHandler(this.body, this.canvas);
              this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler);
              this.view = new View(this.body, this.canvas);
              this.renderer = new CanvasRenderer(this.body, this.canvas);
              this.physics = new PhysicsEngine(this.body);
              this.layoutEngine = new LayoutEngine(this.body);
              this.clustering = new ClusterEngine(this.body);
              this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler);
              this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine);
              this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups);
              this.body.modules["kamadaKawai"] = new KamadaKawai(this.body, 150, 0.05);
              this.body.modules["clustering"] = this.clustering;
              this.canvas._create();
              this.setOptions(options);
              this.setData(data);
            }
            Emitter(Network.prototype);
            Network.prototype.setOptions = function(options) {
              var _this2 = this;
              if (options !== void 0) {
                var errorFound = Validator.validate(options, allOptions);
                if (errorFound === true) {
                  console.log("%cErrors have been found in the supplied options object.", printStyle);
                }
                var fields = ["locale", "locales", "clickToUse"];
                util.selectiveDeepExtend(fields, this.options, options);
                options = this.layoutEngine.setOptions(options.layout, options);
                this.canvas.setOptions(options);
                this.groups.setOptions(options.groups);
                this.nodesHandler.setOptions(options.nodes);
                this.edgesHandler.setOptions(options.edges);
                this.physics.setOptions(options.physics);
                this.manipulation.setOptions(options.manipulation, options, this.options);
                this.interactionHandler.setOptions(options.interaction);
                this.renderer.setOptions(options.interaction);
                this.selectionHandler.setOptions(options.interaction);
                if (options.groups !== void 0) {
                  this.body.emitter.emit("refreshNodes");
                }
                if ("configure" in options) {
                  if (!this.configurator) {
                    this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio);
                  }
                  this.configurator.setOptions(options.configure);
                }
                if (this.configurator && this.configurator.options.enabled === true) {
                  var networkOptions = { nodes: {}, edges: {}, layout: {}, interaction: {}, manipulation: {}, physics: {}, global: {} };
                  util.deepExtend(networkOptions.nodes, this.nodesHandler.options);
                  util.deepExtend(networkOptions.edges, this.edgesHandler.options);
                  util.deepExtend(networkOptions.layout, this.layoutEngine.options);
                  util.deepExtend(networkOptions.interaction, this.selectionHandler.options);
                  util.deepExtend(networkOptions.interaction, this.renderer.options);
                  util.deepExtend(networkOptions.interaction, this.interactionHandler.options);
                  util.deepExtend(networkOptions.manipulation, this.manipulation.options);
                  util.deepExtend(networkOptions.physics, this.physics.options);
                  util.deepExtend(networkOptions.global, this.canvas.options);
                  util.deepExtend(networkOptions.global, this.options);
                  this.configurator.setModuleOptions(networkOptions);
                }
                if (options.clickToUse !== void 0) {
                  if (options.clickToUse === true) {
                    if (this.activator === void 0) {
                      this.activator = new Activator(this.canvas.frame);
                      this.activator.on("change", function() {
                        _this2.body.emitter.emit("activate");
                      });
                    }
                  } else {
                    if (this.activator !== void 0) {
                      this.activator.destroy();
                      delete this.activator;
                    }
                    this.body.emitter.emit("activate");
                  }
                } else {
                  this.body.emitter.emit("activate");
                }
                this.canvas.setSize();
                this.body.emitter.emit("startSimulation");
              }
            };
            Network.prototype._updateVisibleIndices = function() {
              var nodes = this.body.nodes;
              var edges = this.body.edges;
              this.body.nodeIndices = [];
              this.body.edgeIndices = [];
              for (var nodeId in nodes) {
                if (nodes.hasOwnProperty(nodeId)) {
                  if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {
                    this.body.nodeIndices.push(nodes[nodeId].id);
                  }
                }
              }
              for (var edgeId in edges) {
                if (edges.hasOwnProperty(edgeId)) {
                  var edge = edges[edgeId];
                  var fromNode = nodes[edge.fromId];
                  var toNode = nodes[edge.toId];
                  var edgeNodesPresent = fromNode !== void 0 && toNode !== void 0;
                  var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false && toNode.options.hidden === false;
                  if (isVisible) {
                    this.body.edgeIndices.push(edge.id);
                  }
                }
              }
            };
            Network.prototype.bindEventListeners = function() {
              var _this3 = this;
              this.body.emitter.on("_dataChanged", function() {
                _this3.edgesHandler._updateState();
                _this3.body.emitter.emit("_dataUpdated");
              });
              this.body.emitter.on("_dataUpdated", function() {
                _this3.clustering._updateState();
                _this3._updateVisibleIndices();
                _this3._updateValueRange(_this3.body.nodes);
                _this3._updateValueRange(_this3.body.edges);
                _this3.body.emitter.emit("startSimulation");
                _this3.body.emitter.emit("_requestRedraw");
              });
            };
            Network.prototype.setData = function(data) {
              this.body.emitter.emit("resetPhysics");
              this.body.emitter.emit("_resetData");
              this.selectionHandler.unselectAll();
              if (data && data.dot && (data.nodes || data.edges)) {
                throw new SyntaxError('Data must contain either parameter "dot" or  parameter pair "nodes" and "edges", but not both.');
              }
              this.setOptions(data && data.options);
              if (data && data.dot) {
                console.log("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");
                var dotData = dotparser.DOTToGraph(data.dot);
                this.setData(dotData);
                return;
              } else if (data && data.gephi) {
                console.log("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");
                var gephiData = gephiParser.parseGephi(data.gephi);
                this.setData(gephiData);
                return;
              } else {
                this.nodesHandler.setData(data && data.nodes, true);
                this.edgesHandler.setData(data && data.edges, true);
              }
              this.body.emitter.emit("_dataChanged");
              this.body.emitter.emit("_dataLoaded");
              this.body.emitter.emit("initPhysics");
            };
            Network.prototype.destroy = function() {
              this.body.emitter.emit("destroy");
              this.body.emitter.off();
              this.off();
              delete this.groups;
              delete this.canvas;
              delete this.selectionHandler;
              delete this.interactionHandler;
              delete this.view;
              delete this.renderer;
              delete this.physics;
              delete this.layoutEngine;
              delete this.clustering;
              delete this.manipulation;
              delete this.nodesHandler;
              delete this.edgesHandler;
              delete this.configurator;
              delete this.images;
              for (var nodeId in this.body.nodes) {
                if (!this.body.nodes.hasOwnProperty(nodeId)) continue;
                delete this.body.nodes[nodeId];
              }
              for (var edgeId in this.body.edges) {
                if (!this.body.edges.hasOwnProperty(edgeId)) continue;
                delete this.body.edges[edgeId];
              }
              util.recursiveDOMDelete(this.body.container);
            };
            Network.prototype._updateValueRange = function(obj) {
              var id;
              var valueMin = void 0;
              var valueMax = void 0;
              var valueTotal = 0;
              for (id in obj) {
                if (obj.hasOwnProperty(id)) {
                  var value = obj[id].getValue();
                  if (value !== void 0) {
                    valueMin = valueMin === void 0 ? value : Math.min(value, valueMin);
                    valueMax = valueMax === void 0 ? value : Math.max(value, valueMax);
                    valueTotal += value;
                  }
                }
              }
              if (valueMin !== void 0 && valueMax !== void 0) {
                for (id in obj) {
                  if (obj.hasOwnProperty(id)) {
                    obj[id].setValueRange(valueMin, valueMax, valueTotal);
                  }
                }
              }
            };
            Network.prototype.isActive = function() {
              return !this.activator || this.activator.active;
            };
            Network.prototype.setSize = function() {
              return this.canvas.setSize.apply(this.canvas, arguments);
            };
            Network.prototype.canvasToDOM = function() {
              return this.canvas.canvasToDOM.apply(this.canvas, arguments);
            };
            Network.prototype.DOMtoCanvas = function() {
              return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);
            };
            Network.prototype.findNode = function() {
              return this.clustering.findNode.apply(this.clustering, arguments);
            };
            Network.prototype.isCluster = function() {
              return this.clustering.isCluster.apply(this.clustering, arguments);
            };
            Network.prototype.openCluster = function() {
              return this.clustering.openCluster.apply(this.clustering, arguments);
            };
            Network.prototype.cluster = function() {
              return this.clustering.cluster.apply(this.clustering, arguments);
            };
            Network.prototype.getNodesInCluster = function() {
              return this.clustering.getNodesInCluster.apply(this.clustering, arguments);
            };
            Network.prototype.clusterByConnection = function() {
              return this.clustering.clusterByConnection.apply(this.clustering, arguments);
            };
            Network.prototype.clusterByHubsize = function() {
              return this.clustering.clusterByHubsize.apply(this.clustering, arguments);
            };
            Network.prototype.clusterOutliers = function() {
              return this.clustering.clusterOutliers.apply(this.clustering, arguments);
            };
            Network.prototype.getSeed = function() {
              return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);
            };
            Network.prototype.enableEditMode = function() {
              return this.manipulation.enableEditMode.apply(this.manipulation, arguments);
            };
            Network.prototype.disableEditMode = function() {
              return this.manipulation.disableEditMode.apply(this.manipulation, arguments);
            };
            Network.prototype.addNodeMode = function() {
              return this.manipulation.addNodeMode.apply(this.manipulation, arguments);
            };
            Network.prototype.editNode = function() {
              return this.manipulation.editNode.apply(this.manipulation, arguments);
            };
            Network.prototype.editNodeMode = function() {
              console.log("Deprecated: Please use editNode instead of editNodeMode.");
              return this.manipulation.editNode.apply(this.manipulation, arguments);
            };
            Network.prototype.addEdgeMode = function() {
              return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);
            };
            Network.prototype.editEdgeMode = function() {
              return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);
            };
            Network.prototype.deleteSelected = function() {
              return this.manipulation.deleteSelected.apply(this.manipulation, arguments);
            };
            Network.prototype.getPositions = function() {
              return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);
            };
            Network.prototype.storePositions = function() {
              return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);
            };
            Network.prototype.moveNode = function() {
              return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);
            };
            Network.prototype.getBoundingBox = function() {
              return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);
            };
            Network.prototype.getConnectedNodes = function(objectId) {
              if (this.body.nodes[objectId] !== void 0) {
                return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);
              } else {
                return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);
              }
            };
            Network.prototype.getConnectedEdges = function() {
              return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);
            };
            Network.prototype.startSimulation = function() {
              return this.physics.startSimulation.apply(this.physics, arguments);
            };
            Network.prototype.stopSimulation = function() {
              return this.physics.stopSimulation.apply(this.physics, arguments);
            };
            Network.prototype.stabilize = function() {
              return this.physics.stabilize.apply(this.physics, arguments);
            };
            Network.prototype.getSelection = function() {
              return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);
            };
            Network.prototype.setSelection = function() {
              return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);
            };
            Network.prototype.getSelectedNodes = function() {
              return this.selectionHandler.getSelectedNodes.apply(this.selectionHandler, arguments);
            };
            Network.prototype.getSelectedEdges = function() {
              return this.selectionHandler.getSelectedEdges.apply(this.selectionHandler, arguments);
            };
            Network.prototype.getNodeAt = function() {
              var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);
              if (node !== void 0 && node.id !== void 0) {
                return node.id;
              }
              return node;
            };
            Network.prototype.getEdgeAt = function() {
              var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);
              if (edge !== void 0 && edge.id !== void 0) {
                return edge.id;
              }
              return edge;
            };
            Network.prototype.selectNodes = function() {
              return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);
            };
            Network.prototype.selectEdges = function() {
              return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);
            };
            Network.prototype.unselectAll = function() {
              this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);
              this.redraw();
            };
            Network.prototype.redraw = function() {
              return this.renderer.redraw.apply(this.renderer, arguments);
            };
            Network.prototype.getScale = function() {
              return this.view.getScale.apply(this.view, arguments);
            };
            Network.prototype.getViewPosition = function() {
              return this.view.getViewPosition.apply(this.view, arguments);
            };
            Network.prototype.fit = function() {
              return this.view.fit.apply(this.view, arguments);
            };
            Network.prototype.moveTo = function() {
              return this.view.moveTo.apply(this.view, arguments);
            };
            Network.prototype.focus = function() {
              return this.view.focus.apply(this.view, arguments);
            };
            Network.prototype.releaseNode = function() {
              return this.view.releaseNode.apply(this.view, arguments);
            };
            Network.prototype.getOptionsFromConfigurator = function() {
              var options = {};
              if (this.configurator) {
                options = this.configurator.getOptions.apply(this.configurator);
              }
              return options;
            };
            module2.exports = Network;
          },
          /* 183 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            if (typeof CanvasRenderingContext2D !== "undefined") {
              CanvasRenderingContext2D.prototype.circle = function(x, y, r) {
                this.beginPath();
                this.arc(x, y, r, 0, 2 * Math.PI, false);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.square = function(x, y, r) {
                this.beginPath();
                this.rect(x - r, y - r, r * 2, r * 2);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.triangle = function(x, y, r) {
                this.beginPath();
                r *= 1.15;
                y += 0.275 * r;
                var s = r * 2;
                var s2 = s / 2;
                var ir = Math.sqrt(3) / 6 * s;
                var h = Math.sqrt(s * s - s2 * s2);
                this.moveTo(x, y - (h - ir));
                this.lineTo(x + s2, y + ir);
                this.lineTo(x - s2, y + ir);
                this.lineTo(x, y - (h - ir));
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.triangleDown = function(x, y, r) {
                this.beginPath();
                r *= 1.15;
                y -= 0.275 * r;
                var s = r * 2;
                var s2 = s / 2;
                var ir = Math.sqrt(3) / 6 * s;
                var h = Math.sqrt(s * s - s2 * s2);
                this.moveTo(x, y + (h - ir));
                this.lineTo(x + s2, y - ir);
                this.lineTo(x - s2, y - ir);
                this.lineTo(x, y + (h - ir));
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.star = function(x, y, r) {
                this.beginPath();
                r *= 0.82;
                y += 0.1 * r;
                for (var n = 0; n < 10; n++) {
                  var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;
                  this.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));
                }
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.diamond = function(x, y, r) {
                this.beginPath();
                this.lineTo(x, y + r);
                this.lineTo(x + r, y);
                this.lineTo(x, y - r);
                this.lineTo(x - r, y);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                var r2d = Math.PI / 180;
                if (w - 2 * r < 0) {
                  r = w / 2;
                }
                if (h - 2 * r < 0) {
                  r = h / 2;
                }
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);
                this.lineTo(x + w, y + h - r);
                this.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);
                this.lineTo(x + r, y + h);
                this.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);
                this.lineTo(x, y + r);
                this.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.ellipse_vis = function(x, y, w, h) {
                var kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
                this.beginPath();
                this.moveTo(x, ym);
                this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                this.closePath();
              };
              CanvasRenderingContext2D.prototype.database = function(x, y, w, h) {
                var f = 1 / 3;
                var wEllipse = w;
                var hEllipse = h * f;
                var kappa = 0.5522848, ox = wEllipse / 2 * kappa, oy = hEllipse / 2 * kappa, xe = x + wEllipse, ye = y + hEllipse, xm = x + wEllipse / 2, ym = y + hEllipse / 2, ymb = y + (h - hEllipse / 2), yeb = y + h;
                this.beginPath();
                this.moveTo(xe, ym);
                this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                this.lineTo(xe, ymb);
                this.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);
                this.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);
                this.lineTo(x, ym);
              };
              CanvasRenderingContext2D.prototype.dashedLine = function(x, y, x2, y2, pattern) {
                this.beginPath();
                this.moveTo(x, y);
                var patternLength = pattern.length;
                var dx = x2 - x;
                var dy = y2 - y;
                var slope = dy / dx;
                var distRemaining = Math.sqrt(dx * dx + dy * dy);
                var patternIndex = 0;
                var draw = true;
                var xStep = 0;
                var dashLength = pattern[0];
                while (distRemaining >= 0.1) {
                  dashLength = pattern[patternIndex++ % patternLength];
                  if (dashLength > distRemaining) {
                    dashLength = distRemaining;
                  }
                  xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));
                  xStep = dx < 0 ? -xStep : xStep;
                  x += xStep;
                  y += slope * xStep;
                  if (draw === true) {
                    this.lineTo(x, y);
                  } else {
                    this.moveTo(x, y);
                  }
                  distRemaining -= dashLength;
                  draw = !draw;
                }
              };
              CanvasRenderingContext2D.prototype.hexagon = function(x, y, r) {
                this.beginPath();
                var sides = 6;
                var a = Math.PI * 2 / sides;
                this.moveTo(x + r, y);
                for (var i = 1; i < sides; i++) {
                  this.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
                }
                this.closePath();
              };
            }
          },
          /* 184 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2["en"] = {
              edit: "Edit",
              del: "Delete selected",
              back: "Back",
              addNode: "Add Node",
              addEdge: "Add Edge",
              editNode: "Edit Node",
              editEdge: "Edit Edge",
              addDescription: "Click in an empty space to place a new node.",
              edgeDescription: "Click on a node and drag the edge to another node to connect them.",
              editEdgeDescription: "Click on the control points and drag them to a node to connect to it.",
              createEdgeError: "Cannot link edges to a cluster.",
              deleteClusterError: "Clusters cannot be deleted.",
              editClusterError: "Clusters cannot be edited."
            };
            exports2["en_EN"] = exports2["en"];
            exports2["en_US"] = exports2["en"];
            exports2["de"] = {
              edit: "Editieren",
              del: "Lsche Auswahl",
              back: "Zurck",
              addNode: "Knoten hinzufgen",
              addEdge: "Kante hinzufgen",
              editNode: "Knoten editieren",
              editEdge: "Kante editieren",
              addDescription: "Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",
              edgeDescription: "Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",
              editEdgeDescription: "Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",
              createEdgeError: "Es ist nicht mglich, Kanten mit Clustern zu verbinden.",
              deleteClusterError: "Cluster knnen nicht gelscht werden.",
              editClusterError: "Cluster knnen nicht editiert werden."
            };
            exports2["de_DE"] = exports2["de"];
            exports2["es"] = {
              edit: "Editar",
              del: "Eliminar seleccin",
              back: "tras",
              addNode: "Aadir nodo",
              addEdge: "Aadir arista",
              editNode: "Editar nodo",
              editEdge: "Editar arista",
              addDescription: "Haga clic en un lugar vaco para colocar un nuevo nodo.",
              edgeDescription: "Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",
              editEdgeDescription: "Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",
              createEdgeError: "No se puede conectar una arista a un grupo.",
              deleteClusterError: "No es posible eliminar grupos.",
              editClusterError: "No es posible editar grupos."
            };
            exports2["es_ES"] = exports2["es"];
            exports2["it"] = {
              edit: "Modifica",
              del: "Cancella la selezione",
              back: "Indietro",
              addNode: "Aggiungi un nodo",
              addEdge: "Aggiungi un vertice",
              editNode: "Modifica il nodo",
              editEdge: "Modifica il vertice",
              addDescription: "Clicca per aggiungere un nuovo nodo",
              edgeDescription: "Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",
              editEdgeDescription: "Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",
              createEdgeError: "Non si possono collegare vertici ad un cluster",
              deleteClusterError: "I cluster non possono essere cancellati",
              editClusterError: "I clusters non possono essere modificati."
            };
            exports2["it_IT"] = exports2["it"];
            exports2["nl"] = {
              edit: "Wijzigen",
              del: "Selectie verwijderen",
              back: "Terug",
              addNode: "Node toevoegen",
              addEdge: "Link toevoegen",
              editNode: "Node wijzigen",
              editEdge: "Link wijzigen",
              addDescription: "Klik op een leeg gebied om een nieuwe node te maken.",
              edgeDescription: "Klik op een node en sleep de link naar een andere node om ze te verbinden.",
              editEdgeDescription: "Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",
              createEdgeError: "Kan geen link maken naar een cluster.",
              deleteClusterError: "Clusters kunnen niet worden verwijderd.",
              editClusterError: "Clusters kunnen niet worden aangepast."
            };
            exports2["nl_NL"] = exports2["nl"];
            exports2["nl_BE"] = exports2["nl"];
            exports2["pt-br"] = {
              edit: "Editar",
              del: "Remover selecionado",
              back: "Voltar",
              addNode: "Adicionar n",
              addEdge: "Adicionar aresta",
              editNode: "Editar n",
              editEdge: "Editar aresta",
              addDescription: "Clique em um espao em branco para adicionar um novo n",
              edgeDescription: "Clique em um n e arraste a aresta at outro n para conect-los",
              editEdgeDescription: "Clique nos pontos de controle e os arraste para um n para conect-los",
              createEdgeError: "No foi possvel linkar arestas a um cluster.",
              deleteClusterError: "Clusters no puderam ser removidos.",
              editClusterError: "Clusters no puderam ser editados."
            };
            exports2["pt-BR"] = exports2["pt-br"];
            exports2["pt_BR"] = exports2["pt-br"];
            exports2["pt_br"] = exports2["pt-br"];
            exports2["ru"] = {
              edit: "",
              del: " ",
              back: "",
              addNode: " ",
              addEdge: " ",
              editNode: " ",
              editEdge: " ",
              addDescription: "   ,    .",
              edgeDescription: "        ,   .",
              editEdgeDescription: "        ,    .",
              createEdgeError: "    .",
              deleteClusterError: "    ",
              editClusterError: "   ."
            };
            exports2["ru_RU"] = exports2["ru"];
            exports2["cn"] = {
              edit: "",
              del: "",
              back: "",
              addNode: "",
              addEdge: "",
              editNode: "",
              editEdge: "",
              addDescription: "",
              edgeDescription: "",
              editEdgeDescription: "",
              createEdgeError: "",
              deleteClusterError: "",
              editClusterError: ""
            };
            exports2["zh_CN"] = exports2["cn"];
          },
          /* 185 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CachedImage = function() {
              function CachedImage2() {
                (0, _classCallCheck3["default"])(this, CachedImage2);
                this.NUM_ITERATIONS = 4;
                this.image = new Image();
                this.canvas = document.createElement("canvas");
              }
              (0, _createClass3["default"])(CachedImage2, [{
                key: "init",
                value: function init() {
                  if (this.initialized()) return;
                  this.src = this.image.src;
                  var w = this.image.width;
                  var h = this.image.height;
                  this.width = w;
                  this.height = h;
                  var h2 = Math.floor(h / 2);
                  var h4 = Math.floor(h / 4);
                  var h8 = Math.floor(h / 8);
                  var h16 = Math.floor(h / 16);
                  var w2 = Math.floor(w / 2);
                  var w4 = Math.floor(w / 4);
                  var w8 = Math.floor(w / 8);
                  var w16 = Math.floor(w / 16);
                  this.canvas.width = 3 * w4;
                  this.canvas.height = h2;
                  this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];
                  this._fillMipMap();
                }
                /**
                 * @return {Boolean} true if init() has been called, false otherwise.
                 */
              }, {
                key: "initialized",
                value: function initialized() {
                  return this.coordinates !== void 0;
                }
                /**
                 * Redraw main image in various sizes to the context.
                 *
                 * The rationale behind this is to reduce artefacts due to interpolation
                 * at differing zoom levels.
                 *
                 * Source: http://stackoverflow.com/q/18761404/1223531
                 *
                 * This methods takes the resizing out of the drawing loop, in order to
                 * reduce performance overhead.
                 *
                 * TODO: The code assumes that a 2D context can always be gotten. This is
                 *       not necessarily true! OTOH, if not true then usage of this class
                 *       is senseless.
                 *
                 * @private
                 */
              }, {
                key: "_fillMipMap",
                value: function _fillMipMap() {
                  var ctx = this.canvas.getContext("2d");
                  var to = this.coordinates[0];
                  ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);
                  for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {
                    var from = this.coordinates[iterations - 1];
                    var _to = this.coordinates[iterations];
                    ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);
                  }
                }
                /**
                 * Draw the image, using the mipmap if necessary.
                 *
                 * MipMap is only used if param factor > 2; otherwise, original bitmap
                 * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
                 *
                 * Credits to 'Alex de Mulder' for original implementation.
                 *
                 * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
                 * @param {Float} factor scale factor at which to draw
                 * @param {number} left
                 * @param {number} top
                 * @param {number} width
                 * @param {number} height
                 */
              }, {
                key: "drawImageAtPosition",
                value: function drawImageAtPosition(ctx, factor, left, top, width, height) {
                  if (!this.initialized()) return;
                  if (factor > 2) {
                    factor *= 0.5;
                    var iterations = 0;
                    while (factor > 2 && iterations < this.NUM_ITERATIONS) {
                      factor *= 0.5;
                      iterations += 1;
                    }
                    if (iterations >= this.NUM_ITERATIONS) {
                      iterations = this.NUM_ITERATIONS - 1;
                    }
                    var from = this.coordinates[iterations];
                    ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);
                  } else {
                    ctx.drawImage(this.image, left, top, width, height);
                  }
                }
              }]);
              return CachedImage2;
            }();
            exports2["default"] = CachedImage;
          },
          /* 186 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Groups = function() {
              function Groups2() {
                (0, _classCallCheck3["default"])(this, Groups2);
                this.clear();
                this.defaultIndex = 0;
                this.groupsArray = [];
                this.groupIndex = 0;
                this.defaultGroups = [
                  { border: "#2B7CE9", background: "#97C2FC", highlight: { border: "#2B7CE9", background: "#D2E5FF" }, hover: { border: "#2B7CE9", background: "#D2E5FF" } },
                  // 0: blue
                  { border: "#FFA500", background: "#FFFF00", highlight: { border: "#FFA500", background: "#FFFFA3" }, hover: { border: "#FFA500", background: "#FFFFA3" } },
                  // 1: yellow
                  { border: "#FA0A10", background: "#FB7E81", highlight: { border: "#FA0A10", background: "#FFAFB1" }, hover: { border: "#FA0A10", background: "#FFAFB1" } },
                  // 2: red
                  { border: "#41A906", background: "#7BE141", highlight: { border: "#41A906", background: "#A1EC76" }, hover: { border: "#41A906", background: "#A1EC76" } },
                  // 3: green
                  { border: "#E129F0", background: "#EB7DF4", highlight: { border: "#E129F0", background: "#F0B3F5" }, hover: { border: "#E129F0", background: "#F0B3F5" } },
                  // 4: magenta
                  { border: "#7C29F0", background: "#AD85E4", highlight: { border: "#7C29F0", background: "#D3BDF0" }, hover: { border: "#7C29F0", background: "#D3BDF0" } },
                  // 5: purple
                  { border: "#C37F00", background: "#FFA807", highlight: { border: "#C37F00", background: "#FFCA66" }, hover: { border: "#C37F00", background: "#FFCA66" } },
                  // 6: orange
                  { border: "#4220FB", background: "#6E6EFD", highlight: { border: "#4220FB", background: "#9B9BFD" }, hover: { border: "#4220FB", background: "#9B9BFD" } },
                  // 7: darkblue
                  { border: "#FD5A77", background: "#FFC0CB", highlight: { border: "#FD5A77", background: "#FFD1D9" }, hover: { border: "#FD5A77", background: "#FFD1D9" } },
                  // 8: pink
                  { border: "#4AD63A", background: "#C2FABC", highlight: { border: "#4AD63A", background: "#E6FFE3" }, hover: { border: "#4AD63A", background: "#E6FFE3" } },
                  // 9: mint
                  { border: "#990000", background: "#EE0000", highlight: { border: "#BB0000", background: "#FF3333" }, hover: { border: "#BB0000", background: "#FF3333" } },
                  // 10:bright red
                  { border: "#FF6000", background: "#FF6000", highlight: { border: "#FF6000", background: "#FF6000" }, hover: { border: "#FF6000", background: "#FF6000" } },
                  // 12: real orange
                  { border: "#97C2FC", background: "#2B7CE9", highlight: { border: "#D2E5FF", background: "#2B7CE9" }, hover: { border: "#D2E5FF", background: "#2B7CE9" } },
                  // 13: blue
                  { border: "#399605", background: "#255C03", highlight: { border: "#399605", background: "#255C03" }, hover: { border: "#399605", background: "#255C03" } },
                  // 14: green
                  { border: "#B70054", background: "#FF007E", highlight: { border: "#B70054", background: "#FF007E" }, hover: { border: "#B70054", background: "#FF007E" } },
                  // 15: magenta
                  { border: "#AD85E4", background: "#7C29F0", highlight: { border: "#D3BDF0", background: "#7C29F0" }, hover: { border: "#D3BDF0", background: "#7C29F0" } },
                  // 16: purple
                  { border: "#4557FA", background: "#000EA1", highlight: { border: "#6E6EFD", background: "#000EA1" }, hover: { border: "#6E6EFD", background: "#000EA1" } },
                  // 17: darkblue
                  { border: "#FFC0CB", background: "#FD5A77", highlight: { border: "#FFD1D9", background: "#FD5A77" }, hover: { border: "#FFD1D9", background: "#FD5A77" } },
                  // 18: pink
                  { border: "#C2FABC", background: "#74D66A", highlight: { border: "#E6FFE3", background: "#74D66A" }, hover: { border: "#E6FFE3", background: "#74D66A" } },
                  // 19: mint
                  {
                    border: "#EE0000",
                    background: "#990000",
                    highlight: { border: "#FF3333", background: "#BB0000" },
                    hover: { border: "#FF3333", background: "#BB0000" }
                    // 20:bright red
                  }
                ];
                this.options = {};
                this.defaultOptions = {
                  useDefaultGroups: true
                };
                util.extend(this.options, this.defaultOptions);
              }
              (0, _createClass3["default"])(Groups2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  var optionFields = ["useDefaultGroups"];
                  if (options !== void 0) {
                    for (var groupName in options) {
                      if (options.hasOwnProperty(groupName)) {
                        if (optionFields.indexOf(groupName) === -1) {
                          var group = options[groupName];
                          this.add(groupName, group);
                        }
                      }
                    }
                  }
                }
                /**
                 * Clear all groups
                 */
              }, {
                key: "clear",
                value: function clear() {
                  this.groups = {};
                  this.groupsArray = [];
                }
                /**
                 * Get group options of a groupname.
                 * If groupname is not found, a new group may be created.
                 *
                 * @param {*}       groupname     Can be a number, string, Date, etc.
                 * @param {boolean} [shouldCreate=true] If true, create a new group
                 * @return {Object} The found or created group
                 */
              }, {
                key: "get",
                value: function get(groupname) {
                  var shouldCreate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var group = this.groups[groupname];
                  if (group === void 0 && shouldCreate) {
                    if (this.options.useDefaultGroups === false && this.groupsArray.length > 0) {
                      var index = this.groupIndex % this.groupsArray.length;
                      this.groupIndex++;
                      group = {};
                      group.color = this.groups[this.groupsArray[index]];
                      this.groups[groupname] = group;
                    } else {
                      var _index = this.defaultIndex % this.defaultGroups.length;
                      this.defaultIndex++;
                      group = {};
                      group.color = this.defaultGroups[_index];
                      this.groups[groupname] = group;
                    }
                  }
                  return group;
                }
                /**
                 * Add a custom group style
                 * @param {string} groupName
                 * @param {Object} style       An object containing borderColor,
                 *                             backgroundColor, etc.
                 * @return {Object} group      The created group object
                 */
              }, {
                key: "add",
                value: function add(groupName, style) {
                  this.groups[groupName] = style;
                  this.groupsArray.push(groupName);
                  return style;
                }
              }]);
              return Groups2;
            }();
            exports2["default"] = Groups;
          },
          /* 187 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Node = __webpack_require__(47)["default"];
            var NodesHandler = function() {
              function NodesHandler2(body, images, groups, layoutEngine) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, NodesHandler2);
                this.body = body;
                this.images = images;
                this.groups = groups;
                this.layoutEngine = layoutEngine;
                this.body.functions.createNode = this.create.bind(this);
                this.nodesListeners = {
                  add: function add(event, params) {
                    _this.add(params.items);
                  },
                  update: function update(event, params) {
                    _this.update(params.items, params.data, params.oldData);
                  },
                  remove: function remove(event, params) {
                    _this.remove(params.items);
                  }
                };
                this.defaultOptions = {
                  borderWidth: 1,
                  borderWidthSelected: 2,
                  brokenImage: void 0,
                  color: {
                    border: "#2B7CE9",
                    background: "#97C2FC",
                    highlight: {
                      border: "#2B7CE9",
                      background: "#D2E5FF"
                    },
                    hover: {
                      border: "#2B7CE9",
                      background: "#D2E5FF"
                    }
                  },
                  fixed: {
                    x: false,
                    y: false
                  },
                  font: {
                    color: "#343434",
                    size: 14,
                    // px
                    face: "arial",
                    background: "none",
                    strokeWidth: 0,
                    // px
                    strokeColor: "#ffffff",
                    align: "center",
                    vadjust: 0,
                    multi: false,
                    bold: {
                      mod: "bold"
                    },
                    boldital: {
                      mod: "bold italic"
                    },
                    ital: {
                      mod: "italic"
                    },
                    mono: {
                      mod: "",
                      size: 15,
                      // px
                      face: "monospace",
                      vadjust: 2
                    }
                  },
                  group: void 0,
                  hidden: false,
                  icon: {
                    face: "FontAwesome",
                    //'FontAwesome',
                    code: void 0,
                    //'\uf007',
                    size: 50,
                    //50,
                    color: "#2B7CE9"
                    //'#aa00ff'
                  },
                  image: void 0,
                  // --> URL
                  label: void 0,
                  labelHighlightBold: true,
                  level: void 0,
                  margin: {
                    top: 5,
                    right: 5,
                    bottom: 5,
                    left: 5
                  },
                  mass: 1,
                  physics: true,
                  scaling: {
                    min: 10,
                    max: 30,
                    label: {
                      enabled: false,
                      min: 14,
                      max: 30,
                      maxVisible: 30,
                      drawThreshold: 5
                    },
                    customScalingFunction: function customScalingFunction(min, max, total, value) {
                      if (max === min) {
                        return 0.5;
                      } else {
                        var scale = 1 / (max - min);
                        return Math.max(0, (value - min) * scale);
                      }
                    }
                  },
                  shadow: {
                    enabled: false,
                    color: "rgba(0,0,0,0.5)",
                    size: 10,
                    x: 5,
                    y: 5
                  },
                  shape: "ellipse",
                  shapeProperties: {
                    borderDashes: false,
                    // only for borders
                    borderRadius: 6,
                    // only for box shape
                    interpolation: true,
                    // only for image and circularImage shapes
                    useImageSize: false,
                    // only for image and circularImage shapes
                    useBorderWithImage: false
                    // only for image shape
                  },
                  size: 25,
                  title: void 0,
                  value: void 0,
                  x: void 0,
                  y: void 0
                };
                if (this.defaultOptions.mass <= 0) {
                  throw "Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";
                }
                this.options = util.bridgeObject(this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(NodesHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("refreshNodes", this.refresh.bind(this));
                  this.body.emitter.on("refresh", this.refresh.bind(this));
                  this.body.emitter.on("destroy", function() {
                    util.forEach(_this2.nodesListeners, function(callback, event) {
                      if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);
                    });
                    delete _this2.body.functions.createNode;
                    delete _this2.nodesListeners.add;
                    delete _this2.nodesListeners.update;
                    delete _this2.nodesListeners.remove;
                    delete _this2.nodesListeners;
                  });
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    Node.parseOptions(this.options, options);
                    if (options.shape !== void 0) {
                      for (var nodeId in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(nodeId)) {
                          this.body.nodes[nodeId].updateShape();
                        }
                      }
                    }
                    if (options.font !== void 0) {
                      for (var _nodeId in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId)) {
                          this.body.nodes[_nodeId].updateLabelModule();
                          this.body.nodes[_nodeId].needsRefresh();
                        }
                      }
                    }
                    if (options.size !== void 0) {
                      for (var _nodeId2 in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                          this.body.nodes[_nodeId2].needsRefresh();
                        }
                      }
                    }
                    if (options.hidden !== void 0 || options.physics !== void 0) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
                /**
                 * Set a data set with nodes for the network
                 * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
                 * @param {boolean} [doNotEmit=false]
                 * @private
                 */
              }, {
                key: "setData",
                value: function setData(nodes) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var oldNodesData = this.body.data.nodes;
                  if (nodes instanceof DataSet || nodes instanceof DataView) {
                    this.body.data.nodes = nodes;
                  } else if (Array.isArray(nodes)) {
                    this.body.data.nodes = new DataSet();
                    this.body.data.nodes.add(nodes);
                  } else if (!nodes) {
                    this.body.data.nodes = new DataSet();
                  } else {
                    throw new TypeError("Array or DataSet expected");
                  }
                  if (oldNodesData) {
                    util.forEach(this.nodesListeners, function(callback, event) {
                      oldNodesData.off(event, callback);
                    });
                  }
                  this.body.nodes = {};
                  if (this.body.data.nodes) {
                    var me = this;
                    util.forEach(this.nodesListeners, function(callback, event) {
                      me.body.data.nodes.on(event, callback);
                    });
                    var ids = this.body.data.nodes.getIds();
                    this.add(ids, true);
                  }
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Add nodes
                 * @param {number[] | string[]} ids
                 * @param {boolean} [doNotEmit=false]
                 * @private
                 */
              }, {
                key: "add",
                value: function add(ids) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var id = void 0;
                  var newNodes = [];
                  for (var i = 0; i < ids.length; i++) {
                    id = ids[i];
                    var properties = this.body.data.nodes.get(id);
                    var node = this.create(properties);
                    newNodes.push(node);
                    this.body.nodes[id] = node;
                  }
                  this.layoutEngine.positionInitially(newNodes);
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Update existing nodes, or create them when not yet existing
                 * @param {number[] | string[]} ids id's of changed nodes
                 * @param {Array} changedData array with changed data
                 * @param {Array|undefined} oldData optional; array with previous data
                 * @private
                 */
              }, {
                key: "update",
                value: function update(ids, changedData, oldData) {
                  var nodes = this.body.nodes;
                  var dataChanged = false;
                  for (var i = 0; i < ids.length; i++) {
                    var id = ids[i];
                    var node = nodes[id];
                    var data = changedData[i];
                    if (node !== void 0) {
                      if (node.setOptions(data)) {
                        dataChanged = true;
                      }
                    } else {
                      dataChanged = true;
                      node = this.create(data);
                      nodes[id] = node;
                    }
                  }
                  if (!dataChanged && oldData !== void 0) {
                    dataChanged = changedData.some(function(newValue, index) {
                      var oldValue = oldData[index];
                      return oldValue && oldValue.level !== newValue.level;
                    });
                  }
                  if (dataChanged === true) {
                    this.body.emitter.emit("_dataChanged");
                  } else {
                    this.body.emitter.emit("_dataUpdated");
                  }
                }
                /**
                 * Remove existing nodes. If nodes do not exist, the method will just ignore it.
                 * @param {number[] | string[]} ids
                 * @private
                 */
              }, {
                key: "remove",
                value: function remove(ids) {
                  var nodes = this.body.nodes;
                  for (var i = 0; i < ids.length; i++) {
                    var id = ids[i];
                    delete nodes[id];
                  }
                  this.body.emitter.emit("_dataChanged");
                }
                /**
                 * create a node
                 * @param {Object} properties
                 * @param {class} [constructorClass=Node.default]
                 * @returns {*}
                 */
              }, {
                key: "create",
                value: function create(properties) {
                  var constructorClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Node;
                  return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);
                }
                /**
                 *
                 * @param {boolean} [clearPositions=false]
                 */
              }, {
                key: "refresh",
                value: function refresh() {
                  var _this3 = this;
                  var clearPositions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  util.forEach(this.body.nodes, function(node, nodeId) {
                    var data = _this3.body.data.nodes.get(nodeId);
                    if (data !== void 0) {
                      if (clearPositions === true) {
                        node.setOptions({ x: null, y: null });
                      }
                      node.setOptions({ fixed: false });
                      node.setOptions(data);
                    }
                  });
                }
                /**
                 * Returns the positions of the nodes.
                 * @param {Array.<Node.id>|String} [ids]  --> optional, can be array of nodeIds, can be string
                 * @returns {{}}
                 */
              }, {
                key: "getPositions",
                value: function getPositions(ids) {
                  var dataArray = {};
                  if (ids !== void 0) {
                    if (Array.isArray(ids) === true) {
                      for (var i = 0; i < ids.length; i++) {
                        if (this.body.nodes[ids[i]] !== void 0) {
                          var node = this.body.nodes[ids[i]];
                          dataArray[ids[i]] = { x: Math.round(node.x), y: Math.round(node.y) };
                        }
                      }
                    } else {
                      if (this.body.nodes[ids] !== void 0) {
                        var _node = this.body.nodes[ids];
                        dataArray[ids] = { x: Math.round(_node.x), y: Math.round(_node.y) };
                      }
                    }
                  } else {
                    for (var _i = 0; _i < this.body.nodeIndices.length; _i++) {
                      var _node2 = this.body.nodes[this.body.nodeIndices[_i]];
                      dataArray[this.body.nodeIndices[_i]] = { x: Math.round(_node2.x), y: Math.round(_node2.y) };
                    }
                  }
                  return dataArray;
                }
                /**
                 * Load the XY positions of the nodes into the dataset.
                 */
              }, {
                key: "storePositions",
                value: function storePositions() {
                  var dataArray = [];
                  var dataset = this.body.data.nodes.getDataSet();
                  for (var nodeId in dataset._data) {
                    if (dataset._data.hasOwnProperty(nodeId)) {
                      var node = this.body.nodes[nodeId];
                      if (dataset._data[nodeId].x != Math.round(node.x) || dataset._data[nodeId].y != Math.round(node.y)) {
                        dataArray.push({ id: node.id, x: Math.round(node.x), y: Math.round(node.y) });
                      }
                    }
                  }
                  dataset.update(dataArray);
                }
                /**
                 * get the bounding box of a node.
                 * @param {Node.id} nodeId
                 * @returns {j|*}
                 */
              }, {
                key: "getBoundingBox",
                value: function getBoundingBox(nodeId) {
                  if (this.body.nodes[nodeId] !== void 0) {
                    return this.body.nodes[nodeId].shape.boundingBox;
                  }
                }
                /**
                 * Get the Ids of nodes connected to this node.
                 * @param {Node.id} nodeId
                 * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
                 *                                          Any other value returns both parent and child nodes.
                 * @returns {Array}
                 */
              }, {
                key: "getConnectedNodes",
                value: function getConnectedNodes(nodeId, direction) {
                  var nodeList = [];
                  if (this.body.nodes[nodeId] !== void 0) {
                    var node = this.body.nodes[nodeId];
                    var nodeObj = {};
                    for (var i = 0; i < node.edges.length; i++) {
                      var edge = node.edges[i];
                      if (direction !== "to" && edge.toId == node.id) {
                        if (nodeObj[edge.fromId] === void 0) {
                          nodeList.push(edge.fromId);
                          nodeObj[edge.fromId] = true;
                        }
                      } else if (direction !== "from" && edge.fromId == node.id) {
                        if (nodeObj[edge.toId] === void 0) {
                          nodeList.push(edge.toId);
                          nodeObj[edge.toId] = true;
                        }
                      }
                    }
                  }
                  return nodeList;
                }
                /**
                 * Get the ids of the edges connected to this node.
                 * @param {Node.id} nodeId
                 * @returns {*}
                 */
              }, {
                key: "getConnectedEdges",
                value: function getConnectedEdges(nodeId) {
                  var edgeList = [];
                  if (this.body.nodes[nodeId] !== void 0) {
                    var node = this.body.nodes[nodeId];
                    for (var i = 0; i < node.edges.length; i++) {
                      edgeList.push(node.edges[i].id);
                    }
                  } else {
                    console.log("NodeId provided for getConnectedEdges does not exist. Provided: ", nodeId);
                  }
                  return edgeList;
                }
                /**
                 * Move a node.
                 *
                 * @param {Node.id} nodeId
                 * @param {number} x
                 * @param {number} y
                 */
              }, {
                key: "moveNode",
                value: function moveNode(nodeId, x, y) {
                  var _this4 = this;
                  if (this.body.nodes[nodeId] !== void 0) {
                    this.body.nodes[nodeId].x = Number(x);
                    this.body.nodes[nodeId].y = Number(y);
                    setTimeout(function() {
                      _this4.body.emitter.emit("startSimulation");
                    }, 0);
                  } else {
                    console.log("Node id supplied to moveNode does not exist. Provided: ", nodeId);
                  }
                }
              }]);
              return NodesHandler2;
            }();
            exports2["default"] = NodesHandler;
          },
          /* 188 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(189), __esModule: true };
          },
          /* 189 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(49);
            __webpack_require__(60);
            module2.exports = __webpack_require__(190);
          },
          /* 190 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__(86);
            var ITERATOR = __webpack_require__(13)("iterator");
            var Iterators = __webpack_require__(31);
            module2.exports = __webpack_require__(7).isIterable = function(it) {
              var O = Object(it);
              return O[ITERATOR] !== void 0 || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
            };
          },
          /* 191 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var LabelAccumulator = __webpack_require__(192)["default"];
            var ComponentUtil = __webpack_require__(48)["default"];
            var LabelSplitter = function() {
              function LabelSplitter2(ctx, parent, selected, hover) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, LabelSplitter2);
                this.ctx = ctx;
                this.parent = parent;
                var textWidth = function textWidth2(text, mod) {
                  if (text === void 0) return 0;
                  var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);
                  var width = 0;
                  if (text !== "") {
                    var measure = _this.ctx.measureText(text);
                    width = measure.width;
                  }
                  return { width, values };
                };
                this.lines = new LabelAccumulator(textWidth);
              }
              (0, _createClass3["default"])(LabelSplitter2, [{
                key: "process",
                value: function process(text) {
                  if (!ComponentUtil.isValidLabel(text)) {
                    return this.lines.finalize();
                  }
                  var font = this.parent.fontOptions;
                  text = text.replace(/\r\n/g, "\n");
                  text = text.replace(/\r/g, "\n");
                  var nlLines = String(text).split("\n");
                  var lineCount = nlLines.length;
                  if (font.multi) {
                    for (var i = 0; i < lineCount; i++) {
                      var blocks = this.splitBlocks(nlLines[i], font.multi);
                      if (blocks === void 0) continue;
                      if (blocks.length === 0) {
                        this.lines.newLine("");
                        continue;
                      }
                      if (font.maxWdt > 0) {
                        for (var j = 0; j < blocks.length; j++) {
                          var mod = blocks[j].mod;
                          var _text = blocks[j].text;
                          this.splitStringIntoLines(_text, mod, true);
                        }
                      } else {
                        for (var _j = 0; _j < blocks.length; _j++) {
                          var _mod = blocks[_j].mod;
                          var _text2 = blocks[_j].text;
                          this.lines.append(_text2, _mod);
                        }
                      }
                      this.lines.newLine();
                    }
                  } else {
                    if (font.maxWdt > 0) {
                      for (var _i = 0; _i < lineCount; _i++) {
                        this.splitStringIntoLines(nlLines[_i]);
                      }
                    } else {
                      for (var _i2 = 0; _i2 < lineCount; _i2++) {
                        this.lines.newLine(nlLines[_i2]);
                      }
                    }
                  }
                  return this.lines.finalize();
                }
                /**
                 * normalize the markup system
                 *
                 * @param {boolean|'md'|'markdown'|'html'} markupSystem
                 * @returns {string}
                 */
              }, {
                key: "decodeMarkupSystem",
                value: function decodeMarkupSystem(markupSystem) {
                  var system = "none";
                  if (markupSystem === "markdown" || markupSystem === "md") {
                    system = "markdown";
                  } else if (markupSystem === true || markupSystem === "html") {
                    system = "html";
                  }
                  return system;
                }
                /**
                 *
                 * @param {string} text
                 * @returns {Array}
                 */
              }, {
                key: "splitHtmlBlocks",
                value: function splitHtmlBlocks(text) {
                  var blocks = [];
                  var s = {
                    bold: false,
                    ital: false,
                    mono: false,
                    spacing: false,
                    position: 0,
                    buffer: "",
                    modStack: []
                  };
                  s.mod = function() {
                    return this.modStack.length === 0 ? "normal" : this.modStack[0];
                  };
                  s.modName = function() {
                    if (this.modStack.length === 0) return "normal";
                    else if (this.modStack[0] === "mono") return "mono";
                    else {
                      if (s.bold && s.ital) {
                        return "boldital";
                      } else if (s.bold) {
                        return "bold";
                      } else if (s.ital) {
                        return "ital";
                      }
                    }
                  };
                  s.emitBlock = function() {
                    var override = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (this.spacing) {
                      this.add(" ");
                      this.spacing = false;
                    }
                    if (this.buffer.length > 0) {
                      blocks.push({ text: this.buffer, mod: this.modName() });
                      this.buffer = "";
                    }
                  };
                  s.add = function(text2) {
                    if (text2 === " ") {
                      s.spacing = true;
                    }
                    if (s.spacing) {
                      this.buffer += " ";
                      this.spacing = false;
                    }
                    if (text2 != " ") {
                      this.buffer += text2;
                    }
                  };
                  while (s.position < text.length) {
                    var ch = text.charAt(s.position);
                    if (/[ \t]/.test(ch)) {
                      if (!s.mono) {
                        s.spacing = true;
                      } else {
                        s.add(ch);
                      }
                    } else if (/</.test(ch)) {
                      if (!s.mono && !s.bold && /<b>/.test(text.substr(s.position, 3))) {
                        s.emitBlock();
                        s.bold = true;
                        s.modStack.unshift("bold");
                        s.position += 2;
                      } else if (!s.mono && !s.ital && /<i>/.test(text.substr(s.position, 3))) {
                        s.emitBlock();
                        s.ital = true;
                        s.modStack.unshift("ital");
                        s.position += 2;
                      } else if (!s.mono && /<code>/.test(text.substr(s.position, 6))) {
                        s.emitBlock();
                        s.mono = true;
                        s.modStack.unshift("mono");
                        s.position += 5;
                      } else if (!s.mono && s.mod() === "bold" && /<\/b>/.test(text.substr(s.position, 4))) {
                        s.emitBlock();
                        s.bold = false;
                        s.modStack.shift();
                        s.position += 3;
                      } else if (!s.mono && s.mod() === "ital" && /<\/i>/.test(text.substr(s.position, 4))) {
                        s.emitBlock();
                        s.ital = false;
                        s.modStack.shift();
                        s.position += 3;
                      } else if (s.mod() === "mono" && /<\/code>/.test(text.substr(s.position, 7))) {
                        s.emitBlock();
                        s.mono = false;
                        s.modStack.shift();
                        s.position += 6;
                      } else {
                        s.add(ch);
                      }
                    } else if (/&/.test(ch)) {
                      if (/&lt;/.test(text.substr(s.position, 4))) {
                        s.add("<");
                        s.position += 3;
                      } else if (/&amp;/.test(text.substr(s.position, 5))) {
                        s.add("&");
                        s.position += 4;
                      } else {
                        s.add("&");
                      }
                    } else {
                      s.add(ch);
                    }
                    s.position++;
                  }
                  s.emitBlock();
                  return blocks;
                }
                /**
                 *
                 * @param {string} text
                 * @returns {Array}
                 */
              }, {
                key: "splitMarkdownBlocks",
                value: function splitMarkdownBlocks(text) {
                  var blocks = [];
                  var s = {
                    bold: false,
                    ital: false,
                    mono: false,
                    beginable: true,
                    spacing: false,
                    position: 0,
                    buffer: "",
                    modStack: []
                  };
                  s.mod = function() {
                    return this.modStack.length === 0 ? "normal" : this.modStack[0];
                  };
                  s.modName = function() {
                    if (this.modStack.length === 0) return "normal";
                    else if (this.modStack[0] === "mono") return "mono";
                    else {
                      if (s.bold && s.ital) {
                        return "boldital";
                      } else if (s.bold) {
                        return "bold";
                      } else if (s.ital) {
                        return "ital";
                      }
                    }
                  };
                  s.emitBlock = function() {
                    var override = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    if (this.spacing) {
                      this.add(" ");
                      this.spacing = false;
                    }
                    if (this.buffer.length > 0) {
                      blocks.push({ text: this.buffer, mod: this.modName() });
                      this.buffer = "";
                    }
                  };
                  s.add = function(text2) {
                    if (text2 === " ") {
                      s.spacing = true;
                    }
                    if (s.spacing) {
                      this.buffer += " ";
                      this.spacing = false;
                    }
                    if (text2 != " ") {
                      this.buffer += text2;
                    }
                  };
                  while (s.position < text.length) {
                    var ch = text.charAt(s.position);
                    if (/[ \t]/.test(ch)) {
                      if (!s.mono) {
                        s.spacing = true;
                      } else {
                        s.add(ch);
                      }
                      s.beginable = true;
                    } else if (/\\/.test(ch)) {
                      if (s.position < text.length + 1) {
                        s.position++;
                        ch = text.charAt(s.position);
                        if (/ \t/.test(ch)) {
                          s.spacing = true;
                        } else {
                          s.add(ch);
                          s.beginable = false;
                        }
                      }
                    } else if (!s.mono && !s.bold && (s.beginable || s.spacing) && /\*/.test(ch)) {
                      s.emitBlock();
                      s.bold = true;
                      s.modStack.unshift("bold");
                    } else if (!s.mono && !s.ital && (s.beginable || s.spacing) && /\_/.test(ch)) {
                      s.emitBlock();
                      s.ital = true;
                      s.modStack.unshift("ital");
                    } else if (!s.mono && (s.beginable || s.spacing) && /`/.test(ch)) {
                      s.emitBlock();
                      s.mono = true;
                      s.modStack.unshift("mono");
                    } else if (!s.mono && s.mod() === "bold" && /\*/.test(ch)) {
                      if (s.position === text.length - 1 || /[.,_` \t\n]/.test(text.charAt(s.position + 1))) {
                        s.emitBlock();
                        s.bold = false;
                        s.modStack.shift();
                      } else {
                        s.add(ch);
                      }
                    } else if (!s.mono && s.mod() === "ital" && /\_/.test(ch)) {
                      if (s.position === text.length - 1 || /[.,*` \t\n]/.test(text.charAt(s.position + 1))) {
                        s.emitBlock();
                        s.ital = false;
                        s.modStack.shift();
                      } else {
                        s.add(ch);
                      }
                    } else if (s.mono && s.mod() === "mono" && /`/.test(ch)) {
                      if (s.position === text.length - 1 || /[.,*_ \t\n]/.test(text.charAt(s.position + 1))) {
                        s.emitBlock();
                        s.mono = false;
                        s.modStack.shift();
                      } else {
                        s.add(ch);
                      }
                    } else {
                      s.add(ch);
                      s.beginable = false;
                    }
                    s.position++;
                  }
                  s.emitBlock();
                  return blocks;
                }
                /**
                 * Explodes a piece of text into single-font blocks using a given markup
                 *
                 * @param {string} text
                 * @param {boolean|'md'|'markdown'|'html'} markupSystem
                 * @returns {Array.<{text: string, mod: string}>}
                 * @private
                 */
              }, {
                key: "splitBlocks",
                value: function splitBlocks(text, markupSystem) {
                  var system = this.decodeMarkupSystem(markupSystem);
                  if (system === "none") {
                    return [{
                      text,
                      mod: "normal"
                    }];
                  } else if (system === "markdown") {
                    return this.splitMarkdownBlocks(text);
                  } else if (system === "html") {
                    return this.splitHtmlBlocks(text);
                  }
                }
                /**
                 * @param {string} text
                 * @returns {boolean} true if text length over the current max with
                 * @private
                 */
              }, {
                key: "overMaxWidth",
                value: function overMaxWidth(text) {
                  var width = this.ctx.measureText(text).width;
                  return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;
                }
                /**
                 * Determine the longest part of the sentence which still fits in the 
                 * current max width.
                 * 
                 * @param {Array} words  Array of strings signifying a text lines
                 * @return {number}      index of first item in string making string go over max
                 * @private
                 */
              }, {
                key: "getLongestFit",
                value: function getLongestFit(words) {
                  var text = "";
                  var w = 0;
                  while (w < words.length) {
                    var pre = text === "" ? "" : " ";
                    var newText = text + pre + words[w];
                    if (this.overMaxWidth(newText)) break;
                    text = newText;
                    w++;
                  }
                  return w;
                }
                /**
                 * Determine the longest part of the string which still fits in the
                 * current max width.
                 * 
                 * @param {Array} words Array of strings signifying a text lines
                 * @return {number} index of first item in string making string go over max
                 */
              }, {
                key: "getLongestFitWord",
                value: function getLongestFitWord(words) {
                  var w = 0;
                  while (w < words.length) {
                    if (this.overMaxWidth(words.slice(0, w))) break;
                    w++;
                  }
                  return w;
                }
                /**
                 * Split the passed text into lines, according to width constraint (if any).
                 * 
                 * The method assumes that the input string is a single line, i.e. without lines break.
                 *
                 * This method retains spaces, if still present (case `font.multi: false`).
                 * A space which falls on an internal line break, will be replaced by a newline.
                 * There is no special handling of tabs; these go along with the flow.
                 * 
                 * @param {string} str
                 * @param {string} [mod='normal']
                 * @param {boolean} [appendLast=false]
                 * @private
                 */
              }, {
                key: "splitStringIntoLines",
                value: function splitStringIntoLines(str) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  var appendLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  str = str.replace(/^( +)/g, "$1\r");
                  str = str.replace(/([^\r][^ ]*)( +)/g, "$1\r$2\r");
                  var words = str.split("\r");
                  while (words.length > 0) {
                    var w = this.getLongestFit(words);
                    if (w === 0) {
                      var word = words[0];
                      var x = this.getLongestFitWord(word);
                      this.lines.newLine(word.slice(0, x), mod);
                      words[0] = word.slice(x);
                    } else {
                      var newW = w;
                      if (words[w - 1] === " ") {
                        w--;
                      } else if (words[newW] === " ") {
                        newW++;
                      }
                      var text = words.slice(0, w).join("");
                      if (w == words.length && appendLast) {
                        this.lines.append(text, mod);
                      } else {
                        this.lines.newLine(text, mod);
                      }
                      words = words.slice(newW);
                    }
                  }
                }
              }]);
              return LabelSplitter2;
            }();
            exports2["default"] = LabelSplitter;
          },
          /* 192 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _assign = __webpack_require__(90);
            var _assign2 = _interopRequireDefault(_assign);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var LabelAccumulator = function() {
              function LabelAccumulator2(measureText) {
                (0, _classCallCheck3["default"])(this, LabelAccumulator2);
                this.measureText = measureText;
                this.current = 0;
                this.width = 0;
                this.height = 0;
                this.lines = [];
              }
              (0, _createClass3["default"])(LabelAccumulator2, [{
                key: "_add",
                value: function _add(l, text) {
                  var mod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "normal";
                  if (this.lines[l] === void 0) {
                    this.lines[l] = {
                      width: 0,
                      height: 0,
                      blocks: []
                    };
                  }
                  var tmpText = text;
                  if (text === void 0 || text === "") tmpText = " ";
                  var result = this.measureText(tmpText, mod);
                  var block = (0, _assign2["default"])({}, result.values);
                  block.text = text;
                  block.width = result.width;
                  block.mod = mod;
                  if (text === void 0 || text === "") {
                    block.width = 0;
                  }
                  this.lines[l].blocks.push(block);
                  this.lines[l].width += block.width;
                }
                /**
                 * Returns the width in pixels of the current line.
                 *
                 * @returns {number}
                 */
              }, {
                key: "curWidth",
                value: function curWidth() {
                  var line = this.lines[this.current];
                  if (line === void 0) return 0;
                  return line.width;
                }
                /**
                 * Add text in block to current line
                 *
                 * @param {string} text
                 * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
                 */
              }, {
                key: "append",
                value: function append(text) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  this._add(this.current, text, mod);
                }
                /**
                 * Add text in block to current line and start a new line
                 *
                 * @param {string} text
                 * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
                 */
              }, {
                key: "newLine",
                value: function newLine(text) {
                  var mod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "normal";
                  this._add(this.current, text, mod);
                  this.current++;
                }
                /**
                 * Determine and set the heights of all the lines currently contained in this instance
                 *
                 * Note that width has already been set.
                 * 
                 * @private
                 */
              }, {
                key: "determineLineHeights",
                value: function determineLineHeights() {
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    var height = 0;
                    if (line.blocks !== void 0) {
                      for (var l = 0; l < line.blocks.length; l++) {
                        var block = line.blocks[l];
                        if (height < block.height) {
                          height = block.height;
                        }
                      }
                    }
                    line.height = height;
                  }
                }
                /**
                 * Determine the full size of the label text, as determined by current lines and blocks
                 * 
                 * @private
                 */
              }, {
                key: "determineLabelSize",
                value: function determineLabelSize() {
                  var width = 0;
                  var height = 0;
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    if (line.width > width) {
                      width = line.width;
                    }
                    height += line.height;
                  }
                  this.width = width;
                  this.height = height;
                }
                /**
                 * Remove all empty blocks and empty lines we don't need
                 * 
                 * This must be done after the width/height determination,
                 * so that these are set properly for processing here.
                 *
                 * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
                 * @private
                 */
              }, {
                key: "removeEmptyBlocks",
                value: function removeEmptyBlocks() {
                  var tmpLines = [];
                  for (var k = 0; k < this.lines.length; k++) {
                    var line = this.lines[k];
                    if (line.blocks.length === 0) continue;
                    if (k === this.lines.length - 1) {
                      if (line.width === 0) continue;
                    }
                    var tmpLine = {};
                    (0, _assign2["default"])(tmpLine, line);
                    tmpLine.blocks = [];
                    var firstEmptyBlock = void 0;
                    var tmpBlocks = [];
                    for (var l = 0; l < line.blocks.length; l++) {
                      var block = line.blocks[l];
                      if (block.width !== 0) {
                        tmpBlocks.push(block);
                      } else {
                        if (firstEmptyBlock === void 0) {
                          firstEmptyBlock = block;
                        }
                      }
                    }
                    if (tmpBlocks.length === 0 && firstEmptyBlock !== void 0) {
                      tmpBlocks.push(firstEmptyBlock);
                    }
                    tmpLine.blocks = tmpBlocks;
                    tmpLines.push(tmpLine);
                  }
                  return tmpLines;
                }
                /**
                 * Set the sizes for all lines and the whole thing.
                 *
                 * @returns {{width: (number|*), height: (number|*), lines: Array}}
                 */
              }, {
                key: "finalize",
                value: function finalize() {
                  this.determineLineHeights();
                  this.determineLabelSize();
                  var tmpLines = this.removeEmptyBlocks();
                  return {
                    width: this.width,
                    height: this.height,
                    lines: tmpLines
                  };
                }
              }]);
              return LabelAccumulator2;
            }();
            exports2["default"] = LabelAccumulator;
          },
          /* 193 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Box = function(_NodeBase) {
              (0, _inherits3["default"])(Box2, _NodeBase);
              function Box2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Box2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Box2.__proto__ || (0, _getPrototypeOf2["default"])(Box2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Box2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    this.width = dimensions.width + this.margin.right + this.margin.left;
                    this.height = dimensions.height + this.margin.top + this.margin.bottom;
                    this.radius = this.width / 2;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx.roundRect(this.left, this.top, this.width, this.height, values.borderRadius);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                }
                /**
                 *
                 * @param {number} x width
                 * @param {number} y height
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {boolean} selected
                 * @param {boolean} hover
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y, ctx, selected, hover) {
                  this._updateBoundingBox(x, y, ctx, selected, hover);
                  var borderRadius = this.options.shapeProperties.borderRadius;
                  this._addBoundingBoxMargin(borderRadius);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  var borderWidth = this.options.borderWidth;
                  return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;
                }
              }]);
              return Box2;
            }(_NodeBase3["default"]);
            exports2["default"] = Box;
          },
          /* 194 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(195);
            module2.exports = __webpack_require__(7).Object.getPrototypeOf;
          },
          /* 195 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toObject = __webpack_require__(41);
            var $getPrototypeOf = __webpack_require__(85);
            __webpack_require__(87)("getPrototypeOf", function() {
              return function getPrototypeOf(it) {
                return $getPrototypeOf(toObject(it));
              };
            });
          },
          /* 196 */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(197), __esModule: true };
          },
          /* 197 */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(198);
            module2.exports = __webpack_require__(7).Object.setPrototypeOf;
          },
          /* 198 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $export = __webpack_require__(17);
            $export($export.S, "Object", { setPrototypeOf: __webpack_require__(199).set });
          },
          /* 199 */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject = __webpack_require__(32);
            var anObject = __webpack_require__(27);
            var check = function(O, proto) {
              anObject(O);
              if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
            };
            module2.exports = {
              set: Object.setPrototypeOf || ("__proto__" in {} ? (
                // eslint-disable-line
                function(test, buggy, set) {
                  try {
                    set = __webpack_require__(80)(Function.call, __webpack_require__(89).f(Object.prototype, "__proto__").set, 2);
                    set(test, []);
                    buggy = !(test instanceof Array);
                  } catch (e) {
                    buggy = true;
                  }
                  return function setPrototypeOf(O, proto) {
                    check(O, proto);
                    if (buggy) O.__proto__ = proto;
                    else set(O, proto);
                    return O;
                  };
                }({}, false)
              ) : void 0),
              check
            };
          },
          /* 200 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(73);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Circle = function(_CircleImageBase) {
              (0, _inherits3["default"])(Circle2, _CircleImageBase);
              function Circle2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Circle2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Circle2.__proto__ || (0, _getPrototypeOf2["default"])(Circle2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Circle2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);
                    this.options.size = diameter / 2;
                    this.width = diameter;
                    this.height = diameter;
                    this.radius = this.width / 2;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._drawRawCircle(ctx, x, y, values);
                  this.updateBoundingBox(x, y);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);
                }
                /**
                 *
                 * @param {number} x width
                 * @param {number} y height
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle - Unused
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.width * 0.5;
                }
              }]);
              return Circle2;
            }(_CircleImageBase3["default"]);
            exports2["default"] = Circle;
          },
          /* 201 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(73);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CircularImage = function(_CircleImageBase) {
              (0, _inherits3["default"])(CircularImage2, _CircleImageBase);
              function CircularImage2(options, body, labelModule, imageObj, imageObjAlt) {
                (0, _classCallCheck3["default"])(this, CircularImage2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (CircularImage2.__proto__ || (0, _getPrototypeOf2["default"])(CircularImage2)).call(this, options, body, labelModule));
                _this.setImages(imageObj, imageObjAlt);
                return _this;
              }
              (0, _createClass3["default"])(CircularImage2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
                  if (imageAbsent) {
                    var diameter = this.options.size * 2;
                    this.width = diameter;
                    this.height = diameter;
                    this.radius = 0.5 * this.width;
                    return;
                  }
                  if (this.needsRefresh(selected, hover)) {
                    this._resizeImage();
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.switchImages(selected);
                  this.resize();
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._drawRawCircle(ctx, x, y, values);
                  ctx.save();
                  ctx.clip();
                  this._drawImageAtPosition(ctx, values);
                  ctx.restore();
                  this._drawImageLabel(ctx, x, y, selected, hover);
                  this.updateBoundingBox(x, y);
                }
                // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here
                /**
                 *
                 * @param {number} x width
                 * @param {number} y height
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.size;
                  this.boundingBox.left = x - this.options.size;
                  this.boundingBox.right = x + this.options.size;
                  this.boundingBox.bottom = y + this.options.size;
                  this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                  this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                  this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle - Unused
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.width * 0.5;
                }
              }]);
              return CircularImage2;
            }(_CircleImageBase3["default"]);
            exports2["default"] = CircularImage;
          },
          /* 202 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Database = function(_NodeBase) {
              (0, _inherits3["default"])(Database2, _NodeBase);
              function Database2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Database2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Database2.__proto__ || (0, _getPrototypeOf2["default"])(Database2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Database2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    var size = dimensions.width + this.margin.right + this.margin.left;
                    this.width = size;
                    this.height = size;
                    this.radius = this.width / 2;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.initContextForDraw(ctx, values);
                  ctx.database(x - this.width / 2, y - this.height / 2, this.width, this.height);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Database2;
            }(_NodeBase3["default"]);
            exports2["default"] = Database;
          },
          /* 203 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Diamond = function(_ShapeBase) {
              (0, _inherits3["default"])(Diamond2, _ShapeBase);
              function Diamond2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Diamond2);
                return (0, _possibleConstructorReturn3["default"])(this, (Diamond2.__proto__ || (0, _getPrototypeOf2["default"])(Diamond2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Diamond2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "diamond", 4, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Diamond2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Diamond;
          },
          /* 204 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Dot = function(_ShapeBase) {
              (0, _inherits3["default"])(Dot2, _ShapeBase);
              function Dot2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Dot2);
                return (0, _possibleConstructorReturn3["default"])(this, (Dot2.__proto__ || (0, _getPrototypeOf2["default"])(Dot2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Dot2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "circle", 2, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  return this.options.size;
                }
              }]);
              return Dot2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Dot;
          },
          /* 205 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Ellipse = function(_NodeBase) {
              (0, _inherits3["default"])(Ellipse2, _NodeBase);
              function Ellipse2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Ellipse2);
                return (0, _possibleConstructorReturn3["default"])(this, (Ellipse2.__proto__ || (0, _getPrototypeOf2["default"])(Ellipse2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Ellipse2, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  if (this.needsRefresh(selected, hover)) {
                    var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);
                    this.height = dimensions.height * 2;
                    this.width = dimensions.width + dimensions.height;
                    this.radius = 0.5 * this.width;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width * 0.5;
                  this.top = y - this.height * 0.5;
                  this.initContextForDraw(ctx, values);
                  ctx.ellipse_vis(this.left, this.top, this.width, this.height);
                  this.performFill(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                  this.labelModule.draw(ctx, x, y, selected, hover);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  this.resize(ctx);
                  var a = this.width * 0.5;
                  var b = this.height * 0.5;
                  var w = Math.sin(angle) * a;
                  var h = Math.cos(angle) * b;
                  return a * b / Math.sqrt(w * w + h * h);
                }
              }]);
              return Ellipse2;
            }(_NodeBase3["default"]);
            exports2["default"] = Ellipse;
          },
          /* 206 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Icon = function(_NodeBase) {
              (0, _inherits3["default"])(Icon2, _NodeBase);
              function Icon2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Icon2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Icon2.__proto__ || (0, _getPrototypeOf2["default"])(Icon2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Icon2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    this.iconSize = {
                      width: Number(this.options.icon.size),
                      height: Number(this.options.icon.size)
                    };
                    this.width = this.iconSize.width + this.margin.right + this.margin.left;
                    this.height = this.iconSize.height + this.margin.top + this.margin.bottom;
                    this.radius = 0.5 * this.width;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.options.icon.size = this.options.icon.size || 50;
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this._icon(ctx, x, y, selected, hover, values);
                  if (this.options.label !== void 0) {
                    var iconTextSpacing = 5;
                    this.labelModule.draw(ctx, this.left + this.iconSize.width / 2 + this.margin.left, y + this.height / 2 + iconTextSpacing, selected);
                  }
                  this.updateBoundingBox(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.boundingBox.top = y - this.options.icon.size * 0.5;
                  this.boundingBox.left = x - this.options.icon.size * 0.5;
                  this.boundingBox.right = x + this.options.icon.size * 0.5;
                  this.boundingBox.bottom = y + this.options.icon.size * 0.5;
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    var iconTextSpacing = 5;
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover - Unused
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "_icon",
                value: function _icon(ctx, x, y, selected, hover, values) {
                  var iconSize = Number(this.options.icon.size);
                  if (this.options.icon.code !== void 0) {
                    ctx.font = (selected ? "bold " : "") + iconSize + "px " + this.options.icon.face;
                    ctx.fillStyle = this.options.icon.color || "black";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    this.enableShadow(ctx, values);
                    ctx.fillText(this.options.icon.code, x, y);
                    this.disableShadow(ctx, values);
                  } else {
                    console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Icon2;
            }(_NodeBase3["default"]);
            exports2["default"] = Icon;
          },
          /* 207 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CircleImageBase2 = __webpack_require__(73);
            var _CircleImageBase3 = _interopRequireDefault(_CircleImageBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Image2 = function(_CircleImageBase) {
              (0, _inherits3["default"])(Image3, _CircleImageBase);
              function Image3(options, body, labelModule, imageObj, imageObjAlt) {
                (0, _classCallCheck3["default"])(this, Image3);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Image3.__proto__ || (0, _getPrototypeOf2["default"])(Image3)).call(this, options, body, labelModule));
                _this.setImages(imageObj, imageObjAlt);
                return _this;
              }
              (0, _createClass3["default"])(Image3, [{
                key: "resize",
                value: function resize(ctx) {
                  var selected = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selected;
                  var hover = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.hover;
                  var imageAbsent = this.imageObj.src === void 0 || this.imageObj.width === void 0 || this.imageObj.height === void 0;
                  if (imageAbsent) {
                    var side = this.options.size * 2;
                    this.width = side;
                    this.height = side;
                    return;
                  }
                  if (this.needsRefresh(selected, hover)) {
                    this._resizeImage();
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.switchImages(selected);
                  this.resize();
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  if (this.options.shapeProperties.useBorderWithImage === true) {
                    var neutralborderWidth = this.options.borderWidth;
                    var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;
                    var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;
                    ctx.lineWidth = Math.min(this.width, borderWidth);
                    ctx.beginPath();
                    ctx.strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;
                    ctx.fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;
                    ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);
                    ctx.fill();
                    this.performStroke(ctx, values);
                    ctx.closePath();
                  }
                  this._drawImageAtPosition(ctx, values);
                  this._drawImageLabel(ctx, x, y, selected, hover);
                  this.updateBoundingBox(x, y);
                }
                /**
                 *
                 * @param {number} x
                 * @param {number} y
                 */
              }, {
                key: "updateBoundingBox",
                value: function updateBoundingBox(x, y) {
                  this.resize();
                  this._updateBoundingBox(x, y);
                  if (this.options.label !== void 0 && this.labelModule.size.width > 0) {
                    this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);
                    this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);
                    this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Image3;
            }(_CircleImageBase3["default"]);
            exports2["default"] = Image2;
          },
          /* 208 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Square = function(_ShapeBase) {
              (0, _inherits3["default"])(Square2, _ShapeBase);
              function Square2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Square2);
                return (0, _possibleConstructorReturn3["default"])(this, (Square2.__proto__ || (0, _getPrototypeOf2["default"])(Square2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Square2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "square", 2, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Square2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Square;
          },
          /* 209 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hexagon = function(_ShapeBase) {
              (0, _inherits3["default"])(Hexagon2, _ShapeBase);
              function Hexagon2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Hexagon2);
                return (0, _possibleConstructorReturn3["default"])(this, (Hexagon2.__proto__ || (0, _getPrototypeOf2["default"])(Hexagon2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Hexagon2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "hexagon", 4, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Hexagon2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Hexagon;
          },
          /* 210 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Star = function(_ShapeBase) {
              (0, _inherits3["default"])(Star2, _ShapeBase);
              function Star2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Star2);
                return (0, _possibleConstructorReturn3["default"])(this, (Star2.__proto__ || (0, _getPrototypeOf2["default"])(Star2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Star2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "star", 4, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Star2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Star;
          },
          /* 211 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _NodeBase2 = __webpack_require__(23);
            var _NodeBase3 = _interopRequireDefault(_NodeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Text = function(_NodeBase) {
              (0, _inherits3["default"])(Text2, _NodeBase);
              function Text2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Text2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Text2.__proto__ || (0, _getPrototypeOf2["default"])(Text2)).call(this, options, body, labelModule));
                _this._setMargins(labelModule);
                return _this;
              }
              (0, _createClass3["default"])(Text2, [{
                key: "resize",
                value: function resize(ctx, selected, hover) {
                  if (this.needsRefresh(selected, hover)) {
                    this.textSize = this.labelModule.getTextSize(ctx, selected, hover);
                    this.width = this.textSize.width + this.margin.right + this.margin.left;
                    this.height = this.textSize.height + this.margin.top + this.margin.bottom;
                    this.radius = 0.5 * this.width;
                  }
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} x width
                 * @param {number} y height
                 * @param {boolean} selected
                 * @param {boolean} hover
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 */
              }, {
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this.resize(ctx, selected, hover);
                  this.left = x - this.width / 2;
                  this.top = y - this.height / 2;
                  this.enableShadow(ctx, values);
                  this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);
                  this.disableShadow(ctx, values);
                  this.updateBoundingBox(x, y, ctx, selected, hover);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Text2;
            }(_NodeBase3["default"]);
            exports2["default"] = Text;
          },
          /* 212 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Triangle = function(_ShapeBase) {
              (0, _inherits3["default"])(Triangle2, _ShapeBase);
              function Triangle2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, Triangle2);
                return (0, _possibleConstructorReturn3["default"])(this, (Triangle2.__proto__ || (0, _getPrototypeOf2["default"])(Triangle2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(Triangle2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "triangle", 3, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return Triangle2;
            }(_ShapeBase3["default"]);
            exports2["default"] = Triangle;
          },
          /* 213 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _ShapeBase2 = __webpack_require__(24);
            var _ShapeBase3 = _interopRequireDefault(_ShapeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var TriangleDown = function(_ShapeBase) {
              (0, _inherits3["default"])(TriangleDown2, _ShapeBase);
              function TriangleDown2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, TriangleDown2);
                return (0, _possibleConstructorReturn3["default"])(this, (TriangleDown2.__proto__ || (0, _getPrototypeOf2["default"])(TriangleDown2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(TriangleDown2, [{
                key: "draw",
                value: function draw(ctx, x, y, selected, hover, values) {
                  this._drawShape(ctx, "triangleDown", 3, x, y, selected, hover, values);
                }
                /**
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {number} angle
                 * @returns {number}
                 */
              }, {
                key: "distanceToBorder",
                value: function distanceToBorder(ctx, angle) {
                  return this._distanceToBorder(ctx, angle);
                }
              }]);
              return TriangleDown2;
            }(_ShapeBase3["default"]);
            exports2["default"] = TriangleDown;
          },
          /* 214 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var DataSet = __webpack_require__(11);
            var DataView = __webpack_require__(12);
            var Edge = __webpack_require__(74)["default"];
            var EdgesHandler = function() {
              function EdgesHandler2(body, images, groups) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, EdgesHandler2);
                this.body = body;
                this.images = images;
                this.groups = groups;
                this.body.functions.createEdge = this.create.bind(this);
                this.edgesListeners = {
                  add: function add(event, params) {
                    _this.add(params.items);
                  },
                  update: function update(event, params) {
                    _this.update(params.items);
                  },
                  remove: function remove(event, params) {
                    _this.remove(params.items);
                  }
                };
                this.options = {};
                this.defaultOptions = {
                  arrows: {
                    to: { enabled: false, scaleFactor: 1, type: "arrow" },
                    // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
                    middle: { enabled: false, scaleFactor: 1, type: "arrow" },
                    from: { enabled: false, scaleFactor: 1, type: "arrow" }
                  },
                  arrowStrikethrough: true,
                  color: {
                    color: "#848484",
                    highlight: "#848484",
                    hover: "#848484",
                    inherit: "from",
                    opacity: 1
                  },
                  dashes: false,
                  font: {
                    color: "#343434",
                    size: 14,
                    // px
                    face: "arial",
                    background: "none",
                    strokeWidth: 2,
                    // px
                    strokeColor: "#ffffff",
                    align: "horizontal",
                    multi: false,
                    vadjust: 0,
                    bold: {
                      mod: "bold"
                    },
                    boldital: {
                      mod: "bold italic"
                    },
                    ital: {
                      mod: "italic"
                    },
                    mono: {
                      mod: "",
                      size: 15,
                      // px
                      face: "courier new",
                      vadjust: 2
                    }
                  },
                  hidden: false,
                  hoverWidth: 1.5,
                  label: void 0,
                  labelHighlightBold: true,
                  length: void 0,
                  physics: true,
                  scaling: {
                    min: 1,
                    max: 15,
                    label: {
                      enabled: true,
                      min: 14,
                      max: 30,
                      maxVisible: 30,
                      drawThreshold: 5
                    },
                    customScalingFunction: function customScalingFunction(min, max, total, value) {
                      if (max === min) {
                        return 0.5;
                      } else {
                        var scale = 1 / (max - min);
                        return Math.max(0, (value - min) * scale);
                      }
                    }
                  },
                  selectionWidth: 1.5,
                  selfReferenceSize: 20,
                  shadow: {
                    enabled: false,
                    color: "rgba(0,0,0,0.5)",
                    size: 10,
                    x: 5,
                    y: 5
                  },
                  smooth: {
                    enabled: true,
                    type: "dynamic",
                    forceDirection: "none",
                    roundness: 0.5
                  },
                  title: void 0,
                  width: 1,
                  value: void 0
                };
                util.deepExtend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(EdgesHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("_forceDisableDynamicCurves", function(type) {
                    var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (type === "dynamic") {
                      type = "continuous";
                    }
                    var dataChanged = false;
                    for (var edgeId in _this2.body.edges) {
                      if (_this2.body.edges.hasOwnProperty(edgeId)) {
                        var edge = _this2.body.edges[edgeId];
                        var edgeData = _this2.body.data.edges._data[edgeId];
                        if (edgeData !== void 0) {
                          var smoothOptions = edgeData.smooth;
                          if (smoothOptions !== void 0) {
                            if (smoothOptions.enabled === true && smoothOptions.type === "dynamic") {
                              if (type === void 0) {
                                edge.setOptions({ smooth: false });
                              } else {
                                edge.setOptions({ smooth: { type } });
                              }
                              dataChanged = true;
                            }
                          }
                        }
                      }
                    }
                    if (emit === true && dataChanged === true) {
                      _this2.body.emitter.emit("_dataChanged");
                    }
                  });
                  this.body.emitter.on("_dataUpdated", function() {
                    _this2.reconnectEdges();
                  });
                  this.body.emitter.on("refreshEdges", this.refresh.bind(this));
                  this.body.emitter.on("refresh", this.refresh.bind(this));
                  this.body.emitter.on("destroy", function() {
                    util.forEach(_this2.edgesListeners, function(callback, event) {
                      if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);
                    });
                    delete _this2.body.functions.createEdge;
                    delete _this2.edgesListeners.add;
                    delete _this2.edgesListeners.update;
                    delete _this2.edgesListeners.remove;
                    delete _this2.edgesListeners;
                  });
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    Edge.parseOptions(this.options, options, true, this.defaultOptions, true);
                    var dataChanged = false;
                    if (options.smooth !== void 0) {
                      for (var edgeId in this.body.edges) {
                        if (this.body.edges.hasOwnProperty(edgeId)) {
                          dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;
                        }
                      }
                    }
                    if (options.font !== void 0) {
                      for (var _edgeId in this.body.edges) {
                        if (this.body.edges.hasOwnProperty(_edgeId)) {
                          this.body.edges[_edgeId].updateLabelModule();
                        }
                      }
                    }
                    if (options.hidden !== void 0 || options.physics !== void 0 || dataChanged === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
                /**
                 * Load edges by reading the data table
                 * @param {Array | DataSet | DataView} edges    The data containing the edges.
                 * @param {boolean} [doNotEmit=false]
                 * @private
                 */
              }, {
                key: "setData",
                value: function setData(edges) {
                  var _this3 = this;
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var oldEdgesData = this.body.data.edges;
                  if (edges instanceof DataSet || edges instanceof DataView) {
                    this.body.data.edges = edges;
                  } else if (Array.isArray(edges)) {
                    this.body.data.edges = new DataSet();
                    this.body.data.edges.add(edges);
                  } else if (!edges) {
                    this.body.data.edges = new DataSet();
                  } else {
                    throw new TypeError("Array or DataSet expected");
                  }
                  if (oldEdgesData) {
                    util.forEach(this.edgesListeners, function(callback, event) {
                      oldEdgesData.off(event, callback);
                    });
                  }
                  this.body.edges = {};
                  if (this.body.data.edges) {
                    util.forEach(this.edgesListeners, function(callback, event) {
                      _this3.body.data.edges.on(event, callback);
                    });
                    var ids = this.body.data.edges.getIds();
                    this.add(ids, true);
                  }
                  this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Add edges
                 * @param {number[] | string[]} ids
                 * @param {boolean} [doNotEmit=false]
                 * @private
                 */
              }, {
                key: "add",
                value: function add(ids) {
                  var doNotEmit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var edges = this.body.edges;
                  var edgesData = this.body.data.edges;
                  for (var i = 0; i < ids.length; i++) {
                    var id = ids[i];
                    var oldEdge = edges[id];
                    if (oldEdge) {
                      oldEdge.disconnect();
                    }
                    var data = edgesData.get(id, { "showInternalIds": true });
                    edges[id] = this.create(data);
                  }
                  this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                  if (doNotEmit === false) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Update existing edges, or create them when not yet existing
                 * @param {number[] | string[]} ids
                 * @private
                 */
              }, {
                key: "update",
                value: function update(ids) {
                  var edges = this.body.edges;
                  var edgesData = this.body.data.edges;
                  var dataChanged = false;
                  for (var i = 0; i < ids.length; i++) {
                    var id = ids[i];
                    var data = edgesData.get(id);
                    var edge = edges[id];
                    if (edge !== void 0) {
                      edge.disconnect();
                      dataChanged = edge.setOptions(data) || dataChanged;
                      edge.connect();
                    } else {
                      this.body.edges[id] = this.create(data);
                      dataChanged = true;
                    }
                  }
                  if (dataChanged === true) {
                    this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");
                    this.body.emitter.emit("_dataChanged");
                  } else {
                    this.body.emitter.emit("_dataUpdated");
                  }
                }
                /**
                 * Remove existing edges. Non existing ids will be ignored
                 * @param {number[] | string[]} ids
                 * @param {boolean} [emit=true]
                 * @private
                 */
              }, {
                key: "remove",
                value: function remove(ids) {
                  var emit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (ids.length === 0) return;
                  var edges = this.body.edges;
                  util.forEach(ids, function(id) {
                    var edge = edges[id];
                    if (edge !== void 0) {
                      edge.remove();
                    }
                  });
                  if (emit) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Refreshes Edge Handler
                 */
              }, {
                key: "refresh",
                value: function refresh() {
                  var _this4 = this;
                  util.forEach(this.body.edges, function(edge, edgeId) {
                    var data = _this4.body.data.edges._data[edgeId];
                    if (data !== void 0) {
                      edge.setOptions(data);
                    }
                  });
                }
                /**
                 *
                 * @param {Object} properties
                 * @returns {Edge}
                 */
              }, {
                key: "create",
                value: function create(properties) {
                  return new Edge(properties, this.body, this.options, this.defaultOptions);
                }
                /**
                 * Reconnect all edges
                 * @private
                 */
              }, {
                key: "reconnectEdges",
                value: function reconnectEdges() {
                  var id;
                  var nodes = this.body.nodes;
                  var edges = this.body.edges;
                  for (id in nodes) {
                    if (nodes.hasOwnProperty(id)) {
                      nodes[id].edges = [];
                    }
                  }
                  for (id in edges) {
                    if (edges.hasOwnProperty(id)) {
                      var edge = edges[id];
                      edge.from = null;
                      edge.to = null;
                      edge.connect();
                    }
                  }
                }
                /**
                 *
                 * @param {Edge.id} edgeId
                 * @returns {Array}
                 */
              }, {
                key: "getConnectedNodes",
                value: function getConnectedNodes(edgeId) {
                  var nodeList = [];
                  if (this.body.edges[edgeId] !== void 0) {
                    var edge = this.body.edges[edgeId];
                    if (edge.fromId !== void 0) {
                      nodeList.push(edge.fromId);
                    }
                    if (edge.toId !== void 0) {
                      nodeList.push(edge.toId);
                    }
                  }
                  return nodeList;
                }
                /**
                 * There is no direct relation between the nodes and the edges DataSet,
                 * so the right place to do call this is in the handler for event `_dataUpdated`.
                 */
              }, {
                key: "_updateState",
                value: function _updateState() {
                  this._addMissingEdges();
                  this._removeInvalidEdges();
                }
                /**
                 * Scan for missing nodes and remove corresponding edges, if any.
                 * @private
                 */
              }, {
                key: "_removeInvalidEdges",
                value: function _removeInvalidEdges() {
                  var _this5 = this;
                  var edgesToDelete = [];
                  util.forEach(this.body.edges, function(edge, id) {
                    var toNode = _this5.body.nodes[edge.toId];
                    var fromNode = _this5.body.nodes[edge.fromId];
                    if (toNode !== void 0 && toNode.isCluster === true || fromNode !== void 0 && fromNode.isCluster === true) {
                      return;
                    }
                    if (toNode === void 0 || fromNode === void 0) {
                      edgesToDelete.push(id);
                    }
                  });
                  this.remove(edgesToDelete, false);
                }
                /**
                 * add all edges from dataset that are not in the cached state
                 * @private
                 */
              }, {
                key: "_addMissingEdges",
                value: function _addMissingEdges() {
                  var edges = this.body.edges;
                  var edgesData = this.body.data.edges;
                  var addIds = [];
                  edgesData.forEach(function(edgeData, edgeId) {
                    var edge = edges[edgeId];
                    if (edge === void 0) {
                      addIds.push(edgeId);
                    }
                  });
                  this.add(addIds, true);
                }
              }]);
              return EdgesHandler2;
            }();
            exports2["default"] = EdgesHandler;
          },
          /* 215 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CubicBezierEdgeBase2 = __webpack_require__(216);
            var _CubicBezierEdgeBase3 = _interopRequireDefault(_CubicBezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CubicBezierEdge = function(_CubicBezierEdgeBase) {
              (0, _inherits3["default"])(CubicBezierEdge2, _CubicBezierEdgeBase);
              function CubicBezierEdge2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CubicBezierEdge2);
                return (0, _possibleConstructorReturn3["default"])(this, (CubicBezierEdge2.__proto__ || (0, _getPrototypeOf2["default"])(CubicBezierEdge2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(CubicBezierEdge2, [{
                key: "_line",
                value: function _line(ctx, values, viaNodes) {
                  var via1 = viaNodes[0];
                  var via2 = viaNodes[1];
                  this._bezierCurve(ctx, values, via1, via2);
                }
                /**
                 *
                 * @returns {Array.<{x: number, y: number}>}
                 * @private
                 */
              }, {
                key: "_getViaCoordinates",
                value: function _getViaCoordinates() {
                  var dx = this.from.x - this.to.x;
                  var dy = this.from.y - this.to.y;
                  var x1 = void 0, y1 = void 0, x2 = void 0, y2 = void 0;
                  var roundness = this.options.smooth.roundness;
                  if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === "horizontal") && this.options.smooth.forceDirection !== "vertical") {
                    y1 = this.from.y;
                    y2 = this.to.y;
                    x1 = this.from.x - roundness * dx;
                    x2 = this.to.x + roundness * dx;
                  } else {
                    y1 = this.from.y - roundness * dy;
                    y2 = this.to.y + roundness * dy;
                    x1 = this.from.x;
                    x2 = this.to.x;
                  }
                  return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
                }
                /**
                 *
                 * @returns {Array.<{x: number, y: number}>}
                 */
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
                /**
                 *
                 * @param {Node} nearNode
                 * @param {CanvasRenderingContext2D} ctx
                 * @returns {{x: number, y: number, t: number}}
                 * @private
                 */
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  return this._findBorderPositionBezier(nearNode, ctx);
                }
                /**
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @param {Node} via1
                 * @param {Node} via2
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  var _ref = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates(), _ref2 = (0, _slicedToArray3["default"])(_ref, 2), via1 = _ref2[0], via2 = _ref2[1];
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2);
                }
                /**
                 * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
                 * @param {number} percentage
                 * @param {{x: number, y: number}} [via1=this._getViaCoordinates()[0]]
                 * @param {{x: number, y: number}} [via2=this._getViaCoordinates()[1]]
                 * @returns {{x: number, y: number}}
                 * @private
                 */
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates(), _ref4 = (0, _slicedToArray3["default"])(_ref3, 2), via1 = _ref4[0], via2 = _ref4[1];
                  var t = percentage;
                  var vec = [];
                  vec[0] = Math.pow(1 - t, 3);
                  vec[1] = 3 * t * Math.pow(1 - t, 2);
                  vec[2] = 3 * Math.pow(t, 2) * (1 - t);
                  vec[3] = Math.pow(t, 3);
                  var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;
                  var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;
                  return { x, y };
                }
              }]);
              return CubicBezierEdge2;
            }(_CubicBezierEdgeBase3["default"]);
            exports2["default"] = CubicBezierEdge;
          },
          /* 216 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(75);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var CubicBezierEdgeBase = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(CubicBezierEdgeBase2, _BezierEdgeBase);
              function CubicBezierEdgeBase2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, CubicBezierEdgeBase2);
                return (0, _possibleConstructorReturn3["default"])(this, (CubicBezierEdgeBase2.__proto__ || (0, _getPrototypeOf2["default"])(CubicBezierEdgeBase2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(CubicBezierEdgeBase2, [{
                key: "_getDistanceToBezierEdge",
                value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via1, via2) {
                  var minDistance = 1e9;
                  var distance = void 0;
                  var i = void 0, t = void 0, x = void 0, y = void 0;
                  var lastX = x1;
                  var lastY = y1;
                  var vec = [0, 0, 0, 0];
                  for (i = 1; i < 10; i++) {
                    t = 0.1 * i;
                    vec[0] = Math.pow(1 - t, 3);
                    vec[1] = 3 * t * Math.pow(1 - t, 2);
                    vec[2] = 3 * Math.pow(t, 2) * (1 - t);
                    vec[3] = Math.pow(t, 3);
                    x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;
                    y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;
                    if (i > 0) {
                      distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);
                      minDistance = distance < minDistance ? distance : minDistance;
                    }
                    lastX = x;
                    lastY = y;
                  }
                  return minDistance;
                }
              }]);
              return CubicBezierEdgeBase2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = CubicBezierEdgeBase;
          },
          /* 217 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(75);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeDynamic = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(BezierEdgeDynamic2, _BezierEdgeBase);
              function BezierEdgeDynamic2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeDynamic2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeDynamic2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeDynamic2)).call(this, options, body, labelModule));
                _this._boundFunction = function() {
                  _this.positionBezierNode();
                };
                _this.body.emitter.on("_repositionBezierNodes", _this._boundFunction);
                return _this;
              }
              (0, _createClass3["default"])(BezierEdgeDynamic2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  var physicsChange = false;
                  if (this.options.physics !== options.physics) {
                    physicsChange = true;
                  }
                  this.options = options;
                  this.id = this.options.id;
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  this.setupSupportNode();
                  this.connect();
                  if (physicsChange === true) {
                    this.via.setOptions({ physics: this.options.physics });
                    this.positionBezierNode();
                  }
                }
                /**
                 * Connects an edge to node(s)
                 */
              }, {
                key: "connect",
                value: function connect() {
                  this.from = this.body.nodes[this.options.from];
                  this.to = this.body.nodes[this.options.to];
                  if (this.from === void 0 || this.to === void 0 || this.options.physics === false) {
                    this.via.setOptions({ physics: false });
                  } else {
                    if (this.from.id === this.to.id) {
                      this.via.setOptions({ physics: false });
                    } else {
                      this.via.setOptions({ physics: true });
                    }
                  }
                }
                /**
                 * remove the support nodes
                 * @returns {boolean}
                 */
              }, {
                key: "cleanup",
                value: function cleanup() {
                  this.body.emitter.off("_repositionBezierNodes", this._boundFunction);
                  if (this.via !== void 0) {
                    delete this.body.nodes[this.via.id];
                    this.via = void 0;
                    return true;
                  }
                  return false;
                }
                /**
                 * Bezier curves require an anchor point to calculate the smooth flow. These points are nodes. These nodes are invisible but
                 * are used for the force calculation.
                 *
                 * The changed data is not called, if needed, it is returned by the main edge constructor.
                 * @private
                 */
              }, {
                key: "setupSupportNode",
                value: function setupSupportNode() {
                  if (this.via === void 0) {
                    var nodeId = "edgeId:" + this.id;
                    var node = this.body.functions.createNode({
                      id: nodeId,
                      shape: "circle",
                      physics: true,
                      hidden: true
                    });
                    this.body.nodes[nodeId] = node;
                    this.via = node;
                    this.via.parentEdgeId = this.id;
                    this.positionBezierNode();
                  }
                }
                /**
                 * Positions bezier node
                 */
              }, {
                key: "positionBezierNode",
                value: function positionBezierNode() {
                  if (this.via !== void 0 && this.from !== void 0 && this.to !== void 0) {
                    this.via.x = 0.5 * (this.from.x + this.to.x);
                    this.via.y = 0.5 * (this.from.y + this.to.y);
                  } else if (this.via !== void 0) {
                    this.via.x = 0;
                    this.via.y = 0;
                  }
                }
                /**
                 * Draw a line between two nodes
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {{toArrow: boolean, toArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), toArrowType: *, middleArrow: boolean, middleArrowScale: (number|allOptions.edges.arrows.middle.scaleFactor|{number}|Array), middleArrowType: (allOptions.edges.arrows.middle.type|{string}|string|*), fromArrow: boolean, fromArrowScale: (allOptions.edges.arrows.to.scaleFactor|{number}|allOptions.edges.arrows.middle.scaleFactor|allOptions.edges.arrows.from.scaleFactor|Array|number), fromArrowType: *, arrowStrikethrough: (*|boolean|allOptions.edges.arrowStrikethrough|{boolean}), color: undefined, inheritsColor: (string|string|string|allOptions.edges.color.inherit|{string, boolean}|Array|*), opacity: *, hidden: *, length: *, shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *, dashes: (*|boolean|Array|allOptions.edges.dashes|{boolean, array}), width: *}} values
                 * @param {Node} viaNode
                 * @private
                 */
              }, {
                key: "_line",
                value: function _line(ctx, values, viaNode) {
                  this._bezierCurve(ctx, values, viaNode);
                }
                /**
                 *
                 * @returns {Node|undefined|*|{index, line, column}}
                 */
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this.via;
                }
                /**
                 * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
                 *
                 * @param {number} percentage
                 * @param {Node} viaNode
                 * @returns {{x: number, y: number}}
                 * @private
                 */
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.via;
                  var t = percentage;
                  var x = void 0, y = void 0;
                  if (this.from === this.to) {
                    var _getCircleData = this._getCircleData(this.from), _getCircleData2 = (0, _slicedToArray3["default"])(_getCircleData, 3), cx = _getCircleData2[0], cy = _getCircleData2[1], cr = _getCircleData2[2];
                    var a = 2 * Math.PI * (1 - t);
                    x = cx + cr * Math.sin(a);
                    y = cy + cr - cr * (1 - Math.cos(a));
                  } else {
                    x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
                    y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
                  }
                  return { x, y };
                }
                /**
                 *
                 * @param {Node} nearNode
                 * @param {CanvasRenderingContext2D} ctx
                 * @returns {*}
                 * @private
                 */
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  return this._findBorderPositionBezier(nearNode, ctx, this.via);
                }
                /**
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);
                }
              }]);
              return BezierEdgeDynamic2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = BezierEdgeDynamic;
          },
          /* 218 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BezierEdgeBase2 = __webpack_require__(75);
            var _BezierEdgeBase3 = _interopRequireDefault(_BezierEdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BezierEdgeStatic = function(_BezierEdgeBase) {
              (0, _inherits3["default"])(BezierEdgeStatic2, _BezierEdgeBase);
              function BezierEdgeStatic2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, BezierEdgeStatic2);
                return (0, _possibleConstructorReturn3["default"])(this, (BezierEdgeStatic2.__proto__ || (0, _getPrototypeOf2["default"])(BezierEdgeStatic2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(BezierEdgeStatic2, [{
                key: "_line",
                value: function _line(ctx, values, viaNode) {
                  this._bezierCurve(ctx, values, viaNode);
                }
                /**
                 *
                 * @returns {Array.<{x: number, y: number}>}
                 */
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return this._getViaCoordinates();
                }
                /**
                 * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
                 * @returns {{x: undefined, y: undefined}}
                 * @private
                 */
              }, {
                key: "_getViaCoordinates",
                value: function _getViaCoordinates() {
                  var xVia = void 0;
                  var yVia = void 0;
                  var factor = this.options.smooth.roundness;
                  var type = this.options.smooth.type;
                  var dx = Math.abs(this.from.x - this.to.x);
                  var dy = Math.abs(this.from.y - this.to.y);
                  if (type === "discrete" || type === "diagonalCross") {
                    var stepX = void 0;
                    var stepY = void 0;
                    if (dx <= dy) {
                      stepX = stepY = factor * dy;
                    } else {
                      stepX = stepY = factor * dx;
                    }
                    if (this.from.x > this.to.x) stepX = -stepX;
                    if (this.from.y >= this.to.y) stepY = -stepY;
                    xVia = this.from.x + stepX;
                    yVia = this.from.y + stepY;
                    if (type === "discrete") {
                      if (dx <= dy) {
                        xVia = dx < factor * dy ? this.from.x : xVia;
                      } else {
                        yVia = dy < factor * dx ? this.from.y : yVia;
                      }
                    }
                  } else if (type === "straightCross") {
                    var _stepX = (1 - factor) * dx;
                    var _stepY = (1 - factor) * dy;
                    if (dx <= dy) {
                      _stepX = 0;
                      if (this.from.y < this.to.y) _stepY = -_stepY;
                    } else {
                      if (this.from.x < this.to.x) _stepX = -_stepX;
                      _stepY = 0;
                    }
                    xVia = this.to.x + _stepX;
                    yVia = this.to.y + _stepY;
                  } else if (type === "horizontal") {
                    var _stepX2 = (1 - factor) * dx;
                    if (this.from.x < this.to.x) _stepX2 = -_stepX2;
                    xVia = this.to.x + _stepX2;
                    yVia = this.from.y;
                  } else if (type === "vertical") {
                    var _stepY2 = (1 - factor) * dy;
                    if (this.from.y < this.to.y) _stepY2 = -_stepY2;
                    xVia = this.from.x;
                    yVia = this.to.y + _stepY2;
                  } else if (type === "curvedCW") {
                    dx = this.to.x - this.from.x;
                    dy = this.from.y - this.to.y;
                    var radius = Math.sqrt(dx * dx + dy * dy);
                    var pi = Math.PI;
                    var originalAngle = Math.atan2(dy, dx);
                    var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);
                    xVia = this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle);
                    yVia = this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle);
                  } else if (type === "curvedCCW") {
                    dx = this.to.x - this.from.x;
                    dy = this.from.y - this.to.y;
                    var _radius = Math.sqrt(dx * dx + dy * dy);
                    var _pi = Math.PI;
                    var _originalAngle = Math.atan2(dy, dx);
                    var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);
                    xVia = this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle);
                    yVia = this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle);
                  } else {
                    var _stepX3 = void 0;
                    var _stepY3 = void 0;
                    if (dx <= dy) {
                      _stepX3 = _stepY3 = factor * dy;
                    } else {
                      _stepX3 = _stepY3 = factor * dx;
                    }
                    if (this.from.x > this.to.x) _stepX3 = -_stepX3;
                    if (this.from.y >= this.to.y) _stepY3 = -_stepY3;
                    xVia = this.from.x + _stepX3;
                    yVia = this.from.y + _stepY3;
                    if (dx <= dy) {
                      if (this.from.x <= this.to.x) {
                        xVia = this.to.x < xVia ? this.to.x : xVia;
                      } else {
                        xVia = this.to.x > xVia ? this.to.x : xVia;
                      }
                    } else {
                      if (this.from.y >= this.to.y) {
                        yVia = this.to.y > yVia ? this.to.y : yVia;
                      } else {
                        yVia = this.to.y < yVia ? this.to.y : yVia;
                      }
                    }
                  }
                  return { x: xVia, y: yVia };
                }
                /**
                 *
                 * @param {Node} nearNode
                 * @param {CanvasRenderingContext2D} ctx
                 * @param {Object} options
                 * @returns {*}
                 * @private
                 */
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  return this._findBorderPositionBezier(nearNode, ctx, options.via);
                }
                /**
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @param {Node} viaNode
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  var viaNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this._getViaCoordinates();
                  return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);
                }
                /**
                 * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
                 * @param {number} percentage
                 * @param {Node} viaNode
                 * @returns {{x: number, y: number}}
                 * @private
                 */
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  var viaNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getViaCoordinates();
                  var t = percentage;
                  var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;
                  var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;
                  return { x, y };
                }
              }]);
              return BezierEdgeStatic2;
            }(_BezierEdgeBase3["default"]);
            exports2["default"] = BezierEdgeStatic;
          },
          /* 219 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _EdgeBase2 = __webpack_require__(118);
            var _EdgeBase3 = _interopRequireDefault(_EdgeBase2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var StraightEdge = function(_EdgeBase) {
              (0, _inherits3["default"])(StraightEdge2, _EdgeBase);
              function StraightEdge2(options, body, labelModule) {
                (0, _classCallCheck3["default"])(this, StraightEdge2);
                return (0, _possibleConstructorReturn3["default"])(this, (StraightEdge2.__proto__ || (0, _getPrototypeOf2["default"])(StraightEdge2)).call(this, options, body, labelModule));
              }
              (0, _createClass3["default"])(StraightEdge2, [{
                key: "_line",
                value: function _line(ctx, values) {
                  ctx.beginPath();
                  ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
                  ctx.lineTo(this.toPoint.x, this.toPoint.y);
                  this.enableShadow(ctx, values);
                  ctx.stroke();
                  this.disableShadow(ctx, values);
                }
                /**
                 *
                 * @returns {undefined}
                 */
              }, {
                key: "getViaNode",
                value: function getViaNode() {
                  return void 0;
                }
                /**
                 * Combined function of pointOnLine and pointOnBezier. This gives the coordinates of a point on the line at a certain percentage of the way
                 *
                 * @param {number} percentage
                 * @returns {{x: number, y: number}}
                 * @private
                 */
              }, {
                key: "getPoint",
                value: function getPoint(percentage) {
                  return {
                    x: (1 - percentage) * this.fromPoint.x + percentage * this.toPoint.x,
                    y: (1 - percentage) * this.fromPoint.y + percentage * this.toPoint.y
                  };
                }
                /**
                 *
                 * @param {Node} nearNode
                 * @param {CanvasRenderingContext2D} ctx
                 * @returns {{x: number, y: number}}
                 * @private
                 */
              }, {
                key: "_findBorderPosition",
                value: function _findBorderPosition(nearNode, ctx) {
                  var node1 = this.to;
                  var node2 = this.from;
                  if (nearNode.id === this.from.id) {
                    node1 = this.from;
                    node2 = this.to;
                  }
                  var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);
                  var dx = node1.x - node2.x;
                  var dy = node1.y - node2.y;
                  var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);
                  var toBorderDist = nearNode.distanceToBorder(ctx, angle);
                  var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;
                  var borderPos = {};
                  borderPos.x = (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x;
                  borderPos.y = (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y;
                  return borderPos;
                }
                /**
                 *
                 * @param {number} x1
                 * @param {number} y1
                 * @param {number} x2
                 * @param {number} y2
                 * @param {number} x3
                 * @param {number} y3
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getDistanceToEdge",
                value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {
                  return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);
                }
              }]);
              return StraightEdge2;
            }(_EdgeBase3["default"]);
            exports2["default"] = StraightEdge;
          },
          /* 220 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var BarnesHutSolver = __webpack_require__(120)["default"];
            var Repulsion = __webpack_require__(221)["default"];
            var HierarchicalRepulsion = __webpack_require__(222)["default"];
            var SpringSolver = __webpack_require__(223)["default"];
            var HierarchicalSpringSolver = __webpack_require__(224)["default"];
            var CentralGravitySolver = __webpack_require__(121)["default"];
            var ForceAtlas2BasedRepulsionSolver = __webpack_require__(225)["default"];
            var ForceAtlas2BasedCentralGravitySolver = __webpack_require__(226)["default"];
            var util = __webpack_require__(2);
            var EndPoints = __webpack_require__(119)["default"];
            var PhysicsEngine = function() {
              function PhysicsEngine2(body) {
                (0, _classCallCheck3["default"])(this, PhysicsEngine2);
                this.body = body;
                this.physicsBody = { physicsNodeIndices: [], physicsEdgeIndices: [], forces: {}, velocities: {} };
                this.physicsEnabled = true;
                this.simulationInterval = 1e3 / 60;
                this.requiresTimeout = true;
                this.previousStates = {};
                this.referenceState = {};
                this.freezeCache = {};
                this.renderTimer = void 0;
                this.adaptiveTimestep = false;
                this.adaptiveTimestepEnabled = false;
                this.adaptiveCounter = 0;
                this.adaptiveInterval = 3;
                this.stabilized = false;
                this.startedStabilization = false;
                this.stabilizationIterations = 0;
                this.ready = false;
                this.options = {};
                this.defaultOptions = {
                  enabled: true,
                  barnesHut: {
                    theta: 0.5,
                    gravitationalConstant: -2e3,
                    centralGravity: 0.3,
                    springLength: 95,
                    springConstant: 0.04,
                    damping: 0.09,
                    avoidOverlap: 0
                  },
                  forceAtlas2Based: {
                    theta: 0.5,
                    gravitationalConstant: -50,
                    centralGravity: 0.01,
                    springConstant: 0.08,
                    springLength: 100,
                    damping: 0.4,
                    avoidOverlap: 0
                  },
                  repulsion: {
                    centralGravity: 0.2,
                    springLength: 200,
                    springConstant: 0.05,
                    nodeDistance: 100,
                    damping: 0.09,
                    avoidOverlap: 0
                  },
                  hierarchicalRepulsion: {
                    centralGravity: 0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 120,
                    damping: 0.09
                  },
                  maxVelocity: 50,
                  minVelocity: 0.75,
                  // px/s
                  solver: "barnesHut",
                  stabilization: {
                    enabled: true,
                    iterations: 1e3,
                    // maximum number of iteration to stabilize
                    updateInterval: 50,
                    onlyDynamicEdges: false,
                    fit: true
                  },
                  timestep: 0.5,
                  adaptiveTimestep: true
                };
                util.extend(this.options, this.defaultOptions);
                this.timestep = 0.5;
                this.layoutFailed = false;
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(PhysicsEngine2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("initPhysics", function() {
                    _this.initPhysics();
                  });
                  this.body.emitter.on("_layoutFailed", function() {
                    _this.layoutFailed = true;
                  });
                  this.body.emitter.on("resetPhysics", function() {
                    _this.stopSimulation();
                    _this.ready = false;
                  });
                  this.body.emitter.on("disablePhysics", function() {
                    _this.physicsEnabled = false;
                    _this.stopSimulation();
                  });
                  this.body.emitter.on("restorePhysics", function() {
                    _this.setOptions(_this.options);
                    if (_this.ready === true) {
                      _this.startSimulation();
                    }
                  });
                  this.body.emitter.on("startSimulation", function() {
                    if (_this.ready === true) {
                      _this.startSimulation();
                    }
                  });
                  this.body.emitter.on("stopSimulation", function() {
                    _this.stopSimulation();
                  });
                  this.body.emitter.on("destroy", function() {
                    _this.stopSimulation(false);
                    _this.body.emitter.off();
                  });
                  this.body.emitter.on("_dataChanged", function() {
                    _this.updatePhysicsData();
                  });
                }
                /**
                 * set the physics options
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    if (options === false) {
                      this.options.enabled = false;
                      this.physicsEnabled = false;
                      this.stopSimulation();
                    } else if (options === true) {
                      this.options.enabled = true;
                      this.physicsEnabled = true;
                      this.startSimulation();
                    } else {
                      this.physicsEnabled = true;
                      util.selectiveNotDeepExtend(["stabilization"], this.options, options);
                      util.mergeOptions(this.options, options, "stabilization");
                      if (options.enabled === void 0) {
                        this.options.enabled = true;
                      }
                      if (this.options.enabled === false) {
                        this.physicsEnabled = false;
                        this.stopSimulation();
                      }
                      this.timestep = this.options.timestep;
                    }
                  }
                  this.init();
                }
                /**
                 * configure the engine.
                 */
              }, {
                key: "init",
                value: function init() {
                  var options;
                  if (this.options.solver === "forceAtlas2Based") {
                    options = this.options.forceAtlas2Based;
                    this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);
                  } else if (this.options.solver === "repulsion") {
                    options = this.options.repulsion;
                    this.nodesSolver = new Repulsion(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  } else if (this.options.solver === "hierarchicalRepulsion") {
                    options = this.options.hierarchicalRepulsion;
                    this.nodesSolver = new HierarchicalRepulsion(this.body, this.physicsBody, options);
                    this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  } else {
                    options = this.options.barnesHut;
                    this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);
                    this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);
                    this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);
                  }
                  this.modelOptions = options;
                }
                /**
                 * initialize the engine
                 */
              }, {
                key: "initPhysics",
                value: function initPhysics() {
                  if (this.physicsEnabled === true && this.options.enabled === true) {
                    if (this.options.stabilization.enabled === true) {
                      this.stabilize();
                    } else {
                      this.stabilized = false;
                      this.ready = true;
                      this.body.emitter.emit("fit", {}, this.layoutFailed);
                      this.startSimulation();
                    }
                  } else {
                    this.ready = true;
                    this.body.emitter.emit("fit");
                  }
                }
                /**
                 * Start the simulation
                 */
              }, {
                key: "startSimulation",
                value: function startSimulation() {
                  if (this.physicsEnabled === true && this.options.enabled === true) {
                    this.stabilized = false;
                    this.adaptiveTimestep = false;
                    this.body.emitter.emit("_resizeNodes");
                    if (this.viewFunction === void 0) {
                      this.viewFunction = this.simulationStep.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                      this.body.emitter.emit("_startRendering");
                    }
                  } else {
                    this.body.emitter.emit("_redraw");
                  }
                }
                /**
                 * Stop the simulation, force stabilization.
                 * @param {boolean} [emit=true]
                 */
              }, {
                key: "stopSimulation",
                value: function stopSimulation() {
                  var emit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                  this.stabilized = true;
                  if (emit === true) {
                    this._emitStabilized();
                  }
                  if (this.viewFunction !== void 0) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.viewFunction = void 0;
                    if (emit === true) {
                      this.body.emitter.emit("_stopRendering");
                    }
                  }
                }
                /**
                 * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
                 *
                 */
              }, {
                key: "simulationStep",
                value: function simulationStep() {
                  var startTime = Date.now();
                  this.physicsTick();
                  var physicsTime = Date.now() - startTime;
                  if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {
                    this.physicsTick();
                    this.runDoubleSpeed = true;
                  }
                  if (this.stabilized === true) {
                    this.stopSimulation();
                  }
                }
                /**
                 * trigger the stabilized event.
                 *
                 * @param {number} [amountOfIterations=this.stabilizationIterations]
                 * @private
                 */
              }, {
                key: "_emitStabilized",
                value: function _emitStabilized() {
                  var _this2 = this;
                  var amountOfIterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.stabilizationIterations;
                  if (this.stabilizationIterations > 1 || this.startedStabilization === true) {
                    setTimeout(function() {
                      _this2.body.emitter.emit("stabilized", { iterations: amountOfIterations });
                      _this2.startedStabilization = false;
                      _this2.stabilizationIterations = 0;
                    }, 0);
                  }
                }
                /**
                 * Calculate the forces for one physics iteration and move the nodes.
                 * @private
                 */
              }, {
                key: "physicsStep",
                value: function physicsStep() {
                  this.gravitySolver.solve();
                  this.nodesSolver.solve();
                  this.edgesSolver.solve();
                  this.moveNodes();
                }
                /**
                 * Make dynamic adjustments to the timestep, based on current state.
                 *
                 * Helper function for physicsTick().
                 * @private
                 */
              }, {
                key: "adjustTimeStep",
                value: function adjustTimeStep() {
                  var factor = 1.2;
                  if (this._evaluateStepQuality() === true) {
                    this.timestep = factor * this.timestep;
                  } else {
                    if (this.timestep / factor < this.options.timestep) {
                      this.timestep = this.options.timestep;
                    } else {
                      this.adaptiveCounter = -1;
                      this.timestep = Math.max(this.options.timestep, this.timestep / factor);
                    }
                  }
                }
                /**
                 * A single simulation step (or 'tick') in the physics simulation
                 *
                 * @private
                 */
              }, {
                key: "physicsTick",
                value: function physicsTick() {
                  this._startStabilizing();
                  if (this.stabilized === true) return;
                  if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {
                    var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;
                    if (doAdaptive) {
                      this.timestep = 2 * this.timestep;
                      this.physicsStep();
                      this.revert();
                      this.timestep = 0.5 * this.timestep;
                      this.physicsStep();
                      this.physicsStep();
                      this.adjustTimeStep();
                    } else {
                      this.physicsStep();
                    }
                    this.adaptiveCounter += 1;
                  } else {
                    this.timestep = this.options.timestep;
                    this.physicsStep();
                  }
                  if (this.stabilized === true) this.revert();
                  this.stabilizationIterations++;
                }
                /**
                 * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
                 *
                 * @private
                 */
              }, {
                key: "updatePhysicsData",
                value: function updatePhysicsData() {
                  this.physicsBody.forces = {};
                  this.physicsBody.physicsNodeIndices = [];
                  this.physicsBody.physicsEdgeIndices = [];
                  var nodes = this.body.nodes;
                  var edges = this.body.edges;
                  for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                      if (nodes[nodeId].options.physics === true) {
                        this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);
                      }
                    }
                  }
                  for (var edgeId in edges) {
                    if (edges.hasOwnProperty(edgeId)) {
                      if (edges[edgeId].options.physics === true) {
                        this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);
                      }
                    }
                  }
                  for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
                    var _nodeId = this.physicsBody.physicsNodeIndices[i];
                    this.physicsBody.forces[_nodeId] = { x: 0, y: 0 };
                    if (this.physicsBody.velocities[_nodeId] === void 0) {
                      this.physicsBody.velocities[_nodeId] = { x: 0, y: 0 };
                    }
                  }
                  for (var _nodeId2 in this.physicsBody.velocities) {
                    if (nodes[_nodeId2] === void 0) {
                      delete this.physicsBody.velocities[_nodeId2];
                    }
                  }
                }
                /**
                 * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
                 */
              }, {
                key: "revert",
                value: function revert() {
                  var nodeIds = (0, _keys2["default"])(this.previousStates);
                  var nodes = this.body.nodes;
                  var velocities = this.physicsBody.velocities;
                  this.referenceState = {};
                  for (var i = 0; i < nodeIds.length; i++) {
                    var nodeId = nodeIds[i];
                    if (nodes[nodeId] !== void 0) {
                      if (nodes[nodeId].options.physics === true) {
                        this.referenceState[nodeId] = {
                          positions: { x: nodes[nodeId].x, y: nodes[nodeId].y }
                        };
                        velocities[nodeId].x = this.previousStates[nodeId].vx;
                        velocities[nodeId].y = this.previousStates[nodeId].vy;
                        nodes[nodeId].x = this.previousStates[nodeId].x;
                        nodes[nodeId].y = this.previousStates[nodeId].y;
                      }
                    } else {
                      delete this.previousStates[nodeId];
                    }
                  }
                }
                /**
                 * This compares the reference state to the current state
                 *
                 * @returns {boolean}
                 * @private
                 */
              }, {
                key: "_evaluateStepQuality",
                value: function _evaluateStepQuality() {
                  var dx = void 0, dy = void 0, dpos = void 0;
                  var nodes = this.body.nodes;
                  var reference = this.referenceState;
                  var posThreshold = 0.3;
                  for (var nodeId in this.referenceState) {
                    if (this.referenceState.hasOwnProperty(nodeId) && nodes[nodeId] !== void 0) {
                      dx = nodes[nodeId].x - reference[nodeId].positions.x;
                      dy = nodes[nodeId].y - reference[nodeId].positions.y;
                      dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                      if (dpos > posThreshold) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                /**
                 * move the nodes one timestep and check if they are stabilized
                 */
              }, {
                key: "moveNodes",
                value: function moveNodes() {
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var maxNodeVelocity = 0;
                  var averageNodeVelocity = 0;
                  var velocityAdaptiveThreshold = 5;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    var nodeVelocity = this._performStep(nodeId);
                    maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);
                    averageNodeVelocity += nodeVelocity;
                  }
                  this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;
                  this.stabilized = maxNodeVelocity < this.options.minVelocity;
                }
                /**
                 * Calculate new velocity for a coordinate direction
                 *
                 * @param {number} v  velocity for current coordinate
                 * @param {number} f  regular force for current coordinate
                 * @param {number} m  mass of current node
                 * @returns {number} new velocity for current coordinate
                 * @private
                 */
              }, {
                key: "calculateComponentVelocity",
                value: function calculateComponentVelocity(v, f, m) {
                  var df = this.modelOptions.damping * v;
                  var a = (f - df) / m;
                  v += a * this.timestep;
                  var maxV = this.options.maxVelocity || 1e9;
                  if (Math.abs(v) > maxV) {
                    v = v > 0 ? maxV : -maxV;
                  }
                  return v;
                }
                /**
                 * Perform the actual step
                 *
                 * @param {Node.id} nodeId
                 * @returns {number} the new velocity of given node
                 * @private
                 */
              }, {
                key: "_performStep",
                value: function _performStep(nodeId) {
                  var node = this.body.nodes[nodeId];
                  var force = this.physicsBody.forces[nodeId];
                  var velocity = this.physicsBody.velocities[nodeId];
                  this.previousStates[nodeId] = { x: node.x, y: node.y, vx: velocity.x, vy: velocity.y };
                  if (node.options.fixed.x === false) {
                    velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);
                    node.x += velocity.x * this.timestep;
                  } else {
                    force.x = 0;
                    velocity.x = 0;
                  }
                  if (node.options.fixed.y === false) {
                    velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);
                    node.y += velocity.y * this.timestep;
                  } else {
                    force.y = 0;
                    velocity.y = 0;
                  }
                  var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));
                  return totalVelocity;
                }
                /**
                 * When initializing and stabilizing, we can freeze nodes with a predefined position.
                 * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
                 *
                 * @private
                 */
              }, {
                key: "_freezeNodes",
                value: function _freezeNodes() {
                  var nodes = this.body.nodes;
                  for (var id in nodes) {
                    if (nodes.hasOwnProperty(id)) {
                      if (nodes[id].x && nodes[id].y) {
                        var fixed = nodes[id].options.fixed;
                        this.freezeCache[id] = { x: fixed.x, y: fixed.y };
                        fixed.x = true;
                        fixed.y = true;
                      }
                    }
                  }
                }
                /**
                 * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
                 *
                 * @private
                 */
              }, {
                key: "_restoreFrozenNodes",
                value: function _restoreFrozenNodes() {
                  var nodes = this.body.nodes;
                  for (var id in nodes) {
                    if (nodes.hasOwnProperty(id)) {
                      if (this.freezeCache[id] !== void 0) {
                        nodes[id].options.fixed.x = this.freezeCache[id].x;
                        nodes[id].options.fixed.y = this.freezeCache[id].y;
                      }
                    }
                  }
                  this.freezeCache = {};
                }
                /**
                 * Find a stable position for all nodes
                 *
                 * @param {number} [iterations=this.options.stabilization.iterations]
                 */
              }, {
                key: "stabilize",
                value: function stabilize() {
                  var _this3 = this;
                  var iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.stabilization.iterations;
                  if (typeof iterations !== "number") {
                    iterations = this.options.stabilization.iterations;
                    console.log("The stabilize method needs a numeric amount of iterations. Switching to default: ", iterations);
                  }
                  if (this.physicsBody.physicsNodeIndices.length === 0) {
                    this.ready = true;
                    return;
                  }
                  this.adaptiveTimestep = this.options.adaptiveTimestep;
                  this.body.emitter.emit("_resizeNodes");
                  this.stopSimulation();
                  this.stabilized = false;
                  this.body.emitter.emit("_blockRedraw");
                  this.targetIterations = iterations;
                  if (this.options.stabilization.onlyDynamicEdges === true) {
                    this._freezeNodes();
                  }
                  this.stabilizationIterations = 0;
                  setTimeout(function() {
                    return _this3._stabilizationBatch();
                  }, 0);
                }
                /**
                 * If not already stabilizing, start it and emit a start event.
                 *
                 * @returns {boolean} true if stabilization started with this call
                 * @private
                 */
              }, {
                key: "_startStabilizing",
                value: function _startStabilizing() {
                  if (this.startedStabilization === true) return false;
                  this.body.emitter.emit("startStabilizing");
                  this.startedStabilization = true;
                  return true;
                }
                /**
                 * One batch of stabilization
                 * @private
                 */
              }, {
                key: "_stabilizationBatch",
                value: function _stabilizationBatch() {
                  var _this4 = this;
                  var running = function running2() {
                    return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;
                  };
                  var sendProgress = function sendProgress2() {
                    _this4.body.emitter.emit("stabilizationProgress", {
                      iterations: _this4.stabilizationIterations,
                      total: _this4.targetIterations
                    });
                  };
                  if (this._startStabilizing()) {
                    sendProgress();
                  }
                  var count = 0;
                  while (running() && count < this.options.stabilization.updateInterval) {
                    this.physicsTick();
                    count++;
                  }
                  sendProgress();
                  if (running()) {
                    setTimeout(this._stabilizationBatch.bind(this), 0);
                  } else {
                    this._finalizeStabilization();
                  }
                }
                /**
                 * Wrap up the stabilization, fit and emit the events.
                 * @private
                 */
              }, {
                key: "_finalizeStabilization",
                value: function _finalizeStabilization() {
                  this.body.emitter.emit("_allowRedraw");
                  if (this.options.stabilization.fit === true) {
                    this.body.emitter.emit("fit");
                  }
                  if (this.options.stabilization.onlyDynamicEdges === true) {
                    this._restoreFrozenNodes();
                  }
                  this.body.emitter.emit("stabilizationIterationsDone");
                  this.body.emitter.emit("_requestRedraw");
                  if (this.stabilized === true) {
                    this._emitStabilized();
                  } else {
                    this.startSimulation();
                  }
                  this.ready = true;
                }
                //---------------------------  DEBUGGING BELOW  ---------------------------//
                /**
                 * Debug function that display arrows for the forces currently active in the network.
                 *
                 * Use this when debugging only.
                 *
                 * @param {CanvasRenderingContext2D} ctx
                 * @private
                 */
              }, {
                key: "_drawForces",
                value: function _drawForces(ctx) {
                  for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {
                    var index = this.physicsBody.physicsNodeIndices[i];
                    var node = this.body.nodes[index];
                    var force = this.physicsBody.forces[index];
                    var factor = 20;
                    var colorFactor = 0.03;
                    var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));
                    var size = Math.min(Math.max(5, forceSize), 15);
                    var arrowSize = 3 * size;
                    var color = util.HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);
                    var point = {
                      x: node.x + factor * force.x,
                      y: node.y + factor * force.y
                    };
                    ctx.lineWidth = size;
                    ctx.strokeStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(point.x, point.y);
                    ctx.stroke();
                    var angle = Math.atan2(force.y, force.x);
                    ctx.fillStyle = color;
                    EndPoints.draw(ctx, { type: "arrow", point, angle, length: arrowSize });
                    ctx.fill();
                  }
                }
              }]);
              return PhysicsEngine2;
            }();
            exports2["default"] = PhysicsEngine;
          },
          /* 221 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var RepulsionSolver = function() {
              function RepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, RepulsionSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(RepulsionSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 * Calculate the forces the nodes apply on each other based on a repulsion field.
                 * This field is linearly approximated.
                 *
                 * @private
                 */
              }, {
                key: "solve",
                value: function solve() {
                  var dx, dy, distance, fx, fy, repulsingForce, node1, node2;
                  var nodes = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  var nodeDistance = this.options.nodeDistance;
                  var a = -2 / 3 / nodeDistance;
                  var b = 4 / 3;
                  for (var i = 0; i < nodeIndices.length - 1; i++) {
                    node1 = nodes[nodeIndices[i]];
                    for (var j = i + 1; j < nodeIndices.length; j++) {
                      node2 = nodes[nodeIndices[j]];
                      dx = node2.x - node1.x;
                      dy = node2.y - node1.y;
                      distance = Math.sqrt(dx * dx + dy * dy);
                      if (distance === 0) {
                        distance = 0.1 * Math.random();
                        dx = distance;
                      }
                      if (distance < 2 * nodeDistance) {
                        if (distance < 0.5 * nodeDistance) {
                          repulsingForce = 1;
                        } else {
                          repulsingForce = a * distance + b;
                        }
                        repulsingForce = repulsingForce / distance;
                        fx = dx * repulsingForce;
                        fy = dy * repulsingForce;
                        forces[node1.id].x -= fx;
                        forces[node1.id].y -= fy;
                        forces[node2.id].x += fx;
                        forces[node2.id].y += fy;
                      }
                    }
                  }
                }
              }]);
              return RepulsionSolver2;
            }();
            exports2["default"] = RepulsionSolver;
          },
          /* 222 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var HierarchicalRepulsionSolver = function() {
              function HierarchicalRepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, HierarchicalRepulsionSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(HierarchicalRepulsionSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 * Calculate the forces the nodes apply on each other based on a repulsion field.
                 * This field is linearly approximated.
                 *
                 * @private
                 */
              }, {
                key: "solve",
                value: function solve() {
                  var dx, dy, distance, fx, fy, repulsingForce, node1, node2, i, j;
                  var nodes = this.body.nodes;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  var nodeDistance = this.options.nodeDistance;
                  for (i = 0; i < nodeIndices.length - 1; i++) {
                    node1 = nodes[nodeIndices[i]];
                    for (j = i + 1; j < nodeIndices.length; j++) {
                      node2 = nodes[nodeIndices[j]];
                      if (node1.level === node2.level) {
                        dx = node2.x - node1.x;
                        dy = node2.y - node1.y;
                        distance = Math.sqrt(dx * dx + dy * dy);
                        var steepness = 0.05;
                        if (distance < nodeDistance) {
                          repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * nodeDistance, 2);
                        } else {
                          repulsingForce = 0;
                        }
                        if (distance === 0) {
                          distance = 0.01;
                        } else {
                          repulsingForce = repulsingForce / distance;
                        }
                        fx = dx * repulsingForce;
                        fy = dy * repulsingForce;
                        forces[node1.id].x -= fx;
                        forces[node1.id].y -= fy;
                        forces[node2.id].x += fx;
                        forces[node2.id].y += fy;
                      }
                    }
                  }
                }
              }]);
              return HierarchicalRepulsionSolver2;
            }();
            exports2["default"] = HierarchicalRepulsionSolver;
          },
          /* 223 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var SpringSolver = function() {
              function SpringSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, SpringSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(SpringSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 * This function calculates the springforces on the nodes, accounting for the support nodes.
                 *
                 * @private
                 */
              }, {
                key: "solve",
                value: function solve() {
                  var edgeLength = void 0, edge = void 0;
                  var edgeIndices = this.physicsBody.physicsEdgeIndices;
                  var edges = this.body.edges;
                  var node1 = void 0, node2 = void 0, node3 = void 0;
                  for (var i = 0; i < edgeIndices.length; i++) {
                    edge = edges[edgeIndices[i]];
                    if (edge.connected === true && edge.toId !== edge.fromId) {
                      if (this.body.nodes[edge.toId] !== void 0 && this.body.nodes[edge.fromId] !== void 0) {
                        if (edge.edgeType.via !== void 0) {
                          edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
                          node1 = edge.to;
                          node2 = edge.edgeType.via;
                          node3 = edge.from;
                          this._calculateSpringForce(node1, node2, 0.5 * edgeLength);
                          this._calculateSpringForce(node2, node3, 0.5 * edgeLength);
                        } else {
                          edgeLength = edge.options.length === void 0 ? this.options.springLength * 1.5 : edge.options.length;
                          this._calculateSpringForce(edge.from, edge.to, edgeLength);
                        }
                      }
                    }
                  }
                }
                /**
                 * This is the code actually performing the calculation for the function above.
                 *
                 * @param {Node} node1
                 * @param {Node} node2
                 * @param {number} edgeLength
                 * @private
                 */
              }, {
                key: "_calculateSpringForce",
                value: function _calculateSpringForce(node1, node2, edgeLength) {
                  var dx = node1.x - node2.x;
                  var dy = node1.y - node2.y;
                  var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);
                  var springForce = this.options.springConstant * (edgeLength - distance) / distance;
                  var fx = dx * springForce;
                  var fy = dy * springForce;
                  if (this.physicsBody.forces[node1.id] !== void 0) {
                    this.physicsBody.forces[node1.id].x += fx;
                    this.physicsBody.forces[node1.id].y += fy;
                  }
                  if (this.physicsBody.forces[node2.id] !== void 0) {
                    this.physicsBody.forces[node2.id].x -= fx;
                    this.physicsBody.forces[node2.id].y -= fy;
                  }
                }
              }]);
              return SpringSolver2;
            }();
            exports2["default"] = SpringSolver;
          },
          /* 224 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var HierarchicalSpringSolver = function() {
              function HierarchicalSpringSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, HierarchicalSpringSolver2);
                this.body = body;
                this.physicsBody = physicsBody;
                this.setOptions(options);
              }
              (0, _createClass3["default"])(HierarchicalSpringSolver2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  this.options = options;
                }
                /**
                 * This function calculates the springforces on the nodes, accounting for the support nodes.
                 *
                 * @private
                 */
              }, {
                key: "solve",
                value: function solve() {
                  var edgeLength, edge;
                  var dx, dy, fx, fy, springForce, distance;
                  var edges = this.body.edges;
                  var factor = 0.5;
                  var edgeIndices = this.physicsBody.physicsEdgeIndices;
                  var nodeIndices = this.physicsBody.physicsNodeIndices;
                  var forces = this.physicsBody.forces;
                  for (var i = 0; i < nodeIndices.length; i++) {
                    var nodeId = nodeIndices[i];
                    forces[nodeId].springFx = 0;
                    forces[nodeId].springFy = 0;
                  }
                  for (var _i = 0; _i < edgeIndices.length; _i++) {
                    edge = edges[edgeIndices[_i]];
                    if (edge.connected === true) {
                      edgeLength = edge.options.length === void 0 ? this.options.springLength : edge.options.length;
                      dx = edge.from.x - edge.to.x;
                      dy = edge.from.y - edge.to.y;
                      distance = Math.sqrt(dx * dx + dy * dy);
                      distance = distance === 0 ? 0.01 : distance;
                      springForce = this.options.springConstant * (edgeLength - distance) / distance;
                      fx = dx * springForce;
                      fy = dy * springForce;
                      if (edge.to.level != edge.from.level) {
                        if (forces[edge.toId] !== void 0) {
                          forces[edge.toId].springFx -= fx;
                          forces[edge.toId].springFy -= fy;
                        }
                        if (forces[edge.fromId] !== void 0) {
                          forces[edge.fromId].springFx += fx;
                          forces[edge.fromId].springFy += fy;
                        }
                      } else {
                        if (forces[edge.toId] !== void 0) {
                          forces[edge.toId].x -= factor * fx;
                          forces[edge.toId].y -= factor * fy;
                        }
                        if (forces[edge.fromId] !== void 0) {
                          forces[edge.fromId].x += factor * fx;
                          forces[edge.fromId].y += factor * fy;
                        }
                      }
                    }
                  }
                  springForce = 1;
                  var springFx, springFy;
                  for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {
                    var _nodeId = nodeIndices[_i2];
                    springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));
                    springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));
                    forces[_nodeId].x += springFx;
                    forces[_nodeId].y += springFy;
                  }
                  var totalFx = 0;
                  var totalFy = 0;
                  for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {
                    var _nodeId2 = nodeIndices[_i3];
                    totalFx += forces[_nodeId2].x;
                    totalFy += forces[_nodeId2].y;
                  }
                  var correctionFx = totalFx / nodeIndices.length;
                  var correctionFy = totalFy / nodeIndices.length;
                  for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {
                    var _nodeId3 = nodeIndices[_i4];
                    forces[_nodeId3].x -= correctionFx;
                    forces[_nodeId3].y -= correctionFy;
                  }
                }
              }]);
              return HierarchicalSpringSolver2;
            }();
            exports2["default"] = HierarchicalSpringSolver;
          },
          /* 225 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _BarnesHutSolver2 = __webpack_require__(120);
            var _BarnesHutSolver3 = _interopRequireDefault(_BarnesHutSolver2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ForceAtlas2BasedRepulsionSolver = function(_BarnesHutSolver) {
              (0, _inherits3["default"])(ForceAtlas2BasedRepulsionSolver2, _BarnesHutSolver);
              function ForceAtlas2BasedRepulsionSolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, ForceAtlas2BasedRepulsionSolver2);
                return (0, _possibleConstructorReturn3["default"])(this, (ForceAtlas2BasedRepulsionSolver2.__proto__ || (0, _getPrototypeOf2["default"])(ForceAtlas2BasedRepulsionSolver2)).call(this, body, physicsBody, options));
              }
              (0, _createClass3["default"])(ForceAtlas2BasedRepulsionSolver2, [{
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, node, parentBranch) {
                  if (distance === 0) {
                    distance = 0.1 * Math.random();
                    dx = distance;
                  }
                  if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {
                    distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);
                  }
                  var degree = node.edges.length + 1;
                  var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);
                  var fx = dx * gravityForce;
                  var fy = dy * gravityForce;
                  this.physicsBody.forces[node.id].x += fx;
                  this.physicsBody.forces[node.id].y += fy;
                }
              }]);
              return ForceAtlas2BasedRepulsionSolver2;
            }(_BarnesHutSolver3["default"]);
            exports2["default"] = ForceAtlas2BasedRepulsionSolver;
          },
          /* 226 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _CentralGravitySolver2 = __webpack_require__(121);
            var _CentralGravitySolver3 = _interopRequireDefault(_CentralGravitySolver2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var ForceAtlas2BasedCentralGravitySolver = function(_CentralGravitySolver) {
              (0, _inherits3["default"])(ForceAtlas2BasedCentralGravitySolver2, _CentralGravitySolver);
              function ForceAtlas2BasedCentralGravitySolver2(body, physicsBody, options) {
                (0, _classCallCheck3["default"])(this, ForceAtlas2BasedCentralGravitySolver2);
                return (0, _possibleConstructorReturn3["default"])(this, (ForceAtlas2BasedCentralGravitySolver2.__proto__ || (0, _getPrototypeOf2["default"])(ForceAtlas2BasedCentralGravitySolver2)).call(this, body, physicsBody, options));
              }
              (0, _createClass3["default"])(ForceAtlas2BasedCentralGravitySolver2, [{
                key: "_calculateForces",
                value: function _calculateForces(distance, dx, dy, forces, node) {
                  if (distance > 0) {
                    var degree = node.edges.length + 1;
                    var gravityForce = this.options.centralGravity * degree * node.options.mass;
                    forces[node.id].x = dx * gravityForce;
                    forces[node.id].y = dy * gravityForce;
                  }
                }
              }]);
              return ForceAtlas2BasedCentralGravitySolver2;
            }(_CentralGravitySolver3["default"]);
            exports2["default"] = ForceAtlas2BasedCentralGravitySolver;
          },
          /* 227 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(76)["default"];
            var Cluster = __webpack_require__(228)["default"];
            var Edge = __webpack_require__(74)["default"];
            var Node = __webpack_require__(47)["default"];
            var ClusterEngine = function() {
              function ClusterEngine2(body) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, ClusterEngine2);
                this.body = body;
                this.clusteredNodes = {};
                this.clusteredEdges = {};
                this.options = {};
                this.defaultOptions = {};
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("_resetData", function() {
                  _this.clusteredNodes = {};
                  _this.clusteredEdges = {};
                });
              }
              (0, _createClass3["default"])(ClusterEngine2, [{
                key: "clusterByHubsize",
                value: function clusterByHubsize(hubsize, options) {
                  if (hubsize === void 0) {
                    hubsize = this._getHubSize();
                  } else if ((typeof hubsize === "undefined" ? "undefined" : (0, _typeof3["default"])(hubsize)) === "object") {
                    options = this._checkOptions(hubsize);
                    hubsize = this._getHubSize();
                  }
                  var nodesToCluster = [];
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var node = this.body.nodes[this.body.nodeIndices[i]];
                    if (node.edges.length >= hubsize) {
                      nodesToCluster.push(node.id);
                    }
                  }
                  for (var _i = 0; _i < nodesToCluster.length; _i++) {
                    this.clusterByConnection(nodesToCluster[_i], options, true);
                  }
                  this.body.emitter.emit("_dataChanged");
                }
                /**
                 * loop over all nodes, check if they adhere to the condition and cluster if needed.
                 * @param {Object} options
                 * @param {boolean} [refreshData=true]
                 */
              }, {
                key: "cluster",
                value: function cluster() {
                  var _this2 = this;
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (options.joinCondition === void 0) {
                    throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");
                  }
                  options = this._checkOptions(options);
                  var childNodesObj = {};
                  var childEdgesObj = {};
                  util.forEach(this.body.nodes, function(node, nodeId) {
                    var clonedOptions = NetworkUtil.cloneOptions(node);
                    if (options.joinCondition(clonedOptions) === true) {
                      childNodesObj[nodeId] = node;
                      util.forEach(node.edges, function(edge) {
                        if (_this2.clusteredEdges[edge.id] === void 0) {
                          childEdgesObj[edge.id] = edge;
                        }
                      });
                    }
                  });
                  this._cluster(childNodesObj, childEdgesObj, options, refreshData);
                }
                /**
                 * Cluster all nodes in the network that have only X edges
                 * @param {number} edgeCount
                 * @param {Object} options
                 * @param {boolean} [refreshData=true]
                 */
              }, {
                key: "clusterByEdgeCount",
                value: function clusterByEdgeCount(edgeCount, options) {
                  var _this3 = this;
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  options = this._checkOptions(options);
                  var clusters = [];
                  var usedNodes = {};
                  var edge = void 0, edges = void 0, relevantEdgeCount = void 0;
                  var _loop = function _loop2(i2) {
                    var childNodesObj = {};
                    var childEdgesObj = {};
                    var nodeId = _this3.body.nodeIndices[i2];
                    var node = _this3.body.nodes[nodeId];
                    if (usedNodes[nodeId] === void 0) {
                      relevantEdgeCount = 0;
                      edges = [];
                      for (var j = 0; j < node.edges.length; j++) {
                        edge = node.edges[j];
                        if (_this3.clusteredEdges[edge.id] === void 0) {
                          if (edge.toId !== edge.fromId) {
                            relevantEdgeCount++;
                          }
                          edges.push(edge);
                        }
                      }
                      if (relevantEdgeCount === edgeCount) {
                        checkJoinCondition = function checkJoinCondition2(node2) {
                          if (options.joinCondition === void 0 || options.joinCondition === null) {
                            return true;
                          }
                          var clonedOptions = NetworkUtil.cloneOptions(node2);
                          return options.joinCondition(clonedOptions);
                        };
                        var gatheringSuccessful = true;
                        for (var _j = 0; _j < edges.length; _j++) {
                          edge = edges[_j];
                          var childNodeId = _this3._getConnectedId(edge, nodeId);
                          if (checkJoinCondition(node)) {
                            childEdgesObj[edge.id] = edge;
                            childNodesObj[nodeId] = node;
                            childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];
                            usedNodes[nodeId] = true;
                          } else {
                            gatheringSuccessful = false;
                            break;
                          }
                        }
                        if ((0, _keys2["default"])(childNodesObj).length > 0 && (0, _keys2["default"])(childEdgesObj).length > 0 && gatheringSuccessful === true) {
                          findClusterData = function findClusterData2() {
                            for (var n = 0; n < clusters.length; ++n) {
                              for (var m2 in childNodesObj) {
                                if (clusters[n].nodes[m2] !== void 0) {
                                  return clusters[n];
                                }
                              }
                            }
                            return void 0;
                          };
                          foundCluster = findClusterData();
                          if (foundCluster !== void 0) {
                            for (var m in childNodesObj) {
                              if (foundCluster.nodes[m] === void 0) {
                                foundCluster.nodes[m] = childNodesObj[m];
                              }
                            }
                            for (var _m in childEdgesObj) {
                              if (foundCluster.edges[_m] === void 0) {
                                foundCluster.edges[_m] = childEdgesObj[_m];
                              }
                            }
                          } else {
                            clusters.push({ nodes: childNodesObj, edges: childEdgesObj });
                          }
                        }
                      }
                    }
                  };
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var checkJoinCondition;
                    var findClusterData;
                    var foundCluster;
                    _loop(i);
                  }
                  for (var i = 0; i < clusters.length; i++) {
                    this._cluster(clusters[i].nodes, clusters[i].edges, options, false);
                  }
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 * Cluster all nodes in the network that have only 1 edge
                 * @param {Object} options
                 * @param {boolean} [refreshData=true]
                 */
              }, {
                key: "clusterOutliers",
                value: function clusterOutliers(options) {
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this.clusterByEdgeCount(1, options, refreshData);
                }
                /**
                 * Cluster all nodes in the network that have only 2 edge
                 * @param {Object} options
                 * @param {boolean} [refreshData=true]
                 */
              }, {
                key: "clusterBridges",
                value: function clusterBridges(options) {
                  var refreshData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  this.clusterByEdgeCount(2, options, refreshData);
                }
                /**
                * suck all connected nodes of a node into the node.
                * @param {Node.id} nodeId
                * @param {Object} options
                * @param {boolean} [refreshData=true]
                */
              }, {
                key: "clusterByConnection",
                value: function clusterByConnection(nodeId, options) {
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  if (nodeId === void 0) {
                    throw new Error("No nodeId supplied to clusterByConnection!");
                  }
                  if (this.body.nodes[nodeId] === void 0) {
                    throw new Error("The nodeId given to clusterByConnection does not exist!");
                  }
                  var node = this.body.nodes[nodeId];
                  options = this._checkOptions(options, node);
                  if (options.clusterNodeProperties.x === void 0) {
                    options.clusterNodeProperties.x = node.x;
                  }
                  if (options.clusterNodeProperties.y === void 0) {
                    options.clusterNodeProperties.y = node.y;
                  }
                  if (options.clusterNodeProperties.fixed === void 0) {
                    options.clusterNodeProperties.fixed = {};
                    options.clusterNodeProperties.fixed.x = node.options.fixed.x;
                    options.clusterNodeProperties.fixed.y = node.options.fixed.y;
                  }
                  var childNodesObj = {};
                  var childEdgesObj = {};
                  var parentNodeId = node.id;
                  var parentClonedOptions = NetworkUtil.cloneOptions(node);
                  childNodesObj[parentNodeId] = node;
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    if (this.clusteredEdges[edge.id] === void 0) {
                      var childNodeId = this._getConnectedId(edge, parentNodeId);
                      if (this.clusteredNodes[childNodeId] === void 0) {
                        if (childNodeId !== parentNodeId) {
                          if (options.joinCondition === void 0) {
                            childEdgesObj[edge.id] = edge;
                            childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                          } else {
                            var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);
                            if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {
                              childEdgesObj[edge.id] = edge;
                              childNodesObj[childNodeId] = this.body.nodes[childNodeId];
                            }
                          }
                        } else {
                          childEdgesObj[edge.id] = edge;
                        }
                      }
                    }
                  }
                  var childNodeIDs = (0, _keys2["default"])(childNodesObj).map(function(childNode2) {
                    return childNodesObj[childNode2].id;
                  });
                  for (childNode in childNodesObj) {
                    if (!childNodesObj.hasOwnProperty(childNode)) continue;
                    var childNode = childNodesObj[childNode];
                    for (var y = 0; y < childNode.edges.length; y++) {
                      var childEdge = childNode.edges[y];
                      if (childNodeIDs.indexOf(this._getConnectedId(childEdge, childNode.id)) > -1) {
                        childEdgesObj[childEdge.id] = childEdge;
                      }
                    }
                  }
                  this._cluster(childNodesObj, childEdgesObj, options, refreshData);
                }
                /**
                * This function creates the edges that will be attached to the cluster
                * It looks for edges that are connected to the nodes from the "outside' of the cluster.
                *
                * @param {{Node.id: vis.Node}} childNodesObj
                * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
                * @param {Object} clusterNodeProperties
                * @param {Object} clusterEdgeProperties
                * @private
                */
              }, {
                key: "_createClusterEdges",
                value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {
                  var edge = void 0, childNodeId = void 0, childNode = void 0, toId = void 0, fromId = void 0, otherNodeId = void 0;
                  var childKeys = (0, _keys2["default"])(childNodesObj);
                  var createEdges = [];
                  for (var i = 0; i < childKeys.length; i++) {
                    childNodeId = childKeys[i];
                    childNode = childNodesObj[childNodeId];
                    for (var j = 0; j < childNode.edges.length; j++) {
                      edge = childNode.edges[j];
                      if (this.clusteredEdges[edge.id] === void 0) {
                        if (edge.toId == edge.fromId) {
                          childEdgesObj[edge.id] = edge;
                        } else {
                          if (edge.toId == childNodeId) {
                            toId = clusterNodeProperties.id;
                            fromId = edge.fromId;
                            otherNodeId = fromId;
                          } else {
                            toId = edge.toId;
                            fromId = clusterNodeProperties.id;
                            otherNodeId = toId;
                          }
                        }
                        if (childNodesObj[otherNodeId] === void 0) {
                          createEdges.push({ edge, fromId, toId });
                        }
                      }
                    }
                  }
                  var newEdges = [];
                  var getNewEdge = function getNewEdge2(createdEdge2) {
                    for (var _j2 = 0; _j2 < newEdges.length; _j2++) {
                      var newEdge2 = newEdges[_j2];
                      var matchToDirection = createdEdge2.fromId === newEdge2.fromId && createdEdge2.toId === newEdge2.toId;
                      var matchFromDirection = createdEdge2.fromId === newEdge2.toId && createdEdge2.toId === newEdge2.fromId;
                      if (matchToDirection || matchFromDirection) {
                        return newEdge2;
                      }
                    }
                    return null;
                  };
                  for (var _j3 = 0; _j3 < createEdges.length; _j3++) {
                    var createdEdge = createEdges[_j3];
                    var _edge = createdEdge.edge;
                    var newEdge = getNewEdge(createdEdge);
                    if (newEdge === null) {
                      newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);
                      newEdges.push(newEdge);
                    } else {
                      newEdge.clusteringEdgeReplacingIds.push(_edge.id);
                    }
                    this.body.edges[_edge.id].edgeReplacedById = newEdge.id;
                    this._backupEdgeOptions(_edge);
                    _edge.setOptions({ physics: false });
                  }
                }
                /**
                * This function checks the options that can be supplied to the different cluster functions
                * for certain fields and inserts defaults if needed
                * @param {Object} options
                * @returns {*}
                * @private
                */
              }, {
                key: "_checkOptions",
                value: function _checkOptions() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  if (options.clusterEdgeProperties === void 0) {
                    options.clusterEdgeProperties = {};
                  }
                  if (options.clusterNodeProperties === void 0) {
                    options.clusterNodeProperties = {};
                  }
                  return options;
                }
                /**
                *
                * @param {Object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
                * @param {Object}    childEdgesObj         | object with edge objects, id as keys
                * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
                * @param {boolean}   refreshData | when true, do not wrap up
                * @private
                */
              }, {
                key: "_cluster",
                value: function _cluster(childNodesObj, childEdgesObj, options) {
                  var refreshData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                  var tmpNodesToRemove = [];
                  for (var _nodeId in childNodesObj) {
                    if (childNodesObj.hasOwnProperty(_nodeId)) {
                      if (this.clusteredNodes[_nodeId] !== void 0) {
                        tmpNodesToRemove.push(_nodeId);
                      }
                    }
                  }
                  for (var n = 0; n < tmpNodesToRemove.length; ++n) {
                    delete childNodesObj[tmpNodesToRemove[n]];
                  }
                  if ((0, _keys2["default"])(childNodesObj).length == 0) {
                    return;
                  }
                  if ((0, _keys2["default"])(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {
                    return;
                  }
                  var clusterNodeProperties = util.deepExtend({}, options.clusterNodeProperties);
                  if (options.processProperties !== void 0) {
                    var childNodesOptions = [];
                    for (var _nodeId2 in childNodesObj) {
                      if (childNodesObj.hasOwnProperty(_nodeId2)) {
                        var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId2]);
                        childNodesOptions.push(clonedOptions);
                      }
                    }
                    var childEdgesOptions = [];
                    for (var edgeId in childEdgesObj) {
                      if (childEdgesObj.hasOwnProperty(edgeId)) {
                        if (edgeId.substr(0, 12) !== "clusterEdge:") {
                          var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], "edge");
                          childEdgesOptions.push(_clonedOptions);
                        }
                      }
                    }
                    clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);
                    if (!clusterNodeProperties) {
                      throw new Error("The processProperties function does not return properties!");
                    }
                  }
                  if (clusterNodeProperties.id === void 0) {
                    clusterNodeProperties.id = "cluster:" + util.randomUUID();
                  }
                  var clusterId = clusterNodeProperties.id;
                  if (clusterNodeProperties.label === void 0) {
                    clusterNodeProperties.label = "cluster";
                  }
                  var pos = void 0;
                  if (clusterNodeProperties.x === void 0) {
                    pos = this._getClusterPosition(childNodesObj);
                    clusterNodeProperties.x = pos.x;
                  }
                  if (clusterNodeProperties.y === void 0) {
                    if (pos === void 0) {
                      pos = this._getClusterPosition(childNodesObj);
                    }
                    clusterNodeProperties.y = pos.y;
                  }
                  clusterNodeProperties.id = clusterId;
                  var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);
                  clusterNode.containedNodes = childNodesObj;
                  clusterNode.containedEdges = childEdgesObj;
                  clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;
                  this.body.nodes[clusterNodeProperties.id] = clusterNode;
                  this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);
                  clusterNodeProperties.id = void 0;
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 *
                 * @param {Edge} edge
                 * @private
                 */
              }, {
                key: "_backupEdgeOptions",
                value: function _backupEdgeOptions(edge) {
                  if (this.clusteredEdges[edge.id] === void 0) {
                    this.clusteredEdges[edge.id] = { physics: edge.options.physics };
                  }
                }
                /**
                 *
                 * @param {Edge} edge
                 * @private
                 */
              }, {
                key: "_restoreEdge",
                value: function _restoreEdge(edge) {
                  var originalOptions = this.clusteredEdges[edge.id];
                  if (originalOptions !== void 0) {
                    edge.setOptions({ physics: originalOptions.physics });
                    delete this.clusteredEdges[edge.id];
                  }
                }
                /**
                * Check if a node is a cluster.
                * @param {Node.id} nodeId
                * @returns {*}
                */
              }, {
                key: "isCluster",
                value: function isCluster(nodeId) {
                  if (this.body.nodes[nodeId] !== void 0) {
                    return this.body.nodes[nodeId].isCluster === true;
                  } else {
                    console.log("Node does not exist.");
                    return false;
                  }
                }
                /**
                * get the position of the cluster node based on what's inside
                * @param {object} childNodesObj    | object with node objects, id as keys
                * @returns {{x: number, y: number}}
                * @private
                */
              }, {
                key: "_getClusterPosition",
                value: function _getClusterPosition(childNodesObj) {
                  var childKeys = (0, _keys2["default"])(childNodesObj);
                  var minX = childNodesObj[childKeys[0]].x;
                  var maxX = childNodesObj[childKeys[0]].x;
                  var minY = childNodesObj[childKeys[0]].y;
                  var maxY = childNodesObj[childKeys[0]].y;
                  var node = void 0;
                  for (var i = 1; i < childKeys.length; i++) {
                    node = childNodesObj[childKeys[i]];
                    minX = node.x < minX ? node.x : minX;
                    maxX = node.x > maxX ? node.x : maxX;
                    minY = node.y < minY ? node.y : minY;
                    maxY = node.y > maxY ? node.y : maxY;
                  }
                  return { x: 0.5 * (minX + maxX), y: 0.5 * (minY + maxY) };
                }
                /**
                 * Open a cluster by calling this function.
                 * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
                 * @param {Object} options
                 * @param {boolean} refreshData | wrap up afterwards if not true
                 */
              }, {
                key: "openCluster",
                value: function openCluster(clusterNodeId, options) {
                  var refreshData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                  if (clusterNodeId === void 0) {
                    throw new Error("No clusterNodeId supplied to openCluster.");
                  }
                  var clusterNode = this.body.nodes[clusterNodeId];
                  if (clusterNode === void 0) {
                    throw new Error("The clusterNodeId supplied to openCluster does not exist.");
                  }
                  if (clusterNode.isCluster !== true || clusterNode.containedNodes === void 0 || clusterNode.containedEdges === void 0) {
                    throw new Error("The node:" + clusterNodeId + " is not a valid cluster.");
                  }
                  var stack = this.findNode(clusterNodeId);
                  var parentIndex = stack.indexOf(clusterNodeId) - 1;
                  if (parentIndex >= 0) {
                    var parentClusterNodeId = stack[parentIndex];
                    var parentClusterNode = this.body.nodes[parentClusterNodeId];
                    parentClusterNode._openChildCluster(clusterNodeId);
                    delete this.body.nodes[clusterNodeId];
                    if (refreshData === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                    return;
                  }
                  var containedNodes = clusterNode.containedNodes;
                  var containedEdges = clusterNode.containedEdges;
                  if (options !== void 0 && options.releaseFunction !== void 0 && typeof options.releaseFunction === "function") {
                    var positions = {};
                    var clusterPosition = { x: clusterNode.x, y: clusterNode.y };
                    for (var _nodeId3 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId3)) {
                        var containedNode = this.body.nodes[_nodeId3];
                        positions[_nodeId3] = { x: containedNode.x, y: containedNode.y };
                      }
                    }
                    var newPositions = options.releaseFunction(clusterPosition, positions);
                    for (var _nodeId4 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId4)) {
                        var _containedNode = this.body.nodes[_nodeId4];
                        if (newPositions[_nodeId4] !== void 0) {
                          _containedNode.x = newPositions[_nodeId4].x === void 0 ? clusterNode.x : newPositions[_nodeId4].x;
                          _containedNode.y = newPositions[_nodeId4].y === void 0 ? clusterNode.y : newPositions[_nodeId4].y;
                        }
                      }
                    }
                  } else {
                    util.forEach(containedNodes, function(containedNode2) {
                      if (containedNode2.options.fixed.x === false) {
                        containedNode2.x = clusterNode.x;
                      }
                      if (containedNode2.options.fixed.y === false) {
                        containedNode2.y = clusterNode.y;
                      }
                    });
                  }
                  for (var _nodeId5 in containedNodes) {
                    if (containedNodes.hasOwnProperty(_nodeId5)) {
                      var _containedNode2 = this.body.nodes[_nodeId5];
                      _containedNode2.vx = clusterNode.vx;
                      _containedNode2.vy = clusterNode.vy;
                      _containedNode2.setOptions({ physics: true });
                      delete this.clusteredNodes[_nodeId5];
                    }
                  }
                  var edgesToBeDeleted = [];
                  for (var i = 0; i < clusterNode.edges.length; i++) {
                    edgesToBeDeleted.push(clusterNode.edges[i]);
                  }
                  for (var _i2 = 0; _i2 < edgesToBeDeleted.length; _i2++) {
                    var edge = edgesToBeDeleted[_i2];
                    var otherNodeId = this._getConnectedId(edge, clusterNodeId);
                    var otherNode = this.clusteredNodes[otherNodeId];
                    for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {
                      var transferId = edge.clusteringEdgeReplacingIds[j];
                      var transferEdge = this.body.edges[transferId];
                      if (transferEdge === void 0) continue;
                      if (otherNode !== void 0) {
                        var otherCluster = this.body.nodes[otherNode.clusterId];
                        otherCluster.containedEdges[transferEdge.id] = transferEdge;
                        delete containedEdges[transferEdge.id];
                        var fromId = transferEdge.fromId;
                        var toId = transferEdge.toId;
                        if (transferEdge.toId == otherNodeId) {
                          toId = otherNode.clusterId;
                        } else {
                          fromId = otherNode.clusterId;
                        }
                        this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, { hidden: false, physics: true });
                      } else {
                        this._restoreEdge(transferEdge);
                      }
                    }
                    edge.remove();
                  }
                  for (var edgeId in containedEdges) {
                    if (containedEdges.hasOwnProperty(edgeId)) {
                      this._restoreEdge(containedEdges[edgeId]);
                    }
                  }
                  delete this.body.nodes[clusterNodeId];
                  if (refreshData === true) {
                    this.body.emitter.emit("_dataChanged");
                  }
                }
                /**
                 *
                 * @param {Cluster.id} clusterId
                 * @returns {Array.<Node.id>}
                 */
              }, {
                key: "getNodesInCluster",
                value: function getNodesInCluster(clusterId) {
                  var nodesArray = [];
                  if (this.isCluster(clusterId) === true) {
                    var containedNodes = this.body.nodes[clusterId].containedNodes;
                    for (var _nodeId6 in containedNodes) {
                      if (containedNodes.hasOwnProperty(_nodeId6)) {
                        nodesArray.push(this.body.nodes[_nodeId6].id);
                      }
                    }
                  }
                  return nodesArray;
                }
                /**
                * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
                *
                * If a node can't be found in the chain, return an empty array.
                *
                * @param {string|number} nodeId
                * @returns {Array}
                */
              }, {
                key: "findNode",
                value: function findNode(nodeId) {
                  var stack = [];
                  var max = 100;
                  var counter = 0;
                  var node = void 0;
                  while (this.clusteredNodes[nodeId] !== void 0 && counter < max) {
                    node = this.body.nodes[nodeId];
                    if (node === void 0) return [];
                    stack.push(node.id);
                    nodeId = this.clusteredNodes[nodeId].clusterId;
                    counter++;
                  }
                  node = this.body.nodes[nodeId];
                  if (node === void 0) return [];
                  stack.push(node.id);
                  stack.reverse();
                  return stack;
                }
                /**
                * Using a clustered nodeId, update with the new options
                * @param {vis.Edge.id} clusteredNodeId
                * @param {object} newOptions
                */
              }, {
                key: "updateClusteredNode",
                value: function updateClusteredNode(clusteredNodeId, newOptions) {
                  if (clusteredNodeId === void 0) {
                    throw new Error("No clusteredNodeId supplied to updateClusteredNode.");
                  }
                  if (newOptions === void 0) {
                    throw new Error("No newOptions supplied to updateClusteredNode.");
                  }
                  if (this.body.nodes[clusteredNodeId] === void 0) {
                    throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");
                  }
                  this.body.nodes[clusteredNodeId].setOptions(newOptions);
                  this.body.emitter.emit("_dataChanged");
                }
                /**
                * Using a base edgeId, update all related clustered edges with the new options
                * @param {vis.Edge.id} startEdgeId
                * @param {object} newOptions
                */
              }, {
                key: "updateEdge",
                value: function updateEdge(startEdgeId, newOptions) {
                  if (startEdgeId === void 0) {
                    throw new Error("No startEdgeId supplied to updateEdge.");
                  }
                  if (newOptions === void 0) {
                    throw new Error("No newOptions supplied to updateEdge.");
                  }
                  if (this.body.edges[startEdgeId] === void 0) {
                    throw new Error("The startEdgeId supplied to updateEdge does not exist.");
                  }
                  var allEdgeIds = this.getClusteredEdges(startEdgeId);
                  for (var i = 0; i < allEdgeIds.length; i++) {
                    var edge = this.body.edges[allEdgeIds[i]];
                    edge.setOptions(newOptions);
                  }
                  this.body.emitter.emit("_dataChanged");
                }
                /**
                * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
                * @param {vis.Edge.id} edgeId
                * @returns {Array.<vis.Edge.id>}
                */
              }, {
                key: "getClusteredEdges",
                value: function getClusteredEdges(edgeId) {
                  var stack = [];
                  var max = 100;
                  var counter = 0;
                  while (edgeId !== void 0 && this.body.edges[edgeId] !== void 0 && counter < max) {
                    stack.push(this.body.edges[edgeId].id);
                    edgeId = this.body.edges[edgeId].edgeReplacedById;
                    counter++;
                  }
                  stack.reverse();
                  return stack;
                }
                /**
                * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
                * @param {vis.Edge.id} clusteredEdgeId
                * @returns {vis.Edge.id} baseEdgeId
                *
                * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
                */
              }, {
                key: "getBaseEdge",
                value: function getBaseEdge(clusteredEdgeId) {
                  return this.getBaseEdges(clusteredEdgeId)[0];
                }
                /**
                 * Get all regular edges for this clustered edge id.
                 *
                 * @param {vis.Edge.id} clusteredEdgeId
                 * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
                 */
              }, {
                key: "getBaseEdges",
                value: function getBaseEdges(clusteredEdgeId) {
                  var IdsToHandle = [clusteredEdgeId];
                  var doneIds = [];
                  var foundIds = [];
                  var max = 100;
                  var counter = 0;
                  while (IdsToHandle.length > 0 && counter < max) {
                    var nextId = IdsToHandle.pop();
                    if (nextId === void 0) continue;
                    var nextEdge = this.body.edges[nextId];
                    if (nextEdge === void 0) continue;
                    counter++;
                    var replacingIds = nextEdge.clusteringEdgeReplacingIds;
                    if (replacingIds === void 0) {
                      foundIds.push(nextId);
                    } else {
                      for (var i = 0; i < replacingIds.length; ++i) {
                        var replacingId = replacingIds[i];
                        if (IdsToHandle.indexOf(replacingIds) !== -1 || doneIds.indexOf(replacingIds) !== -1) {
                          continue;
                        }
                        IdsToHandle.push(replacingId);
                      }
                    }
                    doneIds.push(nextId);
                  }
                  return foundIds;
                }
                /**
                * Get the Id the node is connected to
                * @param {vis.Edge} edge
                * @param {Node.id} nodeId
                * @returns {*}
                * @private
                */
              }, {
                key: "_getConnectedId",
                value: function _getConnectedId(edge, nodeId) {
                  if (edge.toId != nodeId) {
                    return edge.toId;
                  } else if (edge.fromId != nodeId) {
                    return edge.fromId;
                  } else {
                    return edge.fromId;
                  }
                }
                /**
                * We determine how many connections denote an important hub.
                * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
                *
                * @returns {number}
                * @private
                */
              }, {
                key: "_getHubSize",
                value: function _getHubSize() {
                  var average = 0;
                  var averageSquared = 0;
                  var hubCounter = 0;
                  var largestHub = 0;
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var _node = this.body.nodes[this.body.nodeIndices[i]];
                    if (_node.edges.length > largestHub) {
                      largestHub = _node.edges.length;
                    }
                    average += _node.edges.length;
                    averageSquared += Math.pow(_node.edges.length, 2);
                    hubCounter += 1;
                  }
                  average = average / hubCounter;
                  averageSquared = averageSquared / hubCounter;
                  var variance = averageSquared - Math.pow(average, 2);
                  var standardDeviation = Math.sqrt(variance);
                  var hubThreshold = Math.floor(average + 2 * standardDeviation);
                  if (hubThreshold > largestHub) {
                    hubThreshold = largestHub;
                  }
                  return hubThreshold;
                }
                /**
                 * Create an edge for the cluster representation.
                 *
                 * @param {Node.id} fromId
                 * @param {Node.id} toId
                 * @param {vis.Edge} baseEdge
                 * @param {Object} clusterEdgeProperties
                 * @param {Object} extraOptions
                 * @returns {Edge} newly created clustered edge
                 * @private
                 */
              }, {
                key: "_createClusteredEdge",
                value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {
                  var clonedOptions = NetworkUtil.cloneOptions(baseEdge, "edge");
                  util.deepExtend(clonedOptions, clusterEdgeProperties);
                  clonedOptions.from = fromId;
                  clonedOptions.to = toId;
                  clonedOptions.id = "clusterEdge:" + util.randomUUID();
                  if (extraOptions !== void 0) {
                    util.deepExtend(clonedOptions, extraOptions);
                  }
                  var newEdge = this.body.functions.createEdge(clonedOptions);
                  newEdge.clusteringEdgeReplacingIds = [baseEdge.id];
                  newEdge.connect();
                  this.body.edges[newEdge.id] = newEdge;
                  return newEdge;
                }
                /**
                 * Add the passed child nodes and edges to the given cluster node.
                 *
                 * @param {Object|Node} childNodes  hash of nodes or single node to add in cluster
                 * @param {Object|Edge} childEdges  hash of edges or single edge to take into account when clustering
                 * @param {Node} clusterNode  cluster node to add nodes and edges to
                 * @param {Object} [clusterEdgeProperties]
                 * @private
                 */
              }, {
                key: "_clusterEdges",
                value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {
                  if (childEdges instanceof Edge) {
                    var edge = childEdges;
                    var obj = {};
                    obj[edge.id] = edge;
                    childEdges = obj;
                  }
                  if (childNodes instanceof Node) {
                    var _node2 = childNodes;
                    var _obj = {};
                    _obj[_node2.id] = _node2;
                    childNodes = _obj;
                  }
                  if (clusterNode === void 0 || clusterNode === null) {
                    throw new Error("_clusterEdges: parameter clusterNode required");
                  }
                  if (clusterEdgeProperties === void 0) {
                    clusterEdgeProperties = clusterNode.clusterEdgeProperties;
                  }
                  this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);
                  for (var edgeId in childEdges) {
                    if (childEdges.hasOwnProperty(edgeId)) {
                      if (this.body.edges[edgeId] !== void 0) {
                        var _edge2 = this.body.edges[edgeId];
                        this._backupEdgeOptions(_edge2);
                        _edge2.setOptions({ physics: false });
                      }
                    }
                  }
                  for (var _nodeId7 in childNodes) {
                    if (childNodes.hasOwnProperty(_nodeId7)) {
                      this.clusteredNodes[_nodeId7] = { clusterId: clusterNode.id, node: this.body.nodes[_nodeId7] };
                      this.body.nodes[_nodeId7].setOptions({ physics: false });
                    }
                  }
                }
                /**
                 * Determine in which cluster given nodeId resides.
                 *
                 * If not in cluster, return undefined.
                 *
                 * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
                 *
                 * @param {Node.id} nodeId
                 * @returns {Node|undefined} Node instance for cluster, if present
                 * @private
                 */
              }, {
                key: "_getClusterNodeForNode",
                value: function _getClusterNodeForNode(nodeId) {
                  if (nodeId === void 0) return void 0;
                  var clusteredNode = this.clusteredNodes[nodeId];
                  if (clusteredNode === void 0) return void 0;
                  var clusterId = clusteredNode.clusterId;
                  if (clusterId === void 0) return void 0;
                  return this.body.nodes[clusterId];
                }
                /**
                 * Internal helper function for conditionally removing items in array
                 *
                 * Done like this because Array.filter() is not fully supported by all IE's.
                 *
                 * @param {Array} arr
                 * @param {function} callback
                 * @returns {Array}
                 * @private
                 */
              }, {
                key: "_filter",
                value: function _filter(arr, callback) {
                  var ret = [];
                  util.forEach(arr, function(item) {
                    if (callback(item)) {
                      ret.push(item);
                    }
                  });
                  return ret;
                }
                /**
                 * Scan all edges for changes in clustering and adjust this if necessary.
                 *
                 * Call this (internally) after there has been a change in node or edge data.
                 *
                 * Pre: States of this.body.nodes and this.body.edges consistent
                 * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
                 *      of cluster nodes.
                 */
              }, {
                key: "_updateState",
                value: function _updateState() {
                  var _this4 = this;
                  var nodeId = void 0;
                  var deletedNodeIds = [];
                  var deletedEdgeIds = [];
                  var eachClusterNode = function eachClusterNode2(callback) {
                    util.forEach(_this4.body.nodes, function(node) {
                      if (node.isCluster === true) {
                        callback(node);
                      }
                    });
                  };
                  for (nodeId in this.clusteredNodes) {
                    if (!this.clusteredNodes.hasOwnProperty(nodeId)) continue;
                    var _node3 = this.body.nodes[nodeId];
                    if (_node3 === void 0) {
                      deletedNodeIds.push(nodeId);
                    }
                  }
                  eachClusterNode(function(clusterNode) {
                    for (var n2 = 0; n2 < deletedNodeIds.length; n2++) {
                      delete clusterNode.containedNodes[deletedNodeIds[n2]];
                    }
                  });
                  for (var n = 0; n < deletedNodeIds.length; n++) {
                    delete this.clusteredNodes[deletedNodeIds[n]];
                  }
                  util.forEach(this.clusteredEdges, function(edgeId) {
                    var edge = _this4.body.edges[edgeId];
                    if (edge === void 0 || !edge.endPointsValid()) {
                      deletedEdgeIds.push(edgeId);
                    }
                  });
                  eachClusterNode(function(clusterNode) {
                    util.forEach(clusterNode.containedEdges, function(edge, edgeId) {
                      if (!edge.endPointsValid() && deletedEdgeIds.indexOf(edgeId) === -1) {
                        deletedEdgeIds.push(edgeId);
                      }
                    });
                  });
                  util.forEach(this.body.edges, function(edge, edgeId) {
                    var isValid = true;
                    var replacedIds = edge.clusteringEdgeReplacingIds;
                    if (replacedIds !== void 0) {
                      var numValid = 0;
                      util.forEach(replacedIds, function(containedEdgeId) {
                        var containedEdge = _this4.body.edges[containedEdgeId];
                        if (containedEdge !== void 0 && containedEdge.endPointsValid()) {
                          numValid += 1;
                        }
                      });
                      isValid = numValid > 0;
                    }
                    if (!edge.endPointsValid() || !isValid) {
                      deletedEdgeIds.push(edgeId);
                    }
                  });
                  eachClusterNode(function(clusterNode) {
                    util.forEach(deletedEdgeIds, function(deletedEdgeId) {
                      delete clusterNode.containedEdges[deletedEdgeId];
                      util.forEach(clusterNode.edges, function(edge, m) {
                        if (edge.id === deletedEdgeId) {
                          clusterNode.edges[m] = null;
                          return;
                        }
                        edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function(id) {
                          return deletedEdgeIds.indexOf(id) === -1;
                        });
                      });
                      clusterNode.edges = _this4._filter(clusterNode.edges, function(item) {
                        return item !== null;
                      });
                    });
                  });
                  util.forEach(deletedEdgeIds, function(edgeId) {
                    delete _this4.clusteredEdges[edgeId];
                  });
                  util.forEach(deletedEdgeIds, function(edgeId) {
                    delete _this4.body.edges[edgeId];
                  });
                  var ids = (0, _keys2["default"])(this.body.edges);
                  util.forEach(ids, function(edgeId) {
                    var edge = _this4.body.edges[edgeId];
                    var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);
                    if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {
                      return;
                    }
                    if (shouldBeClustered) {
                      var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);
                      if (clusterFrom !== void 0) {
                        _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);
                      }
                      var clusterTo = _this4._getClusterNodeForNode(edge.toId);
                      if (clusterTo !== void 0) {
                        _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);
                      }
                    } else {
                      throw new Error("remove edge from clustering not implemented!");
                    }
                  });
                  var changed = false;
                  var continueLoop = true;
                  var _loop2 = function _loop22() {
                    var clustersToOpen = [];
                    eachClusterNode(function(clusterNode) {
                      var numNodes = (0, _keys2["default"])(clusterNode.containedNodes).length;
                      var allowSingle = clusterNode.options.allowSingleNodeCluster === true;
                      if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {
                        clustersToOpen.push(clusterNode.id);
                      }
                    });
                    for (var _n = 0; _n < clustersToOpen.length; ++_n) {
                      _this4.openCluster(
                        clustersToOpen[_n],
                        {},
                        false
                        /* Don't refresh, we're in an refresh/update already */
                      );
                    }
                    continueLoop = clustersToOpen.length > 0;
                    changed = changed || continueLoop;
                  };
                  while (continueLoop) {
                    _loop2();
                  }
                  if (changed) {
                    this._updateState();
                  }
                }
                /**
                 * Determine if node with given id is part of a cluster.
                 *
                 * @param {Node.id} nodeId
                 * @return {boolean} true if part of a cluster.
                 */
              }, {
                key: "_isClusteredNode",
                value: function _isClusteredNode(nodeId) {
                  return this.clusteredNodes[nodeId] !== void 0;
                }
                /**
                 * Determine if edge with given id is not visible due to clustering.
                 *
                 * An edge is considered clustered if:
                 * - it is directly replaced by a clustering edge
                 * - any of its connecting nodes is in a cluster
                 *
                 * @param {vis.Edge.id} edgeId
                 * @return {boolean} true if part of a cluster.
                 */
              }, {
                key: "_isClusteredEdge",
                value: function _isClusteredEdge(edgeId) {
                  return this.clusteredEdges[edgeId] !== void 0;
                }
              }]);
              return ClusterEngine2;
            }();
            exports2["default"] = ClusterEngine;
          },
          /* 228 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Node = __webpack_require__(47)["default"];
            var Cluster = function(_Node) {
              (0, _inherits3["default"])(Cluster2, _Node);
              function Cluster2(options, body, imagelist, grouplist, globalOptions, defaultOptions) {
                (0, _classCallCheck3["default"])(this, Cluster2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (Cluster2.__proto__ || (0, _getPrototypeOf2["default"])(Cluster2)).call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions));
                _this.isCluster = true;
                _this.containedNodes = {};
                _this.containedEdges = {};
                return _this;
              }
              (0, _createClass3["default"])(Cluster2, [{
                key: "_openChildCluster",
                value: function _openChildCluster(childClusterId) {
                  var _this2 = this;
                  var childCluster = this.body.nodes[childClusterId];
                  if (this.containedNodes[childClusterId] === void 0) {
                    throw new Error("node with id: " + childClusterId + " not in current cluster");
                  }
                  if (!childCluster.isCluster) {
                    throw new Error("node with id: " + childClusterId + " is not a cluster");
                  }
                  delete this.containedNodes[childClusterId];
                  util.forEach(childCluster.edges, function(edge) {
                    delete _this2.containedEdges[edge.id];
                  });
                  util.forEach(childCluster.containedNodes, function(node, nodeId) {
                    _this2.containedNodes[nodeId] = node;
                  });
                  childCluster.containedNodes = {};
                  util.forEach(childCluster.containedEdges, function(edge, edgeId) {
                    _this2.containedEdges[edgeId] = edge;
                  });
                  childCluster.containedEdges = {};
                  util.forEach(childCluster.edges, function(clusterEdge) {
                    util.forEach(_this2.edges, function(parentClusterEdge) {
                      var index = parentClusterEdge.clusteringEdgeReplacingIds.indexOf(clusterEdge.id);
                      if (index === -1) return;
                      util.forEach(clusterEdge.clusteringEdgeReplacingIds, function(srcId) {
                        parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);
                        _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;
                      });
                      parentClusterEdge.clusteringEdgeReplacingIds.splice(index, 1);
                    });
                  });
                  childCluster.edges = [];
                }
              }]);
              return Cluster2;
            }(Node);
            exports2["default"] = Cluster;
          },
          /* 229 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            function _initRequestAnimationFrame() {
              var func;
              if (window !== void 0) {
                func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
              }
              if (func === void 0) {
                window.requestAnimationFrame = function(callback) {
                  callback();
                };
              } else {
                window.requestAnimationFrame = func;
              }
            }
            var util = __webpack_require__(2);
            var CanvasRenderer = function() {
              function CanvasRenderer2(body, canvas) {
                (0, _classCallCheck3["default"])(this, CanvasRenderer2);
                _initRequestAnimationFrame();
                this.body = body;
                this.canvas = canvas;
                this.redrawRequested = false;
                this.renderTimer = void 0;
                this.requiresTimeout = true;
                this.renderingActive = false;
                this.renderRequests = 0;
                this.allowRedraw = true;
                this.dragging = false;
                this.options = {};
                this.defaultOptions = {
                  hideEdgesOnDrag: false,
                  hideNodesOnDrag: false
                };
                util.extend(this.options, this.defaultOptions);
                this._determineBrowserMethod();
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(CanvasRenderer2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("dragStart", function() {
                    _this.dragging = true;
                  });
                  this.body.emitter.on("dragEnd", function() {
                    _this.dragging = false;
                  });
                  this.body.emitter.on("_resizeNodes", function() {
                    _this._resizeNodes();
                  });
                  this.body.emitter.on("_redraw", function() {
                    if (_this.renderingActive === false) {
                      _this._redraw();
                    }
                  });
                  this.body.emitter.on("_blockRedraw", function() {
                    _this.allowRedraw = false;
                  });
                  this.body.emitter.on("_allowRedraw", function() {
                    _this.allowRedraw = true;
                    _this.redrawRequested = false;
                  });
                  this.body.emitter.on("_requestRedraw", this._requestRedraw.bind(this));
                  this.body.emitter.on("_startRendering", function() {
                    _this.renderRequests += 1;
                    _this.renderingActive = true;
                    _this._startRendering();
                  });
                  this.body.emitter.on("_stopRendering", function() {
                    _this.renderRequests -= 1;
                    _this.renderingActive = _this.renderRequests > 0;
                    _this.renderTimer = void 0;
                  });
                  this.body.emitter.on("destroy", function() {
                    _this.renderRequests = 0;
                    _this.allowRedraw = false;
                    _this.renderingActive = false;
                    if (_this.requiresTimeout === true) {
                      clearTimeout(_this.renderTimer);
                    } else {
                      window.cancelAnimationFrame(_this.renderTimer);
                    }
                    _this.body.emitter.off();
                  });
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["hideEdgesOnDrag", "hideNodesOnDrag"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                }
                /**
                 * Prepare the drawing of the next frame.
                 *
                 * Calls the callback when the next frame can or will be drawn.
                 *
                 * @param {function} callback
                 * @param {number} delay - timeout case only, wait this number of milliseconds
                 * @returns {function|undefined}
                 * @private
                 */
              }, {
                key: "_requestNextFrame",
                value: function _requestNextFrame(callback, delay) {
                  if (typeof window === "undefined") return;
                  var timer = void 0;
                  var myWindow = window;
                  if (this.requiresTimeout === true) {
                    timer = myWindow.setTimeout(callback, delay);
                  } else {
                    if (myWindow.requestAnimationFrame) {
                      timer = myWindow.requestAnimationFrame(callback);
                    }
                  }
                  return timer;
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_startRendering",
                value: function _startRendering() {
                  if (this.renderingActive === true) {
                    if (this.renderTimer === void 0) {
                      this.renderTimer = this._requestNextFrame(this._renderStep.bind(this), this.simulationInterval);
                    }
                  }
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_renderStep",
                value: function _renderStep() {
                  if (this.renderingActive === true) {
                    this.renderTimer = void 0;
                    if (this.requiresTimeout === true) {
                      this._startRendering();
                    }
                    this._redraw();
                    if (this.requiresTimeout === false) {
                      this._startRendering();
                    }
                  }
                }
                /**
                 * Redraw the network with the current data
                 * chart will be resized too.
                 */
              }, {
                key: "redraw",
                value: function redraw() {
                  this.body.emitter.emit("setSize");
                  this._redraw();
                }
                /**
                 * Redraw the network with the current data
                 * @private
                 */
              }, {
                key: "_requestRedraw",
                value: function _requestRedraw() {
                  var _this2 = this;
                  if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {
                    this.redrawRequested = true;
                    this._requestNextFrame(function() {
                      _this2._redraw(false);
                    }, 0);
                  }
                }
                /**
                 * Redraw the network with the current data
                 * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
                 *                                   Only the nodes are drawn after which they are quickly drawn over.
                 * @private
                 */
              }, {
                key: "_redraw",
                value: function _redraw() {
                  var hidden = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (this.allowRedraw === true) {
                    this.body.emitter.emit("initRedraw");
                    this.redrawRequested = false;
                    if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {
                      this.canvas.setSize();
                    }
                    this.canvas.setTransform();
                    var ctx = this.canvas.getContext();
                    var w = this.canvas.frame.canvas.clientWidth;
                    var h = this.canvas.frame.canvas.clientHeight;
                    ctx.clearRect(0, 0, w, h);
                    if (this.canvas.frame.clientWidth === 0) {
                      return;
                    }
                    ctx.save();
                    ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
                    ctx.scale(this.body.view.scale, this.body.view.scale);
                    ctx.beginPath();
                    this.body.emitter.emit("beforeDrawing", ctx);
                    ctx.closePath();
                    if (hidden === false) {
                      if (this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) {
                        this._drawEdges(ctx);
                      }
                    }
                    if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {
                      this._drawNodes(ctx, hidden);
                    }
                    ctx.beginPath();
                    this.body.emitter.emit("afterDrawing", ctx);
                    ctx.closePath();
                    ctx.restore();
                    if (hidden === true) {
                      ctx.clearRect(0, 0, w, h);
                    }
                  }
                }
                /**
                 * Redraw all nodes
                 *
                 * @param {CanvasRenderingContext2D}   ctx
                 * @param {boolean} [alwaysShow]
                 * @private
                 */
              }, {
                key: "_resizeNodes",
                value: function _resizeNodes() {
                  this.canvas.setTransform();
                  var ctx = this.canvas.getContext();
                  ctx.save();
                  ctx.translate(this.body.view.translation.x, this.body.view.translation.y);
                  ctx.scale(this.body.view.scale, this.body.view.scale);
                  var nodes = this.body.nodes;
                  var node = void 0;
                  for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                      node = nodes[nodeId];
                      node.resize(ctx);
                      node.updateBoundingBox(ctx, node.selected);
                    }
                  }
                  ctx.restore();
                }
                /**
                 * Redraw all nodes
                 *
                 * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
                 * @param {boolean} [alwaysShow]
                 * @private
                 */
              }, {
                key: "_drawNodes",
                value: function _drawNodes(ctx) {
                  var alwaysShow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var nodes = this.body.nodes;
                  var nodeIndices = this.body.nodeIndices;
                  var node = void 0;
                  var selected = [];
                  var margin = 20;
                  var topLeft = this.canvas.DOMtoCanvas({ x: -margin, y: -margin });
                  var bottomRight = this.canvas.DOMtoCanvas({
                    x: this.canvas.frame.canvas.clientWidth + margin,
                    y: this.canvas.frame.canvas.clientHeight + margin
                  });
                  var viewableArea = { top: topLeft.y, left: topLeft.x, bottom: bottomRight.y, right: bottomRight.x };
                  for (var i = 0; i < nodeIndices.length; i++) {
                    node = nodes[nodeIndices[i]];
                    if (node.isSelected()) {
                      selected.push(nodeIndices[i]);
                    } else {
                      if (alwaysShow === true) {
                        node.draw(ctx);
                      } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {
                        node.draw(ctx);
                      } else {
                        node.updateBoundingBox(ctx, node.selected);
                      }
                    }
                  }
                  for (var _i = 0; _i < selected.length; _i++) {
                    node = nodes[selected[_i]];
                    node.draw(ctx);
                  }
                }
                /**
                 * Redraw all edges
                 * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
                 * @private
                 */
              }, {
                key: "_drawEdges",
                value: function _drawEdges(ctx) {
                  var edges = this.body.edges;
                  var edgeIndices = this.body.edgeIndices;
                  var edge = void 0;
                  for (var i = 0; i < edgeIndices.length; i++) {
                    edge = edges[edgeIndices[i]];
                    if (edge.connected === true) {
                      edge.draw(ctx);
                    }
                  }
                }
                /**
                 * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
                 * some implementations (safari and IE9) did not support requestAnimationFrame
                 * @private
                 */
              }, {
                key: "_determineBrowserMethod",
                value: function _determineBrowserMethod() {
                  if (typeof window !== "undefined") {
                    var browserType = navigator.userAgent.toLowerCase();
                    this.requiresTimeout = false;
                    if (browserType.indexOf("msie 9.0") != -1) {
                      this.requiresTimeout = true;
                    } else if (browserType.indexOf("safari") != -1) {
                      if (browserType.indexOf("chrome") <= -1) {
                        this.requiresTimeout = true;
                      }
                    }
                  } else {
                    this.requiresTimeout = true;
                  }
                }
              }]);
              return CanvasRenderer2;
            }();
            exports2["default"] = CanvasRenderer;
          },
          /* 230 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(10);
            var hammerUtil = __webpack_require__(37);
            var util = __webpack_require__(2);
            var Canvas = function() {
              function Canvas2(body) {
                (0, _classCallCheck3["default"])(this, Canvas2);
                this.body = body;
                this.pixelRatio = 1;
                this.resizeTimer = void 0;
                this.resizeFunction = this._onResize.bind(this);
                this.cameraState = {};
                this.initialized = false;
                this.canvasViewCenter = {};
                this.options = {};
                this.defaultOptions = {
                  autoResize: true,
                  height: "100%",
                  width: "100%"
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(Canvas2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.once("resize", function(obj) {
                    if (obj.width !== 0) {
                      _this.body.view.translation.x = obj.width * 0.5;
                    }
                    if (obj.height !== 0) {
                      _this.body.view.translation.y = obj.height * 0.5;
                    }
                  });
                  this.body.emitter.on("setSize", this.setSize.bind(this));
                  this.body.emitter.on("destroy", function() {
                    _this.hammerFrame.destroy();
                    _this.hammer.destroy();
                    _this._cleanUp();
                  });
                }
                /**
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  var _this2 = this;
                  if (options !== void 0) {
                    var fields = ["width", "height", "autoResize"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                  if (this.options.autoResize === true) {
                    this._cleanUp();
                    this.resizeTimer = setInterval(function() {
                      var changed = _this2.setSize();
                      if (changed === true) {
                        _this2.body.emitter.emit("_requestRedraw");
                      }
                    }, 1e3);
                    this.resizeFunction = this._onResize.bind(this);
                    util.addEventListener(window, "resize", this.resizeFunction);
                  }
                }
                /**
                 * @private
                 */
              }, {
                key: "_cleanUp",
                value: function _cleanUp() {
                  if (this.resizeTimer !== void 0) {
                    clearInterval(this.resizeTimer);
                  }
                  util.removeEventListener(window, "resize", this.resizeFunction);
                  this.resizeFunction = void 0;
                }
                /**
                 * @private
                 */
              }, {
                key: "_onResize",
                value: function _onResize() {
                  this.setSize();
                  this.body.emitter.emit("_redraw");
                }
                /**
                 * Get and store the cameraState
                 *
                 * @param {number} [pixelRatio=this.pixelRatio]
                 * @private
                 */
              }, {
                key: "_getCameraState",
                value: function _getCameraState() {
                  var pixelRatio = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pixelRatio;
                  if (this.initialized === true) {
                    this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;
                    this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;
                    this.cameraState.scale = this.body.view.scale;
                    this.cameraState.position = this.DOMtoCanvas({
                      x: 0.5 * this.frame.canvas.width / pixelRatio,
                      y: 0.5 * this.frame.canvas.height / pixelRatio
                    });
                  }
                }
                /**
                 * Set the cameraState
                 * @private
                 */
              }, {
                key: "_setCameraState",
                value: function _setCameraState() {
                  if (this.cameraState.scale !== void 0 && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0) {
                    var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;
                    var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;
                    var newScale = this.cameraState.scale;
                    if (widthRatio != 1 && heightRatio != 1) {
                      newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);
                    } else if (widthRatio != 1) {
                      newScale = this.cameraState.scale * widthRatio;
                    } else if (heightRatio != 1) {
                      newScale = this.cameraState.scale * heightRatio;
                    }
                    this.body.view.scale = newScale;
                    var currentViewCenter = this.DOMtoCanvas({
                      x: 0.5 * this.frame.canvas.clientWidth,
                      y: 0.5 * this.frame.canvas.clientHeight
                    });
                    var distanceFromCenter = {
                      // offset from view, distance view has to change by these x and y to center the node
                      x: currentViewCenter.x - this.cameraState.position.x,
                      y: currentViewCenter.y - this.cameraState.position.y
                    };
                    this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;
                    this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;
                  }
                }
                /**
                 *
                 * @param {number|string} value
                 * @returns {string}
                 * @private
                 */
              }, {
                key: "_prepareValue",
                value: function _prepareValue(value) {
                  if (typeof value === "number") {
                    return value + "px";
                  } else if (typeof value === "string") {
                    if (value.indexOf("%") !== -1 || value.indexOf("px") !== -1) {
                      return value;
                    } else if (value.indexOf("%") === -1) {
                      return value + "px";
                    }
                  }
                  throw new Error("Could not use the value supplied for width or height:" + value);
                }
                /**
                 * Create the HTML
                 */
              }, {
                key: "_create",
                value: function _create() {
                  while (this.body.container.hasChildNodes()) {
                    this.body.container.removeChild(this.body.container.firstChild);
                  }
                  this.frame = document.createElement("div");
                  this.frame.className = "vis-network";
                  this.frame.style.position = "relative";
                  this.frame.style.overflow = "hidden";
                  this.frame.tabIndex = 900;
                  this.frame.canvas = document.createElement("canvas");
                  this.frame.canvas.style.position = "relative";
                  this.frame.appendChild(this.frame.canvas);
                  if (!this.frame.canvas.getContext) {
                    var noCanvas = document.createElement("DIV");
                    noCanvas.style.color = "red";
                    noCanvas.style.fontWeight = "bold";
                    noCanvas.style.padding = "10px";
                    noCanvas.innerHTML = "Error: your browser does not support HTML canvas";
                    this.frame.canvas.appendChild(noCanvas);
                  } else {
                    this._setPixelRatio();
                    this.setTransform();
                  }
                  this.body.container.appendChild(this.frame);
                  this.body.view.scale = 1;
                  this.body.view.translation = { x: 0.5 * this.frame.canvas.clientWidth, y: 0.5 * this.frame.canvas.clientHeight };
                  this._bindHammer();
                }
                /**
                 * This function binds hammer, it can be repeated over and over due to the uniqueness check.
                 * @private
                 */
              }, {
                key: "_bindHammer",
                value: function _bindHammer() {
                  var _this3 = this;
                  if (this.hammer !== void 0) {
                    this.hammer.destroy();
                  }
                  this.drag = {};
                  this.pinch = {};
                  this.hammer = new Hammer(this.frame.canvas);
                  this.hammer.get("pinch").set({ enable: true });
                  this.hammer.get("pan").set({ threshold: 5, direction: Hammer.DIRECTION_ALL });
                  hammerUtil.onTouch(this.hammer, function(event) {
                    _this3.body.eventListeners.onTouch(event);
                  });
                  this.hammer.on("tap", function(event) {
                    _this3.body.eventListeners.onTap(event);
                  });
                  this.hammer.on("doubletap", function(event) {
                    _this3.body.eventListeners.onDoubleTap(event);
                  });
                  this.hammer.on("press", function(event) {
                    _this3.body.eventListeners.onHold(event);
                  });
                  this.hammer.on("panstart", function(event) {
                    _this3.body.eventListeners.onDragStart(event);
                  });
                  this.hammer.on("panmove", function(event) {
                    _this3.body.eventListeners.onDrag(event);
                  });
                  this.hammer.on("panend", function(event) {
                    _this3.body.eventListeners.onDragEnd(event);
                  });
                  this.hammer.on("pinch", function(event) {
                    _this3.body.eventListeners.onPinch(event);
                  });
                  this.frame.canvas.addEventListener("mousewheel", function(event) {
                    _this3.body.eventListeners.onMouseWheel(event);
                  });
                  this.frame.canvas.addEventListener("DOMMouseScroll", function(event) {
                    _this3.body.eventListeners.onMouseWheel(event);
                  });
                  this.frame.canvas.addEventListener("mousemove", function(event) {
                    _this3.body.eventListeners.onMouseMove(event);
                  });
                  this.frame.canvas.addEventListener("contextmenu", function(event) {
                    _this3.body.eventListeners.onContext(event);
                  });
                  this.hammerFrame = new Hammer(this.frame);
                  hammerUtil.onRelease(this.hammerFrame, function(event) {
                    _this3.body.eventListeners.onRelease(event);
                  });
                }
                /**
                 * Set a new size for the network
                 * @param {string} width   Width in pixels or percentage (for example '800px'
                 *                         or '50%')
                 * @param {string} height  Height in pixels or percentage  (for example '400px'
                 *                         or '30%')
                 * @returns {boolean}
                 */
              }, {
                key: "setSize",
                value: function setSize() {
                  var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.width;
                  var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.height;
                  width = this._prepareValue(width);
                  height = this._prepareValue(height);
                  var emitEvent = false;
                  var oldWidth = this.frame.canvas.width;
                  var oldHeight = this.frame.canvas.height;
                  var previousRatio = this.pixelRatio;
                  this._setPixelRatio();
                  if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {
                    this._getCameraState(previousRatio);
                    this.frame.style.width = width;
                    this.frame.style.height = height;
                    this.frame.canvas.style.width = "100%";
                    this.frame.canvas.style.height = "100%";
                    this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
                    this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
                    this.options.width = width;
                    this.options.height = height;
                    this.canvasViewCenter = {
                      x: 0.5 * this.frame.clientWidth,
                      y: 0.5 * this.frame.clientHeight
                    };
                    emitEvent = true;
                  } else {
                    var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);
                    var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);
                    if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {
                      this._getCameraState(previousRatio);
                    }
                    if (this.frame.canvas.width !== newWidth) {
                      this.frame.canvas.width = newWidth;
                      emitEvent = true;
                    }
                    if (this.frame.canvas.height !== newHeight) {
                      this.frame.canvas.height = newHeight;
                      emitEvent = true;
                    }
                  }
                  if (emitEvent === true) {
                    this.body.emitter.emit("resize", {
                      width: Math.round(this.frame.canvas.width / this.pixelRatio),
                      height: Math.round(this.frame.canvas.height / this.pixelRatio),
                      oldWidth: Math.round(oldWidth / this.pixelRatio),
                      oldHeight: Math.round(oldHeight / this.pixelRatio)
                    });
                    this._setCameraState();
                  }
                  this.initialized = true;
                  return emitEvent;
                }
                /**
                 *
                 * @returns {CanvasRenderingContext2D}
                 */
              }, {
                key: "getContext",
                value: function getContext() {
                  return this.frame.canvas.getContext("2d");
                }
                /**
                 * Determine the pixel ratio for various browsers.
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_determinePixelRatio",
                value: function _determinePixelRatio() {
                  var ctx = this.getContext();
                  if (ctx === void 0) {
                    throw new Error("Could not get canvax context");
                  }
                  var numerator = 1;
                  if (typeof window !== "undefined") {
                    numerator = window.devicePixelRatio || 1;
                  }
                  var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
                  return numerator / denominator;
                }
                /**
                 * Lazy determination of pixel ratio.
                 *
                 * @private
                 */
              }, {
                key: "_setPixelRatio",
                value: function _setPixelRatio() {
                  this.pixelRatio = this._determinePixelRatio();
                }
                /**
                 * Set the transform in the contained context, based on its pixelRatio
                 */
              }, {
                key: "setTransform",
                value: function setTransform() {
                  var ctx = this.getContext();
                  if (ctx === void 0) {
                    throw new Error("Could not get canvax context");
                  }
                  ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                }
                /**
                 * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
                 * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
                 * @param {number} x
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_XconvertDOMtoCanvas",
                value: function _XconvertDOMtoCanvas(x) {
                  return (x - this.body.view.translation.x) / this.body.view.scale;
                }
                /**
                 * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
                 * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
                 * @param {number} x
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_XconvertCanvasToDOM",
                value: function _XconvertCanvasToDOM(x) {
                  return x * this.body.view.scale + this.body.view.translation.x;
                }
                /**
                 * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
                 * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
                 * @param {number} y
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_YconvertDOMtoCanvas",
                value: function _YconvertDOMtoCanvas(y) {
                  return (y - this.body.view.translation.y) / this.body.view.scale;
                }
                /**
                 * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
                 * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
                 * @param {number} y
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_YconvertCanvasToDOM",
                value: function _YconvertCanvasToDOM(y) {
                  return y * this.body.view.scale + this.body.view.translation.y;
                }
                /**
                 * @param {point} pos
                 * @returns {point}
                 */
              }, {
                key: "canvasToDOM",
                value: function canvasToDOM(pos) {
                  return { x: this._XconvertCanvasToDOM(pos.x), y: this._YconvertCanvasToDOM(pos.y) };
                }
                /**
                 *
                 * @param {point} pos
                 * @returns {point}
                 */
              }, {
                key: "DOMtoCanvas",
                value: function DOMtoCanvas(pos) {
                  return { x: this._XconvertDOMtoCanvas(pos.x), y: this._YconvertDOMtoCanvas(pos.y) };
                }
              }]);
              return Canvas2;
            }();
            exports2["default"] = Canvas;
          },
          /* 231 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(76)["default"];
            var View = function() {
              function View2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, View2);
                this.body = body;
                this.canvas = canvas;
                this.animationSpeed = 1 / this.renderRefreshRate;
                this.animationEasingFunction = "easeInOutQuint";
                this.easingTime = 0;
                this.sourceScale = 0;
                this.targetScale = 0;
                this.sourceTranslation = 0;
                this.targetTranslation = 0;
                this.lockedOnNodeId = void 0;
                this.lockedOnNodeOffset = void 0;
                this.touchTime = 0;
                this.viewFunction = void 0;
                this.body.emitter.on("fit", this.fit.bind(this));
                this.body.emitter.on("animationFinished", function() {
                  _this.body.emitter.emit("_stopRendering");
                });
                this.body.emitter.on("unlockNode", this.releaseNode.bind(this));
              }
              (0, _createClass3["default"])(View2, [{
                key: "setOptions",
                value: function setOptions() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  this.options = options;
                }
                /**
                 * This function zooms out to fit all data on screen based on amount of nodes
                 * @param {Object} [options={{nodes=Array}}]
                 * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
                 */
              }, {
                key: "fit",
                value: function fit() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { nodes: [] };
                  var initialZoom = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var range = void 0;
                  var zoomLevel = void 0;
                  if (options.nodes === void 0 || options.nodes.length === 0) {
                    options.nodes = this.body.nodeIndices;
                  }
                  if (initialZoom === true) {
                    var positionDefined = 0;
                    for (var nodeId in this.body.nodes) {
                      if (this.body.nodes.hasOwnProperty(nodeId)) {
                        var node = this.body.nodes[nodeId];
                        if (node.predefinedPosition === true) {
                          positionDefined += 1;
                        }
                      }
                    }
                    if (positionDefined > 0.5 * this.body.nodeIndices.length) {
                      this.fit(options, false);
                      return;
                    }
                    range = NetworkUtil.getRange(this.body.nodes, options.nodes);
                    var numberOfNodes = this.body.nodeIndices.length;
                    zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822;
                    var factor = Math.min(this.canvas.frame.canvas.clientWidth / 600, this.canvas.frame.canvas.clientHeight / 600);
                    zoomLevel *= factor;
                  } else {
                    this.body.emitter.emit("_resizeNodes");
                    range = NetworkUtil.getRange(this.body.nodes, options.nodes);
                    var xDistance = Math.abs(range.maxX - range.minX) * 1.1;
                    var yDistance = Math.abs(range.maxY - range.minY) * 1.1;
                    var xZoomLevel = this.canvas.frame.canvas.clientWidth / xDistance;
                    var yZoomLevel = this.canvas.frame.canvas.clientHeight / yDistance;
                    zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;
                  }
                  if (zoomLevel > 1) {
                    zoomLevel = 1;
                  } else if (zoomLevel === 0) {
                    zoomLevel = 1;
                  }
                  var center = NetworkUtil.findCenter(range);
                  var animationOptions = { position: center, scale: zoomLevel, animation: options.animation };
                  this.moveTo(animationOptions);
                }
                // animation
                /**
                 * Center a node in view.
                 *
                 * @param {number} nodeId
                 * @param {number} [options]
                 */
              }, {
                key: "focus",
                value: function focus(nodeId) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (this.body.nodes[nodeId] !== void 0) {
                    var nodePosition = { x: this.body.nodes[nodeId].x, y: this.body.nodes[nodeId].y };
                    options.position = nodePosition;
                    options.lockedOnNode = nodeId;
                    this.moveTo(options);
                  } else {
                    console.log("Node: " + nodeId + " cannot be found.");
                  }
                }
                /**
                 *
                 * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
                 *                          |  options.scale    = number                 // scale to move to
                 *                          |  options.position = {x:number, y:number}   // position to move to
                 *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
                 */
              }, {
                key: "moveTo",
                value: function moveTo(options) {
                  if (options === void 0) {
                    options = {};
                    return;
                  }
                  if (options.offset === void 0) {
                    options.offset = { x: 0, y: 0 };
                  }
                  if (options.offset.x === void 0) {
                    options.offset.x = 0;
                  }
                  if (options.offset.y === void 0) {
                    options.offset.y = 0;
                  }
                  if (options.scale === void 0) {
                    options.scale = this.body.view.scale;
                  }
                  if (options.position === void 0) {
                    options.position = this.getViewPosition();
                  }
                  if (options.animation === void 0) {
                    options.animation = { duration: 0 };
                  }
                  if (options.animation === false) {
                    options.animation = { duration: 0 };
                  }
                  if (options.animation === true) {
                    options.animation = {};
                  }
                  if (options.animation.duration === void 0) {
                    options.animation.duration = 1e3;
                  }
                  if (options.animation.easingFunction === void 0) {
                    options.animation.easingFunction = "easeInOutQuad";
                  }
                  this.animateView(options);
                }
                /**
                 *
                 * @param {Object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
                 *                          |  options.time     = number                 // animation time in milliseconds
                 *                          |  options.scale    = number                 // scale to animate to
                 *                          |  options.position = {x:number, y:number}   // position to animate to
                 *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
                 *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
                 *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
                 *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
                 */
              }, {
                key: "animateView",
                value: function animateView(options) {
                  if (options === void 0) {
                    return;
                  }
                  this.animationEasingFunction = options.animation.easingFunction;
                  this.releaseNode();
                  if (options.locked === true) {
                    this.lockedOnNodeId = options.lockedOnNode;
                    this.lockedOnNodeOffset = options.offset;
                  }
                  if (this.easingTime != 0) {
                    this._transitionRedraw(true);
                  }
                  this.sourceScale = this.body.view.scale;
                  this.sourceTranslation = this.body.view.translation;
                  this.targetScale = options.scale;
                  this.body.view.scale = this.targetScale;
                  var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
                  var distanceFromCenter = {
                    // offset from view, distance view has to change by these x and y to center the node
                    x: viewCenter.x - options.position.x,
                    y: viewCenter.y - options.position.y
                  };
                  this.targetTranslation = {
                    x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,
                    y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y
                  };
                  if (options.animation.duration === 0) {
                    if (this.lockedOnNodeId != void 0) {
                      this.viewFunction = this._lockedRedraw.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                    } else {
                      this.body.view.scale = this.targetScale;
                      this.body.view.translation = this.targetTranslation;
                      this.body.emitter.emit("_requestRedraw");
                    }
                  } else {
                    this.animationSpeed = 1 / (60 * options.animation.duration * 1e-3) || 1 / 60;
                    this.animationEasingFunction = options.animation.easingFunction;
                    this.viewFunction = this._transitionRedraw.bind(this);
                    this.body.emitter.on("initRedraw", this.viewFunction);
                    this.body.emitter.emit("_startRendering");
                  }
                }
                /**
                 * used to animate smoothly by hijacking the redraw function.
                 * @private
                 */
              }, {
                key: "_lockedRedraw",
                value: function _lockedRedraw() {
                  var nodePosition = { x: this.body.nodes[this.lockedOnNodeId].x, y: this.body.nodes[this.lockedOnNodeId].y };
                  var viewCenter = this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
                  var distanceFromCenter = {
                    // offset from view, distance view has to change by these x and y to center the node
                    x: viewCenter.x - nodePosition.x,
                    y: viewCenter.y - nodePosition.y
                  };
                  var sourceTranslation = this.body.view.translation;
                  var targetTranslation = {
                    x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,
                    y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y
                  };
                  this.body.view.translation = targetTranslation;
                }
                /**
                 * Resets state of a locked on Node
                 */
              }, {
                key: "releaseNode",
                value: function releaseNode() {
                  if (this.lockedOnNodeId !== void 0 && this.viewFunction !== void 0) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.lockedOnNodeId = void 0;
                    this.lockedOnNodeOffset = void 0;
                  }
                }
                /**
                 * @param {boolean} [finished=false]
                 * @private
                 */
              }, {
                key: "_transitionRedraw",
                value: function _transitionRedraw() {
                  var finished = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  this.easingTime += this.animationSpeed;
                  this.easingTime = finished === true ? 1 : this.easingTime;
                  var progress = util.easingFunctions[this.animationEasingFunction](this.easingTime);
                  this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;
                  this.body.view.translation = {
                    x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,
                    y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress
                  };
                  if (this.easingTime >= 1) {
                    this.body.emitter.off("initRedraw", this.viewFunction);
                    this.easingTime = 0;
                    if (this.lockedOnNodeId != void 0) {
                      this.viewFunction = this._lockedRedraw.bind(this);
                      this.body.emitter.on("initRedraw", this.viewFunction);
                    }
                    this.body.emitter.emit("animationFinished");
                  }
                }
                /**
                 *
                 * @returns {number}
                 */
              }, {
                key: "getScale",
                value: function getScale() {
                  return this.body.view.scale;
                }
                /**
                 *
                 * @returns {{x: number, y: number}}
                 */
              }, {
                key: "getViewPosition",
                value: function getViewPosition() {
                  return this.canvas.DOMtoCanvas({ x: 0.5 * this.canvas.frame.canvas.clientWidth, y: 0.5 * this.canvas.frame.canvas.clientHeight });
                }
              }]);
              return View2;
            }();
            exports2["default"] = View;
          },
          /* 232 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NavigationHandler = __webpack_require__(233)["default"];
            var Popup = __webpack_require__(104)["default"];
            var InteractionHandler = function() {
              function InteractionHandler2(body, canvas, selectionHandler) {
                (0, _classCallCheck3["default"])(this, InteractionHandler2);
                this.body = body;
                this.canvas = canvas;
                this.selectionHandler = selectionHandler;
                this.navigationHandler = new NavigationHandler(body, canvas);
                this.body.eventListeners.onTap = this.onTap.bind(this);
                this.body.eventListeners.onTouch = this.onTouch.bind(this);
                this.body.eventListeners.onDoubleTap = this.onDoubleTap.bind(this);
                this.body.eventListeners.onHold = this.onHold.bind(this);
                this.body.eventListeners.onDragStart = this.onDragStart.bind(this);
                this.body.eventListeners.onDrag = this.onDrag.bind(this);
                this.body.eventListeners.onDragEnd = this.onDragEnd.bind(this);
                this.body.eventListeners.onMouseWheel = this.onMouseWheel.bind(this);
                this.body.eventListeners.onPinch = this.onPinch.bind(this);
                this.body.eventListeners.onMouseMove = this.onMouseMove.bind(this);
                this.body.eventListeners.onRelease = this.onRelease.bind(this);
                this.body.eventListeners.onContext = this.onContext.bind(this);
                this.touchTime = 0;
                this.drag = {};
                this.pinch = {};
                this.popup = void 0;
                this.popupObj = void 0;
                this.popupTimer = void 0;
                this.body.functions.getPointer = this.getPointer.bind(this);
                this.options = {};
                this.defaultOptions = {
                  dragNodes: true,
                  dragView: true,
                  hover: false,
                  keyboard: {
                    enabled: false,
                    speed: { x: 10, y: 10, zoom: 0.02 },
                    bindToWindow: true
                  },
                  navigationButtons: false,
                  tooltipDelay: 300,
                  zoomView: true
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(InteractionHandler2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this = this;
                  this.body.emitter.on("destroy", function() {
                    clearTimeout(_this.popupTimer);
                    delete _this.body.functions.getPointer;
                  });
                }
                /**
                 *
                 * @param {Object} options
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["hideEdgesOnDrag", "hideNodesOnDrag", "keyboard", "multiselect", "selectable", "selectConnectedEdges"];
                    util.selectiveNotDeepExtend(fields, this.options, options);
                    util.mergeOptions(this.options, options, "keyboard");
                    if (options.tooltip) {
                      util.extend(this.options.tooltip, options.tooltip);
                      if (options.tooltip.color) {
                        this.options.tooltip.color = util.parseColor(options.tooltip.color);
                      }
                    }
                  }
                  this.navigationHandler.setOptions(this.options);
                }
                /**
                 * Get the pointer location from a touch location
                 * @param {{x: number, y: number}} touch
                 * @return {{x: number, y: number}} pointer
                 * @private
                 */
              }, {
                key: "getPointer",
                value: function getPointer(touch) {
                  return {
                    x: touch.x - util.getAbsoluteLeft(this.canvas.frame.canvas),
                    y: touch.y - util.getAbsoluteTop(this.canvas.frame.canvas)
                  };
                }
                /**
                 * On start of a touch gesture, store the pointer
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "onTouch",
                value: function onTouch(event) {
                  if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 50) {
                    this.drag.pointer = this.getPointer(event.center);
                    this.drag.pinched = false;
                    this.pinch.scale = this.body.view.scale;
                    this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
                  }
                }
                /**
                 * handle tap/click event: select/unselect a node
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onTap",
                value: function onTap(event) {
                  var pointer = this.getPointer(event.center);
                  var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);
                  this.checkSelectionChanges(pointer, event, multiselect);
                  this.selectionHandler._generateClickEvent("click", event, pointer);
                }
                /**
                 * handle doubletap event
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onDoubleTap",
                value: function onDoubleTap(event) {
                  var pointer = this.getPointer(event.center);
                  this.selectionHandler._generateClickEvent("doubleClick", event, pointer);
                }
                /**
                 * handle long tap event: multi select nodes
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onHold",
                value: function onHold(event) {
                  var pointer = this.getPointer(event.center);
                  var multiselect = this.selectionHandler.options.multiselect;
                  this.checkSelectionChanges(pointer, event, multiselect);
                  this.selectionHandler._generateClickEvent("click", event, pointer);
                  this.selectionHandler._generateClickEvent("hold", event, pointer);
                }
                /**
                 * handle the release of the screen
                 *
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onRelease",
                value: function onRelease(event) {
                  if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 10) {
                    var pointer = this.getPointer(event.center);
                    this.selectionHandler._generateClickEvent("release", event, pointer);
                    this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
                  }
                }
                /**
                 *
                 * @param {Event} event
                 */
              }, {
                key: "onContext",
                value: function onContext(event) {
                  var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                  this.selectionHandler._generateClickEvent("oncontext", event, pointer);
                }
                /**
                 * Select and deselect nodes depending current selection change.
                 *
                 * For changing nodes, select/deselect events are fired.
                 *
                 * NOTE: For a given edge, if one connecting node is deselected and with the same
                 *       click the other node is selected, no events for the edge will fire.
                 *       It was selected and it will remain selected.
                 *
                 * TODO: This is all SelectionHandler calls; the method should be moved to there.
                 *
                 * @param {{x: number, y: number}} pointer
                 * @param {Event} event
                 * @param {boolean} [add=false]
                 */
              }, {
                key: "checkSelectionChanges",
                value: function checkSelectionChanges(pointer, event) {
                  var add = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var previousSelection = this.selectionHandler.getSelection();
                  var selected = false;
                  if (add === true) {
                    selected = this.selectionHandler.selectAdditionalOnPoint(pointer);
                  } else {
                    selected = this.selectionHandler.selectOnPoint(pointer);
                  }
                  var currentSelection = this.selectionHandler.getSelection();
                  var deselectedItems = this._determineDifference(previousSelection, currentSelection);
                  var selectedItems = this._determineDifference(currentSelection, previousSelection);
                  if (deselectedItems.edges.length > 0) {
                    this.selectionHandler._generateClickEvent("deselectEdge", event, pointer, previousSelection);
                    selected = true;
                  }
                  if (deselectedItems.nodes.length > 0) {
                    this.selectionHandler._generateClickEvent("deselectNode", event, pointer, previousSelection);
                    selected = true;
                  }
                  if (selectedItems.nodes.length > 0) {
                    this.selectionHandler._generateClickEvent("selectNode", event, pointer);
                    selected = true;
                  }
                  if (selectedItems.edges.length > 0) {
                    this.selectionHandler._generateClickEvent("selectEdge", event, pointer);
                    selected = true;
                  }
                  if (selected === true) {
                    this.selectionHandler._generateClickEvent("select", event, pointer);
                  }
                }
                /**
                 * Remove all node and edge id's from the first set that are present in the second one.
                 *
                 * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
                 * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
                 * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
                 * @private
                 */
              }, {
                key: "_determineDifference",
                value: function _determineDifference(firstSet, secondSet) {
                  var arrayDiff = function arrayDiff2(firstArr, secondArr) {
                    var result = [];
                    for (var i = 0; i < firstArr.length; i++) {
                      var value = firstArr[i];
                      if (secondArr.indexOf(value) === -1) {
                        result.push(value);
                      }
                    }
                    return result;
                  };
                  return {
                    nodes: arrayDiff(firstSet.nodes, secondSet.nodes),
                    edges: arrayDiff(firstSet.edges, secondSet.edges)
                  };
                }
                /**
                 * This function is called by onDragStart.
                 * It is separated out because we can then overload it for the datamanipulation system.
                 *
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onDragStart",
                value: function onDragStart(event) {
                  if (this.drag.pointer === void 0) {
                    this.onTouch(event);
                  }
                  var node = this.selectionHandler.getNodeAt(this.drag.pointer);
                  this.drag.dragging = true;
                  this.drag.selection = [];
                  this.drag.translation = util.extend({}, this.body.view.translation);
                  this.drag.nodeId = void 0;
                  if (node !== void 0 && this.options.dragNodes === true) {
                    this.drag.nodeId = node.id;
                    if (node.isSelected() === false) {
                      this.selectionHandler.unselectAll();
                      this.selectionHandler.selectObject(node);
                    }
                    this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer);
                    var selection = this.selectionHandler.selectionObj.nodes;
                    for (var nodeId in selection) {
                      if (selection.hasOwnProperty(nodeId)) {
                        var object = selection[nodeId];
                        var s = {
                          id: object.id,
                          node: object,
                          // store original x, y, xFixed and yFixed, make the node temporarily Fixed
                          x: object.x,
                          y: object.y,
                          xFixed: object.options.fixed.x,
                          yFixed: object.options.fixed.y
                        };
                        object.options.fixed.x = true;
                        object.options.fixed.y = true;
                        this.drag.selection.push(s);
                      }
                    }
                  } else {
                    this.selectionHandler._generateClickEvent("dragStart", event, this.drag.pointer, void 0, true);
                  }
                }
                /**
                 * handle drag event
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onDrag",
                value: function onDrag(event) {
                  var _this2 = this;
                  if (this.drag.pinched === true) {
                    return;
                  }
                  this.body.emitter.emit("unlockNode");
                  var pointer = this.getPointer(event.center);
                  var selection = this.drag.selection;
                  if (selection && selection.length && this.options.dragNodes === true) {
                    this.selectionHandler._generateClickEvent("dragging", event, pointer);
                    var deltaX = pointer.x - this.drag.pointer.x;
                    var deltaY = pointer.y - this.drag.pointer.y;
                    selection.forEach(function(selection2) {
                      var node = selection2.node;
                      if (selection2.xFixed === false) {
                        node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection2.x) + deltaX);
                      }
                      if (selection2.yFixed === false) {
                        node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection2.y) + deltaY);
                      }
                    });
                    this.body.emitter.emit("startSimulation");
                  } else {
                    if (this.options.dragView === true) {
                      this.selectionHandler._generateClickEvent("dragging", event, pointer, void 0, true);
                      if (this.drag.pointer === void 0) {
                        this.onDragStart(event);
                        return;
                      }
                      var diffX = pointer.x - this.drag.pointer.x;
                      var diffY = pointer.y - this.drag.pointer.y;
                      this.body.view.translation = { x: this.drag.translation.x + diffX, y: this.drag.translation.y + diffY };
                      this.body.emitter.emit("_requestRedraw");
                    }
                  }
                }
                /**
                 * handle drag start event
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "onDragEnd",
                value: function onDragEnd(event) {
                  this.drag.dragging = false;
                  var selection = this.drag.selection;
                  if (selection && selection.length) {
                    selection.forEach(function(s) {
                      s.node.options.fixed.x = s.xFixed;
                      s.node.options.fixed.y = s.yFixed;
                    });
                    this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center));
                    this.body.emitter.emit("startSimulation");
                  } else {
                    this.selectionHandler._generateClickEvent("dragEnd", event, this.getPointer(event.center), void 0, true);
                    this.body.emitter.emit("_requestRedraw");
                  }
                }
                /**
                 * Handle pinch event
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "onPinch",
                value: function onPinch(event) {
                  var pointer = this.getPointer(event.center);
                  this.drag.pinched = true;
                  if (this.pinch["scale"] === void 0) {
                    this.pinch.scale = 1;
                  }
                  var scale = this.pinch.scale * event.scale;
                  this.zoom(scale, pointer);
                }
                /**
                 * Zoom the network in or out
                 * @param {number} scale a number around 1, and between 0.01 and 10
                 * @param {{x: number, y: number}} pointer    Position on screen
                 * @private
                 */
              }, {
                key: "zoom",
                value: function zoom(scale, pointer) {
                  if (this.options.zoomView === true) {
                    var scaleOld = this.body.view.scale;
                    if (scale < 1e-5) {
                      scale = 1e-5;
                    }
                    if (scale > 10) {
                      scale = 10;
                    }
                    var preScaleDragPointer = void 0;
                    if (this.drag !== void 0) {
                      if (this.drag.dragging === true) {
                        preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);
                      }
                    }
                    var translation = this.body.view.translation;
                    var scaleFrac = scale / scaleOld;
                    var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;
                    var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;
                    this.body.view.scale = scale;
                    this.body.view.translation = { x: tx, y: ty };
                    if (preScaleDragPointer != void 0) {
                      var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);
                      this.drag.pointer.x = postScaleDragPointer.x;
                      this.drag.pointer.y = postScaleDragPointer.y;
                    }
                    this.body.emitter.emit("_requestRedraw");
                    if (scaleOld < scale) {
                      this.body.emitter.emit("zoom", { direction: "+", scale: this.body.view.scale, pointer });
                    } else {
                      this.body.emitter.emit("zoom", { direction: "-", scale: this.body.view.scale, pointer });
                    }
                  }
                }
                /**
                 * Event handler for mouse wheel event, used to zoom the timeline
                 * See http://adomas.org/javascript-mouse-wheel/
                 *     https://github.com/EightMedia/hammer.js/issues/256
                 * @param {MouseEvent}  event
                 * @private
                 */
              }, {
                key: "onMouseWheel",
                value: function onMouseWheel(event) {
                  if (this.options.zoomView === true) {
                    var delta = 0;
                    if (event.wheelDelta) {
                      delta = event.wheelDelta / 120;
                    } else if (event.detail) {
                      delta = -event.detail / 3;
                    }
                    if (delta !== 0) {
                      var scale = this.body.view.scale;
                      var zoom = delta / 10;
                      if (delta < 0) {
                        zoom = zoom / (1 - zoom);
                      }
                      scale *= 1 + zoom;
                      var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                      this.zoom(scale, pointer);
                    }
                    event.preventDefault();
                  }
                }
                /**
                 * Mouse move handler for checking whether the title moves over a node with a title.
                 * @param  {Event} event
                 * @private
                 */
              }, {
                key: "onMouseMove",
                value: function onMouseMove(event) {
                  var _this3 = this;
                  var pointer = this.getPointer({ x: event.clientX, y: event.clientY });
                  var popupVisible = false;
                  if (this.popup !== void 0) {
                    if (this.popup.hidden === false) {
                      this._checkHidePopup(pointer);
                    }
                    if (this.popup.hidden === false) {
                      popupVisible = true;
                      this.popup.setPosition(pointer.x + 3, pointer.y - 5);
                      this.popup.show();
                    }
                  }
                  if (this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {
                    this.canvas.frame.focus();
                  }
                  if (popupVisible === false) {
                    if (this.popupTimer !== void 0) {
                      clearInterval(this.popupTimer);
                      this.popupTimer = void 0;
                    }
                    if (!this.drag.dragging) {
                      this.popupTimer = setTimeout(function() {
                        return _this3._checkShowPopup(pointer);
                      }, this.options.tooltipDelay);
                    }
                  }
                  if (this.options.hover === true) {
                    this.selectionHandler.hoverObject(event, pointer);
                  }
                }
                /**
                 * Check if there is an element on the given position in the network
                 * (a node or edge). If so, and if this element has a title,
                 * show a popup window with its title.
                 *
                 * @param {{x:number, y:number}} pointer
                 * @private
                 */
              }, {
                key: "_checkShowPopup",
                value: function _checkShowPopup(pointer) {
                  var x = this.canvas._XconvertDOMtoCanvas(pointer.x);
                  var y = this.canvas._YconvertDOMtoCanvas(pointer.y);
                  var pointerObj = {
                    left: x,
                    top: y,
                    right: x,
                    bottom: y
                  };
                  var previousPopupObjId = this.popupObj === void 0 ? void 0 : this.popupObj.id;
                  var nodeUnderCursor = false;
                  var popupType = "node";
                  if (this.popupObj === void 0) {
                    var nodeIndices = this.body.nodeIndices;
                    var nodes = this.body.nodes;
                    var node = void 0;
                    var overlappingNodes = [];
                    for (var i = 0; i < nodeIndices.length; i++) {
                      node = nodes[nodeIndices[i]];
                      if (node.isOverlappingWith(pointerObj) === true) {
                        if (node.getTitle() !== void 0) {
                          overlappingNodes.push(nodeIndices[i]);
                        }
                      }
                    }
                    if (overlappingNodes.length > 0) {
                      this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];
                      nodeUnderCursor = true;
                    }
                  }
                  if (this.popupObj === void 0 && nodeUnderCursor === false) {
                    var edgeIndices = this.body.edgeIndices;
                    var edges = this.body.edges;
                    var edge = void 0;
                    var overlappingEdges = [];
                    for (var _i = 0; _i < edgeIndices.length; _i++) {
                      edge = edges[edgeIndices[_i]];
                      if (edge.isOverlappingWith(pointerObj) === true) {
                        if (edge.connected === true && edge.getTitle() !== void 0) {
                          overlappingEdges.push(edgeIndices[_i]);
                        }
                      }
                    }
                    if (overlappingEdges.length > 0) {
                      this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];
                      popupType = "edge";
                    }
                  }
                  if (this.popupObj !== void 0) {
                    if (this.popupObj.id !== previousPopupObjId) {
                      if (this.popup === void 0) {
                        this.popup = new Popup(this.canvas.frame);
                      }
                      this.popup.popupTargetType = popupType;
                      this.popup.popupTargetId = this.popupObj.id;
                      this.popup.setPosition(pointer.x + 3, pointer.y - 5);
                      this.popup.setText(this.popupObj.getTitle());
                      this.popup.show();
                      this.body.emitter.emit("showPopup", this.popupObj.id);
                    }
                  } else {
                    if (this.popup !== void 0) {
                      this.popup.hide();
                      this.body.emitter.emit("hidePopup");
                    }
                  }
                }
                /**
                 * Check if the popup must be hidden, which is the case when the mouse is no
                 * longer hovering on the object
                 * @param {{x:number, y:number}} pointer
                 * @private
                 */
              }, {
                key: "_checkHidePopup",
                value: function _checkHidePopup(pointer) {
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var stillOnObj = false;
                  if (this.popup.popupTargetType === "node") {
                    if (this.body.nodes[this.popup.popupTargetId] !== void 0) {
                      stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);
                      if (stillOnObj === true) {
                        var overNode = this.selectionHandler.getNodeAt(pointer);
                        stillOnObj = overNode === void 0 ? false : overNode.id === this.popup.popupTargetId;
                      }
                    }
                  } else {
                    if (this.selectionHandler.getNodeAt(pointer) === void 0) {
                      if (this.body.edges[this.popup.popupTargetId] !== void 0) {
                        stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);
                      }
                    }
                  }
                  if (stillOnObj === false) {
                    this.popupObj = void 0;
                    this.popup.hide();
                    this.body.emitter.emit("hidePopup");
                  }
                }
              }]);
              return InteractionHandler2;
            }();
            exports2["default"] = InteractionHandler;
          },
          /* 233 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Hammer = __webpack_require__(10);
            var hammerUtil = __webpack_require__(37);
            var keycharm = __webpack_require__(35);
            var NavigationHandler = function() {
              function NavigationHandler2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, NavigationHandler2);
                this.body = body;
                this.canvas = canvas;
                this.iconsCreated = false;
                this.navigationHammers = [];
                this.boundFunctions = {};
                this.touchTime = 0;
                this.activated = false;
                this.body.emitter.on("activate", function() {
                  _this.activated = true;
                  _this.configureKeyboardBindings();
                });
                this.body.emitter.on("deactivate", function() {
                  _this.activated = false;
                  _this.configureKeyboardBindings();
                });
                this.body.emitter.on("destroy", function() {
                  if (_this.keycharm !== void 0) {
                    _this.keycharm.destroy();
                  }
                });
                this.options = {};
              }
              (0, _createClass3["default"])(NavigationHandler2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    this.options = options;
                    this.create();
                  }
                }
                /**
                 * Creates or refreshes navigation and sets key bindings
                 */
              }, {
                key: "create",
                value: function create() {
                  if (this.options.navigationButtons === true) {
                    if (this.iconsCreated === false) {
                      this.loadNavigationElements();
                    }
                  } else if (this.iconsCreated === true) {
                    this.cleanNavigation();
                  }
                  this.configureKeyboardBindings();
                }
                /**
                 * Cleans up previous navigation items
                 */
              }, {
                key: "cleanNavigation",
                value: function cleanNavigation() {
                  if (this.navigationHammers.length != 0) {
                    for (var i = 0; i < this.navigationHammers.length; i++) {
                      this.navigationHammers[i].destroy();
                    }
                    this.navigationHammers = [];
                  }
                  if (this.navigationDOM && this.navigationDOM["wrapper"] && this.navigationDOM["wrapper"].parentNode) {
                    this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);
                  }
                  this.iconsCreated = false;
                }
                /**
                 * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
                 * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
                 * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
                 * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
                 *
                 * @private
                 */
              }, {
                key: "loadNavigationElements",
                value: function loadNavigationElements() {
                  var _this2 = this;
                  this.cleanNavigation();
                  this.navigationDOM = {};
                  var navigationDivs = ["up", "down", "left", "right", "zoomIn", "zoomOut", "zoomExtends"];
                  var navigationDivActions = ["_moveUp", "_moveDown", "_moveLeft", "_moveRight", "_zoomIn", "_zoomOut", "_fit"];
                  this.navigationDOM["wrapper"] = document.createElement("div");
                  this.navigationDOM["wrapper"].className = "vis-navigation";
                  this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);
                  for (var i = 0; i < navigationDivs.length; i++) {
                    this.navigationDOM[navigationDivs[i]] = document.createElement("div");
                    this.navigationDOM[navigationDivs[i]].className = "vis-button vis-" + navigationDivs[i];
                    this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);
                    var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);
                    if (navigationDivActions[i] === "_fit") {
                      hammerUtil.onTouch(hammer, this._fit.bind(this));
                    } else {
                      hammerUtil.onTouch(hammer, this.bindToRedraw.bind(this, navigationDivActions[i]));
                    }
                    this.navigationHammers.push(hammer);
                  }
                  var hammerFrame = new Hammer(this.canvas.frame);
                  hammerUtil.onRelease(hammerFrame, function() {
                    _this2._stopMovement();
                  });
                  this.navigationHammers.push(hammerFrame);
                  this.iconsCreated = true;
                }
                /**
                 *
                 * @param {string} action
                 */
              }, {
                key: "bindToRedraw",
                value: function bindToRedraw(action) {
                  if (this.boundFunctions[action] === void 0) {
                    this.boundFunctions[action] = this[action].bind(this);
                    this.body.emitter.on("initRedraw", this.boundFunctions[action]);
                    this.body.emitter.emit("_startRendering");
                  }
                }
                /**
                 *
                 * @param {string} action
                 */
              }, {
                key: "unbindFromRedraw",
                value: function unbindFromRedraw(action) {
                  if (this.boundFunctions[action] !== void 0) {
                    this.body.emitter.off("initRedraw", this.boundFunctions[action]);
                    this.body.emitter.emit("_stopRendering");
                    delete this.boundFunctions[action];
                  }
                }
                /**
                 * this stops all movement induced by the navigation buttons
                 *
                 * @private
                 */
              }, {
                key: "_fit",
                value: function _fit() {
                  if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 700) {
                    this.body.emitter.emit("fit", { duration: 700 });
                    this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
                  }
                }
                /**
                 * this stops all movement induced by the navigation buttons
                 *
                 * @private
                 */
              }, {
                key: "_stopMovement",
                value: function _stopMovement() {
                  for (var boundAction in this.boundFunctions) {
                    if (this.boundFunctions.hasOwnProperty(boundAction)) {
                      this.body.emitter.off("initRedraw", this.boundFunctions[boundAction]);
                      this.body.emitter.emit("_stopRendering");
                    }
                  }
                  this.boundFunctions = {};
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_moveUp",
                value: function _moveUp() {
                  this.body.view.translation.y += this.options.keyboard.speed.y;
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_moveDown",
                value: function _moveDown() {
                  this.body.view.translation.y -= this.options.keyboard.speed.y;
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_moveLeft",
                value: function _moveLeft() {
                  this.body.view.translation.x += this.options.keyboard.speed.x;
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_moveRight",
                value: function _moveRight() {
                  this.body.view.translation.x -= this.options.keyboard.speed.x;
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_zoomIn",
                value: function _zoomIn() {
                  var scaleOld = this.body.view.scale;
                  var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);
                  var translation = this.body.view.translation;
                  var scaleFrac = scale / scaleOld;
                  var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
                  var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
                  this.body.view.scale = scale;
                  this.body.view.translation = { x: tx, y: ty };
                  this.body.emitter.emit("zoom", { direction: "+", scale: this.body.view.scale, pointer: null });
                }
                /**
                 *
                 * @private
                 */
              }, {
                key: "_zoomOut",
                value: function _zoomOut() {
                  var scaleOld = this.body.view.scale;
                  var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);
                  var translation = this.body.view.translation;
                  var scaleFrac = scale / scaleOld;
                  var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;
                  var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;
                  this.body.view.scale = scale;
                  this.body.view.translation = { x: tx, y: ty };
                  this.body.emitter.emit("zoom", { direction: "-", scale: this.body.view.scale, pointer: null });
                }
                /**
                 * bind all keys using keycharm.
                 */
              }, {
                key: "configureKeyboardBindings",
                value: function configureKeyboardBindings() {
                  var _this3 = this;
                  if (this.keycharm !== void 0) {
                    this.keycharm.destroy();
                  }
                  if (this.options.keyboard.enabled === true) {
                    if (this.options.keyboard.bindToWindow === true) {
                      this.keycharm = keycharm({ container: window, preventDefault: true });
                    } else {
                      this.keycharm = keycharm({ container: this.canvas.frame, preventDefault: true });
                    }
                    this.keycharm.reset();
                    if (this.activated === true) {
                      this.keycharm.bind("up", function() {
                        _this3.bindToRedraw("_moveUp");
                      }, "keydown");
                      this.keycharm.bind("down", function() {
                        _this3.bindToRedraw("_moveDown");
                      }, "keydown");
                      this.keycharm.bind("left", function() {
                        _this3.bindToRedraw("_moveLeft");
                      }, "keydown");
                      this.keycharm.bind("right", function() {
                        _this3.bindToRedraw("_moveRight");
                      }, "keydown");
                      this.keycharm.bind("=", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("num+", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("num-", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("-", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("[", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("]", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("pageup", function() {
                        _this3.bindToRedraw("_zoomIn");
                      }, "keydown");
                      this.keycharm.bind("pagedown", function() {
                        _this3.bindToRedraw("_zoomOut");
                      }, "keydown");
                      this.keycharm.bind("up", function() {
                        _this3.unbindFromRedraw("_moveUp");
                      }, "keyup");
                      this.keycharm.bind("down", function() {
                        _this3.unbindFromRedraw("_moveDown");
                      }, "keyup");
                      this.keycharm.bind("left", function() {
                        _this3.unbindFromRedraw("_moveLeft");
                      }, "keyup");
                      this.keycharm.bind("right", function() {
                        _this3.unbindFromRedraw("_moveRight");
                      }, "keyup");
                      this.keycharm.bind("=", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("num+", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("num-", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("-", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("[", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                      this.keycharm.bind("]", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("pageup", function() {
                        _this3.unbindFromRedraw("_zoomIn");
                      }, "keyup");
                      this.keycharm.bind("pagedown", function() {
                        _this3.unbindFromRedraw("_zoomOut");
                      }, "keyup");
                    }
                  }
                }
              }]);
              return NavigationHandler2;
            }();
            exports2["default"] = NavigationHandler;
          },
          /* 234 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var Node = __webpack_require__(47)["default"];
            var Edge = __webpack_require__(74)["default"];
            var util = __webpack_require__(2);
            var SelectionHandler = function() {
              function SelectionHandler2(body, canvas) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, SelectionHandler2);
                this.body = body;
                this.canvas = canvas;
                this.selectionObj = { nodes: [], edges: [] };
                this.hoverObj = { nodes: {}, edges: {} };
                this.options = {};
                this.defaultOptions = {
                  multiselect: false,
                  selectable: true,
                  selectConnectedEdges: true,
                  hoverConnectedEdges: true
                };
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("_dataChanged", function() {
                  _this.updateSelection();
                });
              }
              (0, _createClass3["default"])(SelectionHandler2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options !== void 0) {
                    var fields = ["multiselect", "hoverConnectedEdges", "selectable", "selectConnectedEdges"];
                    util.selectiveDeepExtend(fields, this.options, options);
                  }
                }
                /**
                 * handles the selection part of the tap;
                 *
                 * @param {{x: number, y: number}} pointer
                 * @returns {boolean}
                 */
              }, {
                key: "selectOnPoint",
                value: function selectOnPoint(pointer) {
                  var selected = false;
                  if (this.options.selectable === true) {
                    var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
                    this.unselectAll();
                    if (obj !== void 0) {
                      selected = this.selectObject(obj);
                    }
                    this.body.emitter.emit("_requestRedraw");
                  }
                  return selected;
                }
                /**
                 *
                 * @param {{x: number, y: number}} pointer
                 * @returns {boolean}
                 */
              }, {
                key: "selectAdditionalOnPoint",
                value: function selectAdditionalOnPoint(pointer) {
                  var selectionChanged = false;
                  if (this.options.selectable === true) {
                    var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);
                    if (obj !== void 0) {
                      selectionChanged = true;
                      if (obj.isSelected() === true) {
                        this.deselectObject(obj);
                      } else {
                        this.selectObject(obj);
                      }
                      this.body.emitter.emit("_requestRedraw");
                    }
                  }
                  return selectionChanged;
                }
                /**
                 * Create an object containing the standard fields for an event.
                 *
                 * @param {Event} event
                 * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
                 * @returns {{}}
                 * @private
                 */
              }, {
                key: "_initBaseEvent",
                value: function _initBaseEvent(event, pointer) {
                  var properties = {};
                  properties["pointer"] = {
                    DOM: { x: pointer.x, y: pointer.y },
                    canvas: this.canvas.DOMtoCanvas(pointer)
                  };
                  properties["event"] = event;
                  return properties;
                }
                /**
                 * Generate an event which the user can catch.
                 *
                 * This adds some extra data to the event with respect to cursor position and
                 * selected nodes and edges.
                 *
                 * @param {string} eventType                          Name of event to send
                 * @param {Event}  event
                 * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
                 * @param {Object|undefined} oldSelection             If present, selection state before event occured
                 * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
                 */
              }, {
                key: "_generateClickEvent",
                value: function _generateClickEvent(eventType, event, pointer, oldSelection) {
                  var emptySelection = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                  var properties = this._initBaseEvent(event, pointer);
                  if (emptySelection === true) {
                    properties.nodes = [];
                    properties.edges = [];
                  } else {
                    var tmp = this.getSelection();
                    properties.nodes = tmp.nodes;
                    properties.edges = tmp.edges;
                  }
                  if (oldSelection !== void 0) {
                    properties["previousSelection"] = oldSelection;
                  }
                  if (eventType == "click") {
                    properties.items = this.getClickedItems(pointer);
                  }
                  this.body.emitter.emit(eventType, properties);
                }
                /**
                 *
                 * @param {Object} obj
                 * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
                 * @returns {boolean}
                 */
              }, {
                key: "selectObject",
                value: function selectObject(obj) {
                  var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.selectConnectedEdges;
                  if (obj !== void 0) {
                    if (obj instanceof Node) {
                      if (highlightEdges === true) {
                        this._selectConnectedEdges(obj);
                      }
                    }
                    obj.select();
                    this._addToSelection(obj);
                    return true;
                  }
                  return false;
                }
                /**
                 *
                 * @param {Object} obj
                 */
              }, {
                key: "deselectObject",
                value: function deselectObject(obj) {
                  if (obj.isSelected() === true) {
                    obj.selected = false;
                    this._removeFromSelection(obj);
                  }
                }
                /**
                 * retrieve all nodes overlapping with given object
                 * @param {Object} object  An object with parameters left, top, right, bottom
                 * @return {number[]}   An array with id's of the overlapping nodes
                 * @private
                 */
              }, {
                key: "_getAllNodesOverlappingWith",
                value: function _getAllNodesOverlappingWith(object) {
                  var overlappingNodes = [];
                  var nodes = this.body.nodes;
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var nodeId = this.body.nodeIndices[i];
                    if (nodes[nodeId].isOverlappingWith(object)) {
                      overlappingNodes.push(nodeId);
                    }
                  }
                  return overlappingNodes;
                }
                /**
                 * Return a position object in canvasspace from a single point in screenspace
                 *
                 * @param {{x: number, y: number}} pointer
                 * @returns {{left: number, top: number, right: number, bottom: number}}
                 * @private
                 */
              }, {
                key: "_pointerToPositionObject",
                value: function _pointerToPositionObject(pointer) {
                  var canvasPos = this.canvas.DOMtoCanvas(pointer);
                  return {
                    left: canvasPos.x - 1,
                    top: canvasPos.y + 1,
                    right: canvasPos.x + 1,
                    bottom: canvasPos.y - 1
                  };
                }
                /**
                 * Get the top node at the passed point (like a click)
                 *
                 * @param {{x: number, y: number}} pointer
                 * @param {boolean} [returnNode=true]
                 * @return {Node | undefined} node
                 */
              }, {
                key: "getNodeAt",
                value: function getNodeAt(pointer) {
                  var returnNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var positionObject = this._pointerToPositionObject(pointer);
                  var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);
                  if (overlappingNodes.length > 0) {
                    if (returnNode === true) {
                      return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];
                    } else {
                      return overlappingNodes[overlappingNodes.length - 1];
                    }
                  } else {
                    return void 0;
                  }
                }
                /**
                 * retrieve all edges overlapping with given object, selector is around center
                 * @param {Object} object  An object with parameters left, top, right, bottom
                 * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
                 * @private
                 */
              }, {
                key: "_getEdgesOverlappingWith",
                value: function _getEdgesOverlappingWith(object, overlappingEdges) {
                  var edges = this.body.edges;
                  for (var i = 0; i < this.body.edgeIndices.length; i++) {
                    var edgeId = this.body.edgeIndices[i];
                    if (edges[edgeId].isOverlappingWith(object)) {
                      overlappingEdges.push(edgeId);
                    }
                  }
                }
                /**
                 * retrieve all nodes overlapping with given object
                 * @param {Object} object  An object with parameters left, top, right, bottom
                 * @return {number[]}   An array with id's of the overlapping nodes
                 * @private
                 */
              }, {
                key: "_getAllEdgesOverlappingWith",
                value: function _getAllEdgesOverlappingWith(object) {
                  var overlappingEdges = [];
                  this._getEdgesOverlappingWith(object, overlappingEdges);
                  return overlappingEdges;
                }
                /**
                 * Get the edges nearest to the passed point (like a click)
                 *
                 * @param {{x: number, y: number}} pointer
                 * @param {boolean} [returnEdge=true]
                 * @return {Edge | undefined} node
                 */
              }, {
                key: "getEdgeAt",
                value: function getEdgeAt(pointer) {
                  var returnEdge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  var canvasPos = this.canvas.DOMtoCanvas(pointer);
                  var mindist = 10;
                  var overlappingEdge = null;
                  var edges = this.body.edges;
                  for (var i = 0; i < this.body.edgeIndices.length; i++) {
                    var edgeId = this.body.edgeIndices[i];
                    var edge = edges[edgeId];
                    if (edge.connected) {
                      var xFrom = edge.from.x;
                      var yFrom = edge.from.y;
                      var xTo = edge.to.x;
                      var yTo = edge.to.y;
                      var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);
                      if (dist < mindist) {
                        overlappingEdge = edgeId;
                        mindist = dist;
                      }
                    }
                  }
                  if (overlappingEdge !== null) {
                    if (returnEdge === true) {
                      return this.body.edges[overlappingEdge];
                    } else {
                      return overlappingEdge;
                    }
                  } else {
                    return void 0;
                  }
                }
                /**
                 * Add object to the selection array.
                 *
                 * @param {Object} obj
                 * @private
                 */
              }, {
                key: "_addToSelection",
                value: function _addToSelection(obj) {
                  if (obj instanceof Node) {
                    this.selectionObj.nodes[obj.id] = obj;
                  } else {
                    this.selectionObj.edges[obj.id] = obj;
                  }
                }
                /**
                 * Add object to the selection array.
                 *
                 * @param {Object} obj
                 * @private
                 */
              }, {
                key: "_addToHover",
                value: function _addToHover(obj) {
                  if (obj instanceof Node) {
                    this.hoverObj.nodes[obj.id] = obj;
                  } else {
                    this.hoverObj.edges[obj.id] = obj;
                  }
                }
                /**
                 * Remove a single option from selection.
                 *
                 * @param {Object} obj
                 * @private
                 */
              }, {
                key: "_removeFromSelection",
                value: function _removeFromSelection(obj) {
                  if (obj instanceof Node) {
                    delete this.selectionObj.nodes[obj.id];
                    this._unselectConnectedEdges(obj);
                  } else {
                    delete this.selectionObj.edges[obj.id];
                  }
                }
                /**
                 * Unselect all. The selectionObj is useful for this.
                 */
              }, {
                key: "unselectAll",
                value: function unselectAll() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      this.selectionObj.nodes[nodeId].unselect();
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      this.selectionObj.edges[edgeId].unselect();
                    }
                  }
                  this.selectionObj = { nodes: {}, edges: {} };
                }
                /**
                 * return the number of selected nodes
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getSelectedNodeCount",
                value: function _getSelectedNodeCount() {
                  var count = 0;
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
                /**
                 * return the selected node
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getSelectedNode",
                value: function _getSelectedNode() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      return this.selectionObj.nodes[nodeId];
                    }
                  }
                  return void 0;
                }
                /**
                 * return the selected edge
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getSelectedEdge",
                value: function _getSelectedEdge() {
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      return this.selectionObj.edges[edgeId];
                    }
                  }
                  return void 0;
                }
                /**
                 * return the number of selected edges
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getSelectedEdgeCount",
                value: function _getSelectedEdgeCount() {
                  var count = 0;
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
                /**
                 * return the number of selected objects.
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getSelectedObjectCount",
                value: function _getSelectedObjectCount() {
                  var count = 0;
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      count += 1;
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      count += 1;
                    }
                  }
                  return count;
                }
                /**
                 * Check if anything is selected
                 *
                 * @returns {boolean}
                 * @private
                 */
              }, {
                key: "_selectionIsEmpty",
                value: function _selectionIsEmpty() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      return false;
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      return false;
                    }
                  }
                  return true;
                }
                /**
                 * check if one of the selected nodes is a cluster.
                 *
                 * @returns {boolean}
                 * @private
                 */
              }, {
                key: "_clusterInSelection",
                value: function _clusterInSelection() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      if (this.selectionObj.nodes[nodeId].clusterSize > 1) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
                /**
                 * select the edges connected to the node that is being selected
                 *
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_selectConnectedEdges",
                value: function _selectConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.select();
                    this._addToSelection(edge);
                  }
                }
                /**
                 * select the edges connected to the node that is being selected
                 *
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_hoverConnectedEdges",
                value: function _hoverConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.hover = true;
                    this._addToHover(edge);
                  }
                }
                /**
                 * unselect the edges connected to the node that is being selected
                 *
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_unselectConnectedEdges",
                value: function _unselectConnectedEdges(node) {
                  for (var i = 0; i < node.edges.length; i++) {
                    var edge = node.edges[i];
                    edge.unselect();
                    this._removeFromSelection(edge);
                  }
                }
                /**
                 * Remove the highlight from a node or edge, in response to mouse movement
                 *
                 * @param {Event}  event
                 * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
                 * @param {Node|vis.Edge} object
                 * @private
                 */
              }, {
                key: "emitBlurEvent",
                value: function emitBlurEvent(event, pointer, object) {
                  var properties = this._initBaseEvent(event, pointer);
                  if (object.hover === true) {
                    object.hover = false;
                    if (object instanceof Node) {
                      properties.node = object.id;
                      this.body.emitter.emit("blurNode", properties);
                    } else {
                      properties.edge = object.id;
                      this.body.emitter.emit("blurEdge", properties);
                    }
                  }
                }
                /**
                 * Create the highlight for a node or edge, in response to mouse movement
                 *
                 * @param {Event}  event
                 * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
                 * @param {Node|vis.Edge} object
                 * @returns {boolean} hoverChanged
                 * @private
                 */
              }, {
                key: "emitHoverEvent",
                value: function emitHoverEvent(event, pointer, object) {
                  var properties = this._initBaseEvent(event, pointer);
                  var hoverChanged = false;
                  if (object.hover === false) {
                    object.hover = true;
                    this._addToHover(object);
                    hoverChanged = true;
                    if (object instanceof Node) {
                      properties.node = object.id;
                      this.body.emitter.emit("hoverNode", properties);
                    } else {
                      properties.edge = object.id;
                      this.body.emitter.emit("hoverEdge", properties);
                    }
                  }
                  return hoverChanged;
                }
                /**
                 * Perform actions in response to a mouse movement.
                 *
                 * @param {Event}  event
                 * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
                 */
              }, {
                key: "hoverObject",
                value: function hoverObject(event, pointer) {
                  var object = this.getNodeAt(pointer);
                  if (object === void 0) {
                    object = this.getEdgeAt(pointer);
                  }
                  var hoverChanged = false;
                  for (var nodeId in this.hoverObj.nodes) {
                    if (this.hoverObj.nodes.hasOwnProperty(nodeId)) {
                      if (object === void 0 || object instanceof Node && object.id != nodeId || object instanceof Edge) {
                        this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);
                        delete this.hoverObj.nodes[nodeId];
                        hoverChanged = true;
                      }
                    }
                  }
                  for (var edgeId in this.hoverObj.edges) {
                    if (this.hoverObj.edges.hasOwnProperty(edgeId)) {
                      if (hoverChanged === true) {
                        this.hoverObj.edges[edgeId].hover = false;
                        delete this.hoverObj.edges[edgeId];
                      } else if (object === void 0 || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {
                        this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);
                        delete this.hoverObj.edges[edgeId];
                        hoverChanged = true;
                      }
                    }
                  }
                  if (object !== void 0) {
                    hoverChanged = hoverChanged || this.emitHoverEvent(event, pointer, object);
                    if (object instanceof Node && this.options.hoverConnectedEdges === true) {
                      this._hoverConnectedEdges(object);
                    }
                  }
                  if (hoverChanged === true) {
                    this.body.emitter.emit("_requestRedraw");
                  }
                }
                /**
                 *
                 * retrieve the currently selected objects
                 * @return {{nodes: Array.<string>, edges: Array.<string>}} selection
                 */
              }, {
                key: "getSelection",
                value: function getSelection() {
                  var nodeIds = this.getSelectedNodes();
                  var edgeIds = this.getSelectedEdges();
                  return { nodes: nodeIds, edges: edgeIds };
                }
                /**
                 *
                 * retrieve the currently selected nodes
                 * @return {string[]} selection    An array with the ids of the
                 *                                            selected nodes.
                 */
              }, {
                key: "getSelectedNodes",
                value: function getSelectedNodes() {
                  var idArray = [];
                  if (this.options.selectable === true) {
                    for (var nodeId in this.selectionObj.nodes) {
                      if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                        idArray.push(this.selectionObj.nodes[nodeId].id);
                      }
                    }
                  }
                  return idArray;
                }
                /**
                 *
                 * retrieve the currently selected edges
                 * @return {Array} selection    An array with the ids of the
                 *                                            selected nodes.
                 */
              }, {
                key: "getSelectedEdges",
                value: function getSelectedEdges() {
                  var idArray = [];
                  if (this.options.selectable === true) {
                    for (var edgeId in this.selectionObj.edges) {
                      if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                        idArray.push(this.selectionObj.edges[edgeId].id);
                      }
                    }
                  }
                  return idArray;
                }
                /**
                 * Updates the current selection
                 * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
                 * @param {Object} options                                 Options
                 */
              }, {
                key: "setSelection",
                value: function setSelection(selection) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  var i = void 0, id = void 0;
                  if (!selection || !selection.nodes && !selection.edges) throw "Selection must be an object with nodes and/or edges properties";
                  if (options.unselectAll || options.unselectAll === void 0) {
                    this.unselectAll();
                  }
                  if (selection.nodes) {
                    for (i = 0; i < selection.nodes.length; i++) {
                      id = selection.nodes[i];
                      var node = this.body.nodes[id];
                      if (!node) {
                        throw new RangeError('Node with id "' + id + '" not found');
                      }
                      this.selectObject(node, options.highlightEdges);
                    }
                  }
                  if (selection.edges) {
                    for (i = 0; i < selection.edges.length; i++) {
                      id = selection.edges[i];
                      var edge = this.body.edges[id];
                      if (!edge) {
                        throw new RangeError('Edge with id "' + id + '" not found');
                      }
                      this.selectObject(edge);
                    }
                  }
                  this.body.emitter.emit("_requestRedraw");
                }
                /**
                 * select zero or more nodes with the option to highlight edges
                 * @param {number[] | string[]} selection     An array with the ids of the
                 *                                            selected nodes.
                 * @param {boolean} [highlightEdges]
                 */
              }, {
                key: "selectNodes",
                value: function selectNodes(selection) {
                  var highlightEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                  if (!selection || selection.length === void 0) throw "Selection must be an array with ids";
                  this.setSelection({ nodes: selection }, { highlightEdges });
                }
                /**
                 * select zero or more edges
                 * @param {number[] | string[]} selection     An array with the ids of the
                 *                                            selected nodes.
                 */
              }, {
                key: "selectEdges",
                value: function selectEdges(selection) {
                  if (!selection || selection.length === void 0) throw "Selection must be an array with ids";
                  this.setSelection({ edges: selection });
                }
                /**
                 * Validate the selection: remove ids of nodes which no longer exist
                 * @private
                 */
              }, {
                key: "updateSelection",
                value: function updateSelection() {
                  for (var nodeId in this.selectionObj.nodes) {
                    if (this.selectionObj.nodes.hasOwnProperty(nodeId)) {
                      if (!this.body.nodes.hasOwnProperty(nodeId)) {
                        delete this.selectionObj.nodes[nodeId];
                      }
                    }
                  }
                  for (var edgeId in this.selectionObj.edges) {
                    if (this.selectionObj.edges.hasOwnProperty(edgeId)) {
                      if (!this.body.edges.hasOwnProperty(edgeId)) {
                        delete this.selectionObj.edges[edgeId];
                      }
                    }
                  }
                }
                /**
                 * Determine all the visual elements clicked which are on the given point.
                 *
                 * All elements are returned; this includes nodes, edges and their labels.
                 * The order returned is from highest to lowest, i.e. element 0 of the return
                 * value is the topmost item clicked on.
                 *
                 * The return value consists of an array of the following possible elements:
                 *
                 * - `{nodeId:number}`             - node with given id clicked on
                 * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
                 * - `{edgeId:number}`             - edge with given id clicked on
                 * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
                 *
                 * ## NOTES
                 *
                 * - Currently, there is only one label associated with a node or an edge,
                 *   but this is expected to change somewhere in the future.
                 * - Since there is no z-indexing yet, it is not really possible to set the nodes and
                 *   edges in the correct order. For the time being, nodes come first.
                 *
                 * @param {point} pointer  mouse position in screen coordinates
                 * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
                 * @private
                 */
              }, {
                key: "getClickedItems",
                value: function getClickedItems(pointer) {
                  var point = this.canvas.DOMtoCanvas(pointer);
                  var items = [];
                  var nodeIndices = this.body.nodeIndices;
                  var nodes = this.body.nodes;
                  for (var i = nodeIndices.length - 1; i >= 0; i--) {
                    var node = nodes[nodeIndices[i]];
                    var ret = node.getItemsOnPoint(point);
                    items.push.apply(items, ret);
                  }
                  var edgeIndices = this.body.edgeIndices;
                  var edges = this.body.edges;
                  for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {
                    var edge = edges[edgeIndices[_i]];
                    var _ret = edge.getItemsOnPoint(point);
                    items.push.apply(items, _ret);
                  }
                  return items;
                }
              }]);
              return SelectionHandler2;
            }();
            exports2["default"] = SelectionHandler;
          },
          /* 235 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var NetworkUtil = __webpack_require__(76)["default"];
            var _require = __webpack_require__(236), HorizontalStrategy = _require.HorizontalStrategy, VerticalStrategy = _require.VerticalStrategy;
            var HierarchicalStatus = function() {
              function HierarchicalStatus2() {
                (0, _classCallCheck3["default"])(this, HierarchicalStatus2);
                this.childrenReference = {};
                this.parentReference = {};
                this.trees = {};
                this.distributionOrdering = {};
                this.levels = {};
                this.distributionIndex = {};
                this.isTree = false;
                this.treeIndex = -1;
              }
              (0, _createClass3["default"])(HierarchicalStatus2, [{
                key: "addRelation",
                value: function addRelation(parentNodeId, childNodeId) {
                  if (this.childrenReference[parentNodeId] === void 0) {
                    this.childrenReference[parentNodeId] = [];
                  }
                  this.childrenReference[parentNodeId].push(childNodeId);
                  if (this.parentReference[childNodeId] === void 0) {
                    this.parentReference[childNodeId] = [];
                  }
                  this.parentReference[childNodeId].push(parentNodeId);
                }
                /**
                 * Check if the current state is for a formal tree or formal forest.
                 *
                 * This is the case if every node has at most one parent.
                 *
                 * Pre: parentReference init'ed properly for current network
                 */
              }, {
                key: "checkIfTree",
                value: function checkIfTree() {
                  for (var i in this.parentReference) {
                    if (this.parentReference[i].length > 1) {
                      this.isTree = false;
                      return;
                    }
                  }
                  this.isTree = true;
                }
                /**
                 * Return the number of separate trees in the current network.
                 * @returns {number}
                 */
              }, {
                key: "numTrees",
                value: function numTrees() {
                  return this.treeIndex + 1;
                }
                /**
                 * Assign a tree id to a node
                 * @param {Node} node
                 * @param {string|number} treeId
                 */
              }, {
                key: "setTreeIndex",
                value: function setTreeIndex(node, treeId) {
                  if (treeId === void 0) return;
                  if (this.trees[node.id] === void 0) {
                    this.trees[node.id] = treeId;
                    this.treeIndex = Math.max(treeId, this.treeIndex);
                  }
                }
                /**
                 * Ensure level for given id is defined.
                 *
                 * Sets level to zero for given node id if not already present
                 *
                 * @param {Node.id} nodeId
                 */
              }, {
                key: "ensureLevel",
                value: function ensureLevel(nodeId) {
                  if (this.levels[nodeId] === void 0) {
                    this.levels[nodeId] = 0;
                  }
                }
                /**
                 * get the maximum level of a branch.
                 *
                 * TODO: Never entered; find a test case to test this!
                 * @param {Node.id} nodeId
                 * @returns {number}
                 */
              }, {
                key: "getMaxLevel",
                value: function getMaxLevel(nodeId) {
                  var _this = this;
                  var accumulator = {};
                  var _getMaxLevel = function _getMaxLevel2(nodeId2) {
                    if (accumulator[nodeId2] !== void 0) {
                      return accumulator[nodeId2];
                    }
                    var level = _this.levels[nodeId2];
                    if (_this.childrenReference[nodeId2]) {
                      var children = _this.childrenReference[nodeId2];
                      if (children.length > 0) {
                        for (var i = 0; i < children.length; i++) {
                          level = Math.max(level, _getMaxLevel2(children[i]));
                        }
                      }
                    }
                    accumulator[nodeId2] = level;
                    return level;
                  };
                  return _getMaxLevel(nodeId);
                }
                /**
                 *
                 * @param {Node} nodeA
                 * @param {Node} nodeB
                 */
              }, {
                key: "levelDownstream",
                value: function levelDownstream(nodeA, nodeB) {
                  if (this.levels[nodeB.id] === void 0) {
                    if (this.levels[nodeA.id] === void 0) {
                      this.levels[nodeA.id] = 0;
                    }
                    this.levels[nodeB.id] = this.levels[nodeA.id] + 1;
                  }
                }
                /**
                 * Small util method to set the minimum levels of the nodes to zero.
                 *
                 * @param {Array.<Node>} nodes
                 */
              }, {
                key: "setMinLevelToZero",
                value: function setMinLevelToZero(nodes) {
                  var minLevel = 1e9;
                  for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                      if (this.levels[nodeId] !== void 0) {
                        minLevel = Math.min(this.levels[nodeId], minLevel);
                      }
                    }
                  }
                  for (var _nodeId in nodes) {
                    if (nodes.hasOwnProperty(_nodeId)) {
                      if (this.levels[_nodeId] !== void 0) {
                        this.levels[_nodeId] -= minLevel;
                      }
                    }
                  }
                }
                /**
                 * Get the min and max xy-coordinates of a given tree
                 *
                 * @param {Array.<Node>} nodes
                 * @param {number} index
                 * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
                 */
              }, {
                key: "getTreeSize",
                value: function getTreeSize(nodes, index) {
                  var min_x = 1e9;
                  var max_x = -1e9;
                  var min_y = 1e9;
                  var max_y = -1e9;
                  for (var nodeId in this.trees) {
                    if (this.trees.hasOwnProperty(nodeId)) {
                      if (this.trees[nodeId] === index) {
                        var node = nodes[nodeId];
                        min_x = Math.min(node.x, min_x);
                        max_x = Math.max(node.x, max_x);
                        min_y = Math.min(node.y, min_y);
                        max_y = Math.max(node.y, max_y);
                      }
                    }
                  }
                  return {
                    min_x,
                    max_x,
                    min_y,
                    max_y
                  };
                }
                /**
                 * Check if two nodes have the same parent(s)
                 *
                 * @param {Node} node1
                 * @param {Node} node2
                 * @return {boolean} true if the two nodes have a same ancestor node, false otherwise
                 */
              }, {
                key: "hasSameParent",
                value: function hasSameParent(node1, node2) {
                  var parents1 = this.parentReference[node1.id];
                  var parents2 = this.parentReference[node2.id];
                  if (parents1 === void 0 || parents2 === void 0) {
                    return false;
                  }
                  for (var i = 0; i < parents1.length; i++) {
                    for (var j = 0; j < parents2.length; j++) {
                      if (parents1[i] == parents2[j]) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
                /**
                 * Check if two nodes are in the same tree.
                 *
                 * @param {Node} node1
                 * @param {Node} node2
                 * @return {Boolean} true if this is so, false otherwise
                 */
              }, {
                key: "inSameSubNetwork",
                value: function inSameSubNetwork(node1, node2) {
                  return this.trees[node1.id] === this.trees[node2.id];
                }
                /**
                 * Get a list of the distinct levels in the current network
                 *
                 * @returns {Array}
                 */
              }, {
                key: "getLevels",
                value: function getLevels() {
                  return (0, _keys2["default"])(this.distributionOrdering);
                }
                /**
                 * Add a node to the ordering per level
                 *
                 * @param {Node} node
                 * @param {number} level
                 */
              }, {
                key: "addToOrdering",
                value: function addToOrdering(node, level) {
                  if (this.distributionOrdering[level] === void 0) {
                    this.distributionOrdering[level] = [];
                  }
                  var isPresent = false;
                  var curLevel = this.distributionOrdering[level];
                  for (var n in curLevel) {
                    if (curLevel[n] === node) {
                      isPresent = true;
                      break;
                    }
                  }
                  if (!isPresent) {
                    this.distributionOrdering[level].push(node);
                    this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;
                  }
                }
              }]);
              return HierarchicalStatus2;
            }();
            var LayoutEngine = function() {
              function LayoutEngine2(body) {
                (0, _classCallCheck3["default"])(this, LayoutEngine2);
                this.body = body;
                this.initialRandomSeed = Math.round(Math.random() * 1e6);
                this.randomSeed = this.initialRandomSeed;
                this.setPhysics = false;
                this.options = {};
                this.optionsBackup = { physics: {} };
                this.defaultOptions = {
                  randomSeed: void 0,
                  improvedLayout: true,
                  hierarchical: {
                    enabled: false,
                    levelSeparation: 150,
                    nodeSpacing: 100,
                    treeSpacing: 200,
                    blockShifting: true,
                    edgeMinimization: true,
                    parentCentralization: true,
                    direction: "UD",
                    // UD, DU, LR, RL
                    sortMethod: "hubsize"
                    // hubsize, directed
                  }
                };
                util.extend(this.options, this.defaultOptions);
                this.bindEventListeners();
              }
              (0, _createClass3["default"])(LayoutEngine2, [{
                key: "bindEventListeners",
                value: function bindEventListeners() {
                  var _this2 = this;
                  this.body.emitter.on("_dataChanged", function() {
                    _this2.setupHierarchicalLayout();
                  });
                  this.body.emitter.on("_dataLoaded", function() {
                    _this2.layoutNetwork();
                  });
                  this.body.emitter.on("_resetHierarchicalLayout", function() {
                    _this2.setupHierarchicalLayout();
                  });
                  this.body.emitter.on("_adjustEdgesForHierarchicalLayout", function() {
                    if (_this2.options.hierarchical.enabled !== true) {
                      return;
                    }
                    var type = _this2.direction.curveType();
                    _this2.body.emitter.emit("_forceDisableDynamicCurves", type, false);
                  });
                }
                /**
                 *
                 * @param {Object} options
                 * @param {Object} allOptions
                 * @returns {Object}
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options, allOptions) {
                  if (options !== void 0) {
                    var hierarchical = this.options.hierarchical;
                    var prevHierarchicalState = hierarchical.enabled;
                    util.selectiveDeepExtend(["randomSeed", "improvedLayout"], this.options, options);
                    util.mergeOptions(this.options, options, "hierarchical");
                    if (options.randomSeed !== void 0) {
                      this.initialRandomSeed = options.randomSeed;
                    }
                    if (hierarchical.enabled === true) {
                      if (prevHierarchicalState === true) {
                        this.body.emitter.emit("refresh", true);
                      }
                      if (hierarchical.direction === "RL" || hierarchical.direction === "DU") {
                        if (hierarchical.levelSeparation > 0) {
                          hierarchical.levelSeparation *= -1;
                        }
                      } else {
                        if (hierarchical.levelSeparation < 0) {
                          hierarchical.levelSeparation *= -1;
                        }
                      }
                      this.setDirectionStrategy();
                      this.body.emitter.emit("_resetHierarchicalLayout");
                      return this.adaptAllOptionsForHierarchicalLayout(allOptions);
                    } else {
                      if (prevHierarchicalState === true) {
                        this.body.emitter.emit("refresh");
                        return util.deepExtend(allOptions, this.optionsBackup);
                      }
                    }
                  }
                  return allOptions;
                }
                /**
                 *
                 * @param {Object} allOptions
                 * @returns {Object}
                 */
              }, {
                key: "adaptAllOptionsForHierarchicalLayout",
                value: function adaptAllOptionsForHierarchicalLayout(allOptions) {
                  if (this.options.hierarchical.enabled === true) {
                    var backupPhysics = this.optionsBackup.physics;
                    if (allOptions.physics === void 0 || allOptions.physics === true) {
                      allOptions.physics = {
                        enabled: backupPhysics.enabled === void 0 ? true : backupPhysics.enabled,
                        solver: "hierarchicalRepulsion"
                      };
                      backupPhysics.enabled = backupPhysics.enabled === void 0 ? true : backupPhysics.enabled;
                      backupPhysics.solver = backupPhysics.solver || "barnesHut";
                    } else if ((0, _typeof3["default"])(allOptions.physics) === "object") {
                      backupPhysics.enabled = allOptions.physics.enabled === void 0 ? true : allOptions.physics.enabled;
                      backupPhysics.solver = allOptions.physics.solver || "barnesHut";
                      allOptions.physics.solver = "hierarchicalRepulsion";
                    } else if (allOptions.physics !== false) {
                      backupPhysics.solver = "barnesHut";
                      allOptions.physics = { solver: "hierarchicalRepulsion" };
                    }
                    var type = this.direction.curveType();
                    if (allOptions.edges === void 0) {
                      this.optionsBackup.edges = { smooth: { enabled: true, type: "dynamic" } };
                      allOptions.edges = { smooth: false };
                    } else if (allOptions.edges.smooth === void 0) {
                      this.optionsBackup.edges = { smooth: { enabled: true, type: "dynamic" } };
                      allOptions.edges.smooth = false;
                    } else {
                      if (typeof allOptions.edges.smooth === "boolean") {
                        this.optionsBackup.edges = { smooth: allOptions.edges.smooth };
                        allOptions.edges.smooth = { enabled: allOptions.edges.smooth, type };
                      } else {
                        var smooth = allOptions.edges.smooth;
                        if (smooth.type !== void 0 && smooth.type !== "dynamic") {
                          type = smooth.type;
                        }
                        this.optionsBackup.edges = {
                          smooth: smooth.enabled === void 0 ? true : smooth.enabled,
                          type: smooth.type === void 0 ? "dynamic" : smooth.type,
                          roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                          forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                        };
                        allOptions.edges.smooth = {
                          enabled: smooth.enabled === void 0 ? true : smooth.enabled,
                          type,
                          roundness: smooth.roundness === void 0 ? 0.5 : smooth.roundness,
                          forceDirection: smooth.forceDirection === void 0 ? false : smooth.forceDirection
                        };
                      }
                    }
                    this.body.emitter.emit("_forceDisableDynamicCurves", type);
                  }
                  return allOptions;
                }
                /**
                 *
                 * @returns {number}
                 */
              }, {
                key: "seededRandom",
                value: function seededRandom() {
                  var x = Math.sin(this.randomSeed++) * 1e4;
                  return x - Math.floor(x);
                }
                /**
                 *
                 * @param {Array.<Node>} nodesArray
                 */
              }, {
                key: "positionInitially",
                value: function positionInitially(nodesArray) {
                  if (this.options.hierarchical.enabled !== true) {
                    this.randomSeed = this.initialRandomSeed;
                    var radius = nodesArray.length + 50;
                    for (var i = 0; i < nodesArray.length; i++) {
                      var node = nodesArray[i];
                      var angle = 2 * Math.PI * this.seededRandom();
                      if (node.x === void 0) {
                        node.x = radius * Math.cos(angle);
                      }
                      if (node.y === void 0) {
                        node.y = radius * Math.sin(angle);
                      }
                    }
                  }
                }
                /**
                 * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
                 * cluster them first to reduce the amount.
                 */
              }, {
                key: "layoutNetwork",
                value: function layoutNetwork() {
                  if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {
                    var indices = this.body.nodeIndices;
                    var positionDefined = 0;
                    for (var i = 0; i < indices.length; i++) {
                      var node = this.body.nodes[indices[i]];
                      if (node.predefinedPosition === true) {
                        positionDefined += 1;
                      }
                    }
                    if (positionDefined < 0.5 * indices.length) {
                      var MAX_LEVELS = 10;
                      var level = 0;
                      var clusterThreshold = 150;
                      var clusterOptions = {
                        clusterNodeProperties: {
                          shape: "ellipse",
                          // Bugfix: avoid type 'image', no images supplied
                          label: "",
                          // avoid label handling
                          group: "",
                          // avoid group handling
                          font: { multi: false }
                          // avoid font propagation
                        },
                        clusterEdgeProperties: {
                          label: "",
                          // avoid label handling
                          font: { multi: false },
                          // avoid font propagation
                          smooth: {
                            enabled: false
                            // avoid drawing penalty for complex edges
                          }
                        }
                      };
                      if (indices.length > clusterThreshold) {
                        var startLength = indices.length;
                        while (indices.length > clusterThreshold && level <= MAX_LEVELS) {
                          level += 1;
                          var before = indices.length;
                          if (level % 3 === 0) {
                            this.body.modules.clustering.clusterBridges(clusterOptions);
                          } else {
                            this.body.modules.clustering.clusterOutliers(clusterOptions);
                          }
                          var after = indices.length;
                          if (before == after && level % 3 !== 0) {
                            this._declusterAll();
                            this.body.emitter.emit("_layoutFailed");
                            console.info("This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.");
                            return;
                          }
                        }
                        this.body.modules.kamadaKawai.setOptions({ springLength: Math.max(150, 2 * startLength) });
                      }
                      if (level > MAX_LEVELS) {
                        console.info("The clustering didn't succeed within the amount of interations allowed, progressing with partial result.");
                      }
                      this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);
                      this._shiftToCenter();
                      var offset = 70;
                      for (var _i = 0; _i < indices.length; _i++) {
                        var _node = this.body.nodes[indices[_i]];
                        if (_node.predefinedPosition === false) {
                          _node.x += (0.5 - this.seededRandom()) * offset;
                          _node.y += (0.5 - this.seededRandom()) * offset;
                        }
                      }
                      this._declusterAll();
                      this.body.emitter.emit("_repositionBezierNodes");
                    }
                  }
                }
                /**
                 * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
                 * @private
                 */
              }, {
                key: "_shiftToCenter",
                value: function _shiftToCenter() {
                  var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);
                  var center = NetworkUtil.findCenter(range);
                  for (var i = 0; i < this.body.nodeIndices.length; i++) {
                    var node = this.body.nodes[this.body.nodeIndices[i]];
                    node.x -= center.x;
                    node.y -= center.y;
                  }
                }
                /**
                 * Expands all clusters
                 * @private
                 */
              }, {
                key: "_declusterAll",
                value: function _declusterAll() {
                  var clustersPresent = true;
                  while (clustersPresent === true) {
                    clustersPresent = false;
                    for (var i = 0; i < this.body.nodeIndices.length; i++) {
                      if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {
                        clustersPresent = true;
                        this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);
                      }
                    }
                    if (clustersPresent === true) {
                      this.body.emitter.emit("_dataChanged");
                    }
                  }
                }
                /**
                 *
                 * @returns {number|*}
                 */
              }, {
                key: "getSeed",
                value: function getSeed() {
                  return this.initialRandomSeed;
                }
                /**
                 * This is the main function to layout the nodes in a hierarchical way.
                 * It checks if the node details are supplied correctly
                 *
                 * @private
                 */
              }, {
                key: "setupHierarchicalLayout",
                value: function setupHierarchicalLayout() {
                  if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {
                    var node = void 0, nodeId = void 0;
                    var definedLevel = false;
                    var undefinedLevel = false;
                    this.lastNodeOnLevel = {};
                    this.hierarchical = new HierarchicalStatus();
                    for (nodeId in this.body.nodes) {
                      if (this.body.nodes.hasOwnProperty(nodeId)) {
                        node = this.body.nodes[nodeId];
                        if (node.options.level !== void 0) {
                          definedLevel = true;
                          this.hierarchical.levels[nodeId] = node.options.level;
                        } else {
                          undefinedLevel = true;
                        }
                      }
                    }
                    if (undefinedLevel === true && definedLevel === true) {
                      throw new Error("To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.");
                    } else {
                      if (undefinedLevel === true) {
                        var sortMethod = this.options.hierarchical.sortMethod;
                        if (sortMethod === "hubsize") {
                          this._determineLevelsByHubsize();
                        } else if (sortMethod === "directed") {
                          this._determineLevelsDirected();
                        } else if (sortMethod === "custom") {
                          this._determineLevelsCustomCallback();
                        }
                      }
                      for (var _nodeId2 in this.body.nodes) {
                        if (this.body.nodes.hasOwnProperty(_nodeId2)) {
                          this.hierarchical.ensureLevel(_nodeId2);
                        }
                      }
                      var distribution = this._getDistribution();
                      this._generateMap();
                      this._placeNodesByHierarchy(distribution);
                      this._condenseHierarchy();
                      this._shiftToCenter();
                    }
                  }
                }
                /**
                 * @private
                 */
              }, {
                key: "_condenseHierarchy",
                value: function _condenseHierarchy() {
                  var _this3 = this;
                  var stillShifting = false;
                  var branches = {};
                  var shiftTrees = function shiftTrees2() {
                    var treeSizes = getTreeSizes();
                    var shiftBy = 0;
                    for (var i = 0; i < treeSizes.length - 1; i++) {
                      var diff = treeSizes[i].max - treeSizes[i + 1].min;
                      shiftBy += diff + _this3.options.hierarchical.treeSpacing;
                      shiftTree(i + 1, shiftBy);
                    }
                  };
                  var shiftTree = function shiftTree2(index, offset) {
                    var trees = _this3.hierarchical.trees;
                    for (var nodeId in trees) {
                      if (trees.hasOwnProperty(nodeId)) {
                        if (trees[nodeId] === index) {
                          _this3.direction.shift(nodeId, offset);
                        }
                      }
                    }
                  };
                  var getTreeSizes = function getTreeSizes2() {
                    var treeWidths = [];
                    for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {
                      treeWidths.push(_this3.direction.getTreeSize(i));
                    }
                    return treeWidths;
                  };
                  var getBranchNodes = function getBranchNodes2(source, map) {
                    if (map[source.id]) {
                      return;
                    }
                    map[source.id] = true;
                    if (_this3.hierarchical.childrenReference[source.id]) {
                      var children = _this3.hierarchical.childrenReference[source.id];
                      if (children.length > 0) {
                        for (var i = 0; i < children.length; i++) {
                          getBranchNodes2(_this3.body.nodes[children[i]], map);
                        }
                      }
                    }
                  };
                  var getBranchBoundary = function getBranchBoundary2(branchMap) {
                    var maxLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e9;
                    var minSpace = 1e9;
                    var maxSpace = 1e9;
                    var min = 1e9;
                    var max = -1e9;
                    for (var branchNode in branchMap) {
                      if (branchMap.hasOwnProperty(branchNode)) {
                        var node = _this3.body.nodes[branchNode];
                        var level = _this3.hierarchical.levels[node.id];
                        var position = _this3.direction.getPosition(node);
                        var _getSpaceAroundNode2 = _this3._getSpaceAroundNode(node, branchMap), _getSpaceAroundNode3 = (0, _slicedToArray3["default"])(_getSpaceAroundNode2, 2), minSpaceNode = _getSpaceAroundNode3[0], maxSpaceNode = _getSpaceAroundNode3[1];
                        minSpace = Math.min(minSpaceNode, minSpace);
                        maxSpace = Math.min(maxSpaceNode, maxSpace);
                        if (level <= maxLevel) {
                          min = Math.min(position, min);
                          max = Math.max(position, max);
                        }
                      }
                    }
                    return [min, max, minSpace, maxSpace];
                  };
                  var getCollisionLevel = function getCollisionLevel2(node1, node2) {
                    var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);
                    var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);
                    return Math.min(maxLevel1, maxLevel2);
                  };
                  var shiftElementsCloser = function shiftElementsCloser2(callback, levels, centerParents) {
                    var hier = _this3.hierarchical;
                    for (var i = 0; i < levels.length; i++) {
                      var level = levels[i];
                      var levelNodes = hier.distributionOrdering[level];
                      if (levelNodes.length > 1) {
                        for (var j = 0; j < levelNodes.length - 1; j++) {
                          var node1 = levelNodes[j];
                          var node2 = levelNodes[j + 1];
                          if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {
                            callback(node1, node2, centerParents);
                          }
                        }
                      }
                    }
                  };
                  var branchShiftCallback = function branchShiftCallback2(node1, node2) {
                    var centerParent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var pos1 = _this3.direction.getPosition(node1);
                    var pos2 = _this3.direction.getPosition(node2);
                    var diffAbs = Math.abs(pos2 - pos1);
                    var nodeSpacing = _this3.options.hierarchical.nodeSpacing;
                    if (diffAbs > nodeSpacing) {
                      var branchNodes1 = {};
                      var branchNodes2 = {};
                      getBranchNodes(node1, branchNodes1);
                      getBranchNodes(node2, branchNodes2);
                      var maxLevel = getCollisionLevel(node1, node2);
                      var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);
                      var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);
                      var max1 = branchNodeBoundary1[1];
                      var min2 = branchNodeBoundary2[0];
                      var minSpace2 = branchNodeBoundary2[2];
                      var diffBranch = Math.abs(max1 - min2);
                      if (diffBranch > nodeSpacing) {
                        var offset = max1 - min2 + nodeSpacing;
                        if (offset < -minSpace2 + nodeSpacing) {
                          offset = -minSpace2 + nodeSpacing;
                        }
                        if (offset < 0) {
                          _this3._shiftBlock(node2.id, offset);
                          stillShifting = true;
                          if (centerParent === true) _this3._centerParent(node2);
                        }
                      }
                    }
                  };
                  var minimizeEdgeLength = function minimizeEdgeLength2(iterations, node) {
                    var nodeId = node.id;
                    var allEdges = node.edges;
                    var nodeLevel = _this3.hierarchical.levels[node.id];
                    var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;
                    var referenceNodes = {};
                    var aboveEdges = [];
                    for (var i = 0; i < allEdges.length; i++) {
                      var edge = allEdges[i];
                      if (edge.toId != edge.fromId) {
                        var otherNode = edge.toId == nodeId ? edge.from : edge.to;
                        referenceNodes[allEdges[i].id] = otherNode;
                        if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {
                          aboveEdges.push(edge);
                        }
                      }
                    }
                    var getFx = function getFx2(point, edges) {
                      var sum = 0;
                      for (var _i2 = 0; _i2 < edges.length; _i2++) {
                        if (referenceNodes[edges[_i2].id] !== void 0) {
                          var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;
                          sum += a / Math.sqrt(a * a + C2);
                        }
                      }
                      return sum;
                    };
                    var getDFx = function getDFx2(point, edges) {
                      var sum = 0;
                      for (var _i3 = 0; _i3 < edges.length; _i3++) {
                        if (referenceNodes[edges[_i3].id] !== void 0) {
                          var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;
                          sum -= C2 * Math.pow(a * a + C2, -1.5);
                        }
                      }
                      return sum;
                    };
                    var getGuess = function getGuess2(iterations2, edges) {
                      var guess2 = _this3.direction.getPosition(node);
                      var guessMap = {};
                      for (var _i4 = 0; _i4 < iterations2; _i4++) {
                        var fx = getFx(guess2, edges);
                        var dfx = getDFx(guess2, edges);
                        var limit = 40;
                        var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));
                        guess2 = guess2 - ratio;
                        if (guessMap[guess2] !== void 0) {
                          break;
                        }
                        guessMap[guess2] = _i4;
                      }
                      return guess2;
                    };
                    var moveBranch = function moveBranch2(guess2) {
                      var nodePosition = _this3.direction.getPosition(node);
                      if (branches[node.id] === void 0) {
                        var branchNodes = {};
                        getBranchNodes(node, branchNodes);
                        branches[node.id] = branchNodes;
                      }
                      var branchBoundary = getBranchBoundary(branches[node.id]);
                      var minSpaceBranch = branchBoundary[2];
                      var maxSpaceBranch = branchBoundary[3];
                      var diff = guess2 - nodePosition;
                      var branchOffset = 0;
                      if (diff > 0) {
                        branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);
                      } else if (diff < 0) {
                        branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);
                      }
                      if (branchOffset != 0) {
                        _this3._shiftBlock(node.id, branchOffset);
                        stillShifting = true;
                      }
                    };
                    var moveNode = function moveNode2(guess2) {
                      var nodePosition = _this3.direction.getPosition(node);
                      var _getSpaceAroundNode4 = _this3._getSpaceAroundNode(node), _getSpaceAroundNode5 = (0, _slicedToArray3["default"])(_getSpaceAroundNode4, 2), minSpace = _getSpaceAroundNode5[0], maxSpace = _getSpaceAroundNode5[1];
                      var diff = guess2 - nodePosition;
                      var newPosition = nodePosition;
                      if (diff > 0) {
                        newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess2);
                      } else if (diff < 0) {
                        newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess2);
                      }
                      if (newPosition !== nodePosition) {
                        _this3.direction.setPosition(node, newPosition);
                        stillShifting = true;
                      }
                    };
                    var guess = getGuess(iterations, aboveEdges);
                    moveBranch(guess);
                    guess = getGuess(iterations, allEdges);
                    moveNode(guess);
                  };
                  var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp2(iterations) {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < iterations; i++) {
                      stillShifting = false;
                      for (var j = 0; j < levels.length; j++) {
                        var level = levels[j];
                        var levelNodes = _this3.hierarchical.distributionOrdering[level];
                        for (var k = 0; k < levelNodes.length; k++) {
                          minimizeEdgeLength(1e3, levelNodes[k]);
                        }
                      }
                      if (stillShifting !== true) {
                        break;
                      }
                    }
                  };
                  var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp2(iterations) {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < iterations; i++) {
                      stillShifting = false;
                      shiftElementsCloser(branchShiftCallback, levels, true);
                      if (stillShifting !== true) {
                        break;
                      }
                    }
                  };
                  var centerAllParents = function centerAllParents2() {
                    for (var nodeId in _this3.body.nodes) {
                      if (_this3.body.nodes.hasOwnProperty(nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);
                    }
                  };
                  var centerAllParentsBottomUp = function centerAllParentsBottomUp2() {
                    var levels = _this3.hierarchical.getLevels();
                    levels = levels.reverse();
                    for (var i = 0; i < levels.length; i++) {
                      var level = levels[i];
                      var levelNodes = _this3.hierarchical.distributionOrdering[level];
                      for (var j = 0; j < levelNodes.length; j++) {
                        _this3._centerParent(levelNodes[j]);
                      }
                    }
                  };
                  if (this.options.hierarchical.blockShifting === true) {
                    shiftBranchesCloserBottomUp(5);
                    centerAllParents();
                  }
                  if (this.options.hierarchical.edgeMinimization === true) {
                    minimizeEdgeLengthBottomUp(20);
                  }
                  if (this.options.hierarchical.parentCentralization === true) {
                    centerAllParentsBottomUp();
                  }
                  shiftTrees();
                }
                /**
                 * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
                 * This is used to only get the distances to nodes outside of a branch.
                 * @param {Node} node
                 * @param {{Node.id: vis.Node}} map
                 * @returns {number[]}
                 * @private
                 */
              }, {
                key: "_getSpaceAroundNode",
                value: function _getSpaceAroundNode(node, map) {
                  var useMap = true;
                  if (map === void 0) {
                    useMap = false;
                  }
                  var level = this.hierarchical.levels[node.id];
                  if (level !== void 0) {
                    var index = this.hierarchical.distributionIndex[node.id];
                    var position = this.direction.getPosition(node);
                    var ordering = this.hierarchical.distributionOrdering[level];
                    var minSpace = 1e9;
                    var maxSpace = 1e9;
                    if (index !== 0) {
                      var prevNode = ordering[index - 1];
                      if (useMap === true && map[prevNode.id] === void 0 || useMap === false) {
                        var prevPos = this.direction.getPosition(prevNode);
                        minSpace = position - prevPos;
                      }
                    }
                    if (index != ordering.length - 1) {
                      var nextNode = ordering[index + 1];
                      if (useMap === true && map[nextNode.id] === void 0 || useMap === false) {
                        var nextPos = this.direction.getPosition(nextNode);
                        maxSpace = Math.min(maxSpace, nextPos - position);
                      }
                    }
                    return [minSpace, maxSpace];
                  } else {
                    return [0, 0];
                  }
                }
                /**
                 * We use this method to center a parent node and check if it does not cross other nodes when it does.
                 * @param {Node} node
                 * @private
                 */
              }, {
                key: "_centerParent",
                value: function _centerParent(node) {
                  if (this.hierarchical.parentReference[node.id]) {
                    var parents = this.hierarchical.parentReference[node.id];
                    for (var i = 0; i < parents.length; i++) {
                      var parentId = parents[i];
                      var parentNode = this.body.nodes[parentId];
                      var children = this.hierarchical.childrenReference[parentId];
                      if (children !== void 0) {
                        var newPosition = this._getCenterPosition(children);
                        var position = this.direction.getPosition(parentNode);
                        var _getSpaceAroundNode6 = this._getSpaceAroundNode(parentNode), _getSpaceAroundNode7 = (0, _slicedToArray3["default"])(_getSpaceAroundNode6, 2), minSpace = _getSpaceAroundNode7[0], maxSpace = _getSpaceAroundNode7[1];
                        var diff = position - newPosition;
                        if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {
                          this.direction.setPosition(parentNode, newPosition);
                        }
                      }
                    }
                  }
                }
                /**
                 * This function places the nodes on the canvas based on the hierarchial distribution.
                 *
                 * @param {Object} distribution | obtained by the function this._getDistribution()
                 * @private
                 */
              }, {
                key: "_placeNodesByHierarchy",
                value: function _placeNodesByHierarchy(distribution) {
                  this.positionedNodes = {};
                  for (var level in distribution) {
                    if (distribution.hasOwnProperty(level)) {
                      var nodeArray = (0, _keys2["default"])(distribution[level]);
                      nodeArray = this._indexArrayToNodes(nodeArray);
                      this.direction.sort(nodeArray);
                      var handledNodeCount = 0;
                      for (var i = 0; i < nodeArray.length; i++) {
                        var node = nodeArray[i];
                        if (this.positionedNodes[node.id] === void 0) {
                          var spacing = this.options.hierarchical.nodeSpacing;
                          var pos = spacing * handledNodeCount;
                          if (handledNodeCount > 0) {
                            pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;
                          }
                          this.direction.setPosition(node, pos, level);
                          this._validatePositionAndContinue(node, level, pos);
                          handledNodeCount++;
                        }
                      }
                    }
                  }
                }
                /**
                 * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
                 * on a X position that ensures there will be no overlap.
                 *
                 * @param {Node.id} parentId
                 * @param {number} parentLevel
                 * @private
                 */
              }, {
                key: "_placeBranchNodes",
                value: function _placeBranchNodes(parentId, parentLevel) {
                  var childRef = this.hierarchical.childrenReference[parentId];
                  if (childRef === void 0) {
                    return;
                  }
                  var childNodes = [];
                  for (var i = 0; i < childRef.length; i++) {
                    childNodes.push(this.body.nodes[childRef[i]]);
                  }
                  this.direction.sort(childNodes);
                  for (var _i5 = 0; _i5 < childNodes.length; _i5++) {
                    var childNode = childNodes[_i5];
                    var childNodeLevel = this.hierarchical.levels[childNode.id];
                    if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === void 0) {
                      var spacing = this.options.hierarchical.nodeSpacing;
                      var pos = void 0;
                      if (_i5 === 0) {
                        pos = this.direction.getPosition(this.body.nodes[parentId]);
                      } else {
                        pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;
                      }
                      this.direction.setPosition(childNode, pos, childNodeLevel);
                      this._validatePositionAndContinue(childNode, childNodeLevel, pos);
                    } else {
                      return;
                    }
                  }
                  var center = this._getCenterPosition(childNodes);
                  this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);
                }
                /**
                 * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
                 * Finally it will call _placeBranchNodes to place the branch nodes.
                 * @param {Node} node
                 * @param {number} level
                 * @param {number} pos
                 * @private
                 */
              }, {
                key: "_validatePositionAndContinue",
                value: function _validatePositionAndContinue(node, level, pos) {
                  if (!this.hierarchical.isTree) return;
                  if (this.lastNodeOnLevel[level] !== void 0) {
                    var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);
                    if (pos - previousPos < this.options.hierarchical.nodeSpacing) {
                      var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;
                      var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);
                      this._shiftBlock(sharedParent.withChild, diff);
                    }
                  }
                  this.lastNodeOnLevel[level] = node.id;
                  this.positionedNodes[node.id] = true;
                  this._placeBranchNodes(node.id, level);
                }
                /**
                 * Receives an array with node indices and returns an array with the actual node references.
                 * Used for sorting based on node properties.
                 * @param {Array.<Node.id>} idArray
                 * @returns {Array.<Node>}
                 */
              }, {
                key: "_indexArrayToNodes",
                value: function _indexArrayToNodes(idArray) {
                  var array = [];
                  for (var i = 0; i < idArray.length; i++) {
                    array.push(this.body.nodes[idArray[i]]);
                  }
                  return array;
                }
                /**
                 * This function get the distribution of levels based on hubsize
                 *
                 * @returns {Object}
                 * @private
                 */
              }, {
                key: "_getDistribution",
                value: function _getDistribution() {
                  var distribution = {};
                  var nodeId = void 0, node = void 0;
                  for (nodeId in this.body.nodes) {
                    if (this.body.nodes.hasOwnProperty(nodeId)) {
                      node = this.body.nodes[nodeId];
                      var level = this.hierarchical.levels[nodeId] === void 0 ? 0 : this.hierarchical.levels[nodeId];
                      this.direction.fix(node, level);
                      if (distribution[level] === void 0) {
                        distribution[level] = {};
                      }
                      distribution[level][nodeId] = node;
                    }
                  }
                  return distribution;
                }
                /**
                 * Return the active (i.e. visible) edges for this node
                 *
                 * @param {Node} node
                 * @returns {Array.<vis.Edge>} Array of edge instances
                 * @private
                 */
              }, {
                key: "_getActiveEdges",
                value: function _getActiveEdges(node) {
                  var _this4 = this;
                  var result = [];
                  util.forEach(node.edges, function(edge) {
                    if (_this4.body.edgeIndices.indexOf(edge.id) !== -1) {
                      result.push(edge);
                    }
                  });
                  return result;
                }
                /**
                 * Get the hubsizes for all active nodes.
                 *
                 * @returns {number}
                 * @private
                 */
              }, {
                key: "_getHubSizes",
                value: function _getHubSizes() {
                  var _this5 = this;
                  var hubSizes = {};
                  var nodeIds = this.body.nodeIndices;
                  util.forEach(nodeIds, function(nodeId) {
                    var node = _this5.body.nodes[nodeId];
                    var hubSize = _this5._getActiveEdges(node).length;
                    hubSizes[hubSize] = true;
                  });
                  var result = [];
                  util.forEach(hubSizes, function(size) {
                    result.push(Number(size));
                  });
                  result.sort(function(a, b) {
                    return b - a;
                  });
                  return result;
                }
                /**
                 * this function allocates nodes in levels based on the recursive branching from the largest hubs.
                 *
                 * @private
                 */
              }, {
                key: "_determineLevelsByHubsize",
                value: function _determineLevelsByHubsize() {
                  var _this6 = this;
                  var levelDownstream = function levelDownstream2(nodeA, nodeB) {
                    _this6.hierarchical.levelDownstream(nodeA, nodeB);
                  };
                  var hubSizes = this._getHubSizes();
                  var _loop = function _loop2(i2) {
                    var hubSize = hubSizes[i2];
                    if (hubSize === 0) return "break";
                    util.forEach(_this6.body.nodeIndices, function(nodeId) {
                      var node = _this6.body.nodes[nodeId];
                      if (hubSize === _this6._getActiveEdges(node).length) {
                        _this6._crawlNetwork(levelDownstream, nodeId);
                      }
                    });
                  };
                  for (var i = 0; i < hubSizes.length; ++i) {
                    var _ret = _loop(i);
                    if (_ret === "break") break;
                  }
                }
                /**
                 * TODO: release feature
                 * TODO: Determine if this feature is needed at all
                 *
                 * @private
                 */
              }, {
                key: "_determineLevelsCustomCallback",
                value: function _determineLevelsCustomCallback() {
                  var _this7 = this;
                  var minLevel = 1e5;
                  var customCallback = function customCallback2(nodeA, nodeB, edge) {
                  };
                  var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
                    var levelA = _this7.hierarchical.levels[nodeA.id];
                    if (levelA === void 0) {
                      levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;
                    }
                    var diff = customCallback(NetworkUtil.cloneOptions(nodeA, "node"), NetworkUtil.cloneOptions(nodeB, "node"), NetworkUtil.cloneOptions(edge, "edge"));
                    _this7.hierarchical.levels[nodeB.id] = levelA + diff;
                  };
                  this._crawlNetwork(levelByDirection);
                  this.hierarchical.setMinLevelToZero(this.body.nodes);
                }
                /**
                 * Allocate nodes in levels based on the direction of the edges.
                 *
                 * @private
                 */
              }, {
                key: "_determineLevelsDirected",
                value: function _determineLevelsDirected() {
                  var _this8 = this;
                  var minLevel = 1e4;
                  var isBidirectional = function isBidirectional2(edge) {
                    util.forEach(_this8.body.edges, function(otherEdge) {
                      if (otherEdge.toId === edge.fromId && otherEdge.fromId === edge.toId) {
                        return true;
                      }
                    });
                    return false;
                  };
                  var levelByDirection = function levelByDirection2(nodeA, nodeB, edge) {
                    var levelA = _this8.hierarchical.levels[nodeA.id];
                    var levelB = _this8.hierarchical.levels[nodeB.id];
                    if (isBidirectional(edge) && levelA !== void 0 && levelB !== void 0) {
                      return;
                    }
                    if (levelA === void 0) {
                      levelA = _this8.hierarchical.levels[nodeA.id] = minLevel;
                    }
                    if (edge.toId == nodeB.id) {
                      _this8.hierarchical.levels[nodeB.id] = levelA + 1;
                    } else {
                      _this8.hierarchical.levels[nodeB.id] = levelA - 1;
                    }
                  };
                  this._crawlNetwork(levelByDirection);
                  this.hierarchical.setMinLevelToZero(this.body.nodes);
                }
                /**
                 * Update the bookkeeping of parent and child.
                 * @private
                 */
              }, {
                key: "_generateMap",
                value: function _generateMap() {
                  var _this9 = this;
                  var fillInRelations = function fillInRelations2(parentNode, childNode) {
                    if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {
                      _this9.hierarchical.addRelation(parentNode.id, childNode.id);
                    }
                  };
                  this._crawlNetwork(fillInRelations);
                  this.hierarchical.checkIfTree();
                }
                /**
                 * Crawl over the entire network and use a callback on each node couple that is connected to each other.
                 * @param {function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
                 * @param {Node.id} startingNodeId
                 * @private
                 */
              }, {
                key: "_crawlNetwork",
                value: function _crawlNetwork() {
                  var _this10 = this;
                  var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
                  };
                  var startingNodeId = arguments[1];
                  var progress = {};
                  var crawler = function crawler2(node2, tree) {
                    if (progress[node2.id] === void 0) {
                      _this10.hierarchical.setTreeIndex(node2, tree);
                      progress[node2.id] = true;
                      var childNode = void 0;
                      var edges = _this10._getActiveEdges(node2);
                      for (var i2 = 0; i2 < edges.length; i2++) {
                        var edge = edges[i2];
                        if (edge.connected === true) {
                          if (edge.toId == node2.id) {
                            childNode = edge.from;
                          } else {
                            childNode = edge.to;
                          }
                          if (node2.id != childNode.id) {
                            callback(node2, childNode, edge);
                            crawler2(childNode, tree);
                          }
                        }
                      }
                    }
                  };
                  if (startingNodeId === void 0) {
                    var treeIndex = 0;
                    for (var i = 0; i < this.body.nodeIndices.length; i++) {
                      var nodeId = this.body.nodeIndices[i];
                      if (progress[nodeId] === void 0) {
                        var node = this.body.nodes[nodeId];
                        crawler(node, treeIndex);
                        treeIndex += 1;
                      }
                    }
                  } else {
                    var _node2 = this.body.nodes[startingNodeId];
                    if (_node2 === void 0) {
                      console.error("Node not found:", startingNodeId);
                      return;
                    }
                    crawler(_node2);
                  }
                }
                /**
                 * Shift a branch a certain distance
                 * @param {Node.id} parentId
                 * @param {number} diff
                 * @private
                 */
              }, {
                key: "_shiftBlock",
                value: function _shiftBlock(parentId, diff) {
                  var _this11 = this;
                  var progress = {};
                  var shifter = function shifter2(parentId2) {
                    if (progress[parentId2]) {
                      return;
                    }
                    progress[parentId2] = true;
                    _this11.direction.shift(parentId2, diff);
                    var childRef = _this11.hierarchical.childrenReference[parentId2];
                    if (childRef !== void 0) {
                      for (var i = 0; i < childRef.length; i++) {
                        shifter2(childRef[i]);
                      }
                    }
                  };
                  shifter(parentId);
                }
                /**
                 * Find a common parent between branches.
                 * @param {Node.id} childA
                 * @param {Node.id} childB
                 * @returns {{foundParent, withChild}}
                 * @private
                 */
              }, {
                key: "_findCommonParent",
                value: function _findCommonParent(childA, childB) {
                  var _this12 = this;
                  var parents = {};
                  var iterateParents = function iterateParents2(parents2, child) {
                    var parentRef = _this12.hierarchical.parentReference[child];
                    if (parentRef !== void 0) {
                      for (var i = 0; i < parentRef.length; i++) {
                        var parent = parentRef[i];
                        parents2[parent] = true;
                        iterateParents2(parents2, parent);
                      }
                    }
                  };
                  var findParent = function findParent2(parents2, child) {
                    var parentRef = _this12.hierarchical.parentReference[child];
                    if (parentRef !== void 0) {
                      for (var i = 0; i < parentRef.length; i++) {
                        var parent = parentRef[i];
                        if (parents2[parent] !== void 0) {
                          return { foundParent: parent, withChild: child };
                        }
                        var branch = findParent2(parents2, parent);
                        if (branch.foundParent !== null) {
                          return branch;
                        }
                      }
                    }
                    return { foundParent: null, withChild: child };
                  };
                  iterateParents(parents, childA);
                  return findParent(parents, childB);
                }
                /**
                 * Set the strategy pattern for handling the coordinates given the current direction.
                 *
                 * The individual instances contain all the operations and data specific to a layout direction.
                 *
                 * @param {Node} node
                 * @param {{x: number, y: number}} position
                 * @param {number} level
                 * @param {boolean} [doNotUpdate=false]
                 * @private
                 */
              }, {
                key: "setDirectionStrategy",
                value: function setDirectionStrategy() {
                  var isVertical = this.options.hierarchical.direction === "UD" || this.options.hierarchical.direction === "DU";
                  if (isVertical) {
                    this.direction = new VerticalStrategy(this);
                  } else {
                    this.direction = new HorizontalStrategy(this);
                  }
                }
                /**
                 * Determine the center position of a branch from the passed list of child nodes
                 *
                 * This takes into account the positions of all the child nodes.
                 * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
                 * @return {number}
                 * @private
                 */
              }, {
                key: "_getCenterPosition",
                value: function _getCenterPosition(childNodes) {
                  var minPos = 1e9;
                  var maxPos = -1e9;
                  for (var i = 0; i < childNodes.length; i++) {
                    var childNode = void 0;
                    if (childNodes[i].id !== void 0) {
                      childNode = childNodes[i];
                    } else {
                      var childNodeId = childNodes[i];
                      childNode = this.body.nodes[childNodeId];
                    }
                    var position = this.direction.getPosition(childNode);
                    minPos = Math.min(minPos, position);
                    maxPos = Math.max(maxPos, position);
                  }
                  return 0.5 * (minPos + maxPos);
                }
              }]);
              return LayoutEngine2;
            }();
            exports2["default"] = LayoutEngine;
          },
          /* 236 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.VerticalStrategy = exports2.HorizontalStrategy = void 0;
            var _getPrototypeOf = __webpack_require__(3);
            var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
            var _possibleConstructorReturn2 = __webpack_require__(4);
            var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
            var _inherits2 = __webpack_require__(5);
            var _inherits3 = _interopRequireDefault(_inherits2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var DirectionInterface = function() {
              function DirectionInterface2() {
                (0, _classCallCheck3["default"])(this, DirectionInterface2);
              }
              (0, _createClass3["default"])(DirectionInterface2, [{
                key: "abstract",
                /** @ignore **/
                value: function abstract() {
                  throw new Error("Can't instantiate abstract class!");
                }
                /**
                 * This is a dummy call which is used to suppress the jsdoc errors of type:
                 *
                 *   "'param' is assigned a value but never used"
                 *
                 * @ignore
                 **/
              }, {
                key: "fake_use",
                value: function fake_use() {
                }
                // Do nothing special
                /**
                 * Type to use to translate dynamic curves to, in the case of hierarchical layout.
                 * Dynamic curves do not work for these.
                 *
                 * The value should be perpendicular to the actual direction of the layout.
                 *
                 * @return {string} Direction, either 'vertical' or 'horizontal'
                 */
              }, {
                key: "curveType",
                value: function curveType() {
                  return this.abstract();
                }
                /**
                 * Return the value of the coordinate that is not fixed for this direction.
                 *
                 * @param {Node} node The node to read
                 * @return {number} Value of the unfixed coordinate
                 */
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  this.fake_use(node);
                  return this.abstract();
                }
                /**
                 * Set the value of the coordinate that is not fixed for this direction.
                 *
                 * @param {Node} node The node to adjust
                 * @param {number} position
                 * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
                 */
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  this.fake_use(node, position, level);
                  this.abstract();
                }
                /**
                 * Get the width of a tree.
                 *
                 * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
                 * only among themselves. In essence, it is a sub-network.
                 *
                 * @param {number} index The index number of a tree
                 * @return {number} the width of a tree in the view coordinates
                 */
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  this.fake_use(index);
                  return this.abstract();
                }
                /**
                 * Sort array of nodes on the unfixed coordinates.
                 *
                 * @param {Array.<Node>} nodeArray array of nodes to sort
                 */
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  this.fake_use(nodeArray);
                  this.abstract();
                }
                /**
                 * Assign the fixed coordinate of the node to the given level
                 *
                 * @param {Node} node The node to adjust
                 * @param {number} level The level to fix to
                 */
              }, {
                key: "fix",
                value: function fix(node, level) {
                  this.fake_use(node, level);
                  this.abstract();
                }
                /**
                 * Add an offset to the unfixed coordinate of the given node. 
                 *
                 * @param {NodeId} nodeId Id of the node to adjust
                 * @param {number} diff Offset to add to the unfixed coordinate
                 */
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.fake_use(nodeId, diff);
                  this.abstract();
                }
              }]);
              return DirectionInterface2;
            }();
            var VerticalStrategy = function(_DirectionInterface) {
              (0, _inherits3["default"])(VerticalStrategy2, _DirectionInterface);
              function VerticalStrategy2(layout) {
                (0, _classCallCheck3["default"])(this, VerticalStrategy2);
                var _this = (0, _possibleConstructorReturn3["default"])(this, (VerticalStrategy2.__proto__ || (0, _getPrototypeOf2["default"])(VerticalStrategy2)).call(this));
                _this.layout = layout;
                return _this;
              }
              (0, _createClass3["default"])(VerticalStrategy2, [{
                key: "curveType",
                value: function curveType() {
                  return "horizontal";
                }
                /** @inheritdoc */
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  return node.x;
                }
                /** @inheritdoc */
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  if (level !== void 0) {
                    this.layout.hierarchical.addToOrdering(node, level);
                  }
                  node.x = position;
                }
                /** @inheritdoc */
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
                  return { min: res.min_x, max: res.max_x };
                }
                /** @inheritdoc */
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  nodeArray.sort(function(a, b) {
                    if (a.x === void 0 || b.x === void 0) return 0;
                    return a.x - b.x;
                  });
                }
                /** @inheritdoc */
              }, {
                key: "fix",
                value: function fix(node, level) {
                  node.y = this.layout.options.hierarchical.levelSeparation * level;
                  node.options.fixed.y = true;
                }
                /** @inheritdoc */
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.layout.body.nodes[nodeId].x += diff;
                }
              }]);
              return VerticalStrategy2;
            }(DirectionInterface);
            var HorizontalStrategy = function(_DirectionInterface2) {
              (0, _inherits3["default"])(HorizontalStrategy2, _DirectionInterface2);
              function HorizontalStrategy2(layout) {
                (0, _classCallCheck3["default"])(this, HorizontalStrategy2);
                var _this2 = (0, _possibleConstructorReturn3["default"])(this, (HorizontalStrategy2.__proto__ || (0, _getPrototypeOf2["default"])(HorizontalStrategy2)).call(this));
                _this2.layout = layout;
                return _this2;
              }
              (0, _createClass3["default"])(HorizontalStrategy2, [{
                key: "curveType",
                value: function curveType() {
                  return "vertical";
                }
                /** @inheritdoc */
              }, {
                key: "getPosition",
                value: function getPosition(node) {
                  return node.y;
                }
                /** @inheritdoc */
              }, {
                key: "setPosition",
                value: function setPosition(node, position) {
                  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                  if (level !== void 0) {
                    this.layout.hierarchical.addToOrdering(node, level);
                  }
                  node.y = position;
                }
                /** @inheritdoc */
              }, {
                key: "getTreeSize",
                value: function getTreeSize(index) {
                  var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);
                  return { min: res.min_y, max: res.max_y };
                }
                /** @inheritdoc */
              }, {
                key: "sort",
                value: function sort(nodeArray) {
                  nodeArray.sort(function(a, b) {
                    if (a.y === void 0 || b.y === void 0) return 0;
                    return a.y - b.y;
                  });
                }
                /** @inheritdoc */
              }, {
                key: "fix",
                value: function fix(node, level) {
                  node.x = this.layout.options.hierarchical.levelSeparation * level;
                  node.options.fixed.x = true;
                }
                /** @inheritdoc */
              }, {
                key: "shift",
                value: function shift(nodeId, diff) {
                  this.layout.body.nodes[nodeId].y += diff;
                }
              }]);
              return HorizontalStrategy2;
            }(DirectionInterface);
            exports2.HorizontalStrategy = HorizontalStrategy;
            exports2.VerticalStrategy = VerticalStrategy;
          },
          /* 237 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _keys = __webpack_require__(8);
            var _keys2 = _interopRequireDefault(_keys);
            var _stringify = __webpack_require__(19);
            var _stringify2 = _interopRequireDefault(_stringify);
            var _typeof2 = __webpack_require__(6);
            var _typeof3 = _interopRequireDefault(_typeof2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var util = __webpack_require__(2);
            var Hammer = __webpack_require__(10);
            var hammerUtil = __webpack_require__(37);
            var ManipulationSystem = function() {
              function ManipulationSystem2(body, canvas, selectionHandler) {
                var _this = this;
                (0, _classCallCheck3["default"])(this, ManipulationSystem2);
                this.body = body;
                this.canvas = canvas;
                this.selectionHandler = selectionHandler;
                this.editMode = false;
                this.manipulationDiv = void 0;
                this.editModeDiv = void 0;
                this.closeDiv = void 0;
                this.manipulationHammers = [];
                this.temporaryUIFunctions = {};
                this.temporaryEventFunctions = [];
                this.touchTime = 0;
                this.temporaryIds = { nodes: [], edges: [] };
                this.guiEnabled = false;
                this.inMode = false;
                this.selectedControlNode = void 0;
                this.options = {};
                this.defaultOptions = {
                  enabled: false,
                  initiallyActive: false,
                  addNode: true,
                  addEdge: true,
                  editNode: void 0,
                  editEdge: true,
                  deleteNode: true,
                  deleteEdge: true,
                  controlNodeStyle: {
                    shape: "dot",
                    size: 6,
                    color: { background: "#ff0000", border: "#3c3c3c", highlight: { background: "#07f968", border: "#3c3c3c" } },
                    borderWidth: 2,
                    borderWidthSelected: 2
                  }
                };
                util.extend(this.options, this.defaultOptions);
                this.body.emitter.on("destroy", function() {
                  _this._clean();
                });
                this.body.emitter.on("_dataChanged", this._restore.bind(this));
                this.body.emitter.on("_resetData", this._restore.bind(this));
              }
              (0, _createClass3["default"])(ManipulationSystem2, [{
                key: "_restore",
                value: function _restore() {
                  if (this.inMode !== false) {
                    if (this.options.initiallyActive === true) {
                      this.enableEditMode();
                    } else {
                      this.disableEditMode();
                    }
                  }
                }
                /**
                 * Set the Options
                 *
                 * @param {Object} options
                 * @param {Object} allOptions
                 * @param {Object} globalOptions
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options, allOptions, globalOptions) {
                  if (allOptions !== void 0) {
                    if (allOptions.locale !== void 0) {
                      this.options.locale = allOptions.locale;
                    } else {
                      this.options.locale = globalOptions.locale;
                    }
                    if (allOptions.locales !== void 0) {
                      this.options.locales = allOptions.locales;
                    } else {
                      this.options.locales = globalOptions.locales;
                    }
                  }
                  if (options !== void 0) {
                    if (typeof options === "boolean") {
                      this.options.enabled = options;
                    } else {
                      this.options.enabled = true;
                      util.deepExtend(this.options, options);
                    }
                    if (this.options.initiallyActive === true) {
                      this.editMode = true;
                    }
                    this._setup();
                  }
                }
                /**
                 * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
                 *
                 * @private
                 */
              }, {
                key: "toggleEditMode",
                value: function toggleEditMode() {
                  if (this.editMode === true) {
                    this.disableEditMode();
                  } else {
                    this.enableEditMode();
                  }
                }
                /**
                 * Enables Edit Mode
                 */
              }, {
                key: "enableEditMode",
                value: function enableEditMode() {
                  this.editMode = true;
                  this._clean();
                  if (this.guiEnabled === true) {
                    this.manipulationDiv.style.display = "block";
                    this.closeDiv.style.display = "block";
                    this.editModeDiv.style.display = "none";
                    this.showManipulatorToolbar();
                  }
                }
                /**
                 * Disables Edit Mode
                 */
              }, {
                key: "disableEditMode",
                value: function disableEditMode() {
                  this.editMode = false;
                  this._clean();
                  if (this.guiEnabled === true) {
                    this.manipulationDiv.style.display = "none";
                    this.closeDiv.style.display = "none";
                    this.editModeDiv.style.display = "block";
                    this._createEditButton();
                  }
                }
                /**
                 * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
                 *
                 * @private
                 */
              }, {
                key: "showManipulatorToolbar",
                value: function showManipulatorToolbar() {
                  this._clean();
                  this.manipulationDOM = {};
                  if (this.guiEnabled === true) {
                    this.editMode = true;
                    this.manipulationDiv.style.display = "block";
                    this.closeDiv.style.display = "block";
                    var selectedNodeCount = this.selectionHandler._getSelectedNodeCount();
                    var selectedEdgeCount = this.selectionHandler._getSelectedEdgeCount();
                    var selectedTotalCount = selectedNodeCount + selectedEdgeCount;
                    var locale = this.options.locales[this.options.locale];
                    var needSeperator = false;
                    if (this.options.addNode !== false) {
                      this._createAddNodeButton(locale);
                      needSeperator = true;
                    }
                    if (this.options.addEdge !== false) {
                      if (needSeperator === true) {
                        this._createSeperator(1);
                      } else {
                        needSeperator = true;
                      }
                      this._createAddEdgeButton(locale);
                    }
                    if (selectedNodeCount === 1 && typeof this.options.editNode === "function") {
                      if (needSeperator === true) {
                        this._createSeperator(2);
                      } else {
                        needSeperator = true;
                      }
                      this._createEditNodeButton(locale);
                    } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {
                      if (needSeperator === true) {
                        this._createSeperator(3);
                      } else {
                        needSeperator = true;
                      }
                      this._createEditEdgeButton(locale);
                    }
                    if (selectedTotalCount !== 0) {
                      if (selectedNodeCount > 0 && this.options.deleteNode !== false) {
                        if (needSeperator === true) {
                          this._createSeperator(4);
                        }
                        this._createDeleteButton(locale);
                      } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {
                        if (needSeperator === true) {
                          this._createSeperator(4);
                        }
                        this._createDeleteButton(locale);
                      }
                    }
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                    this._temporaryBindEvent("select", this.showManipulatorToolbar.bind(this));
                  }
                  this.body.emitter.emit("_redraw");
                }
                /**
                 * Create the toolbar for adding Nodes
                 */
              }, {
                key: "addNodeMode",
                value: function addNodeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "addNode";
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["addDescription"] || this.options.locales["en"]["addDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this._temporaryBindEvent("click", this._performAddNode.bind(this));
                }
                /**
                 * call the bound function to handle the editing of the node. The node has to be selected.
                 */
              }, {
                key: "editNode",
                value: function editNode() {
                  var _this2 = this;
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  var node = this.selectionHandler._getSelectedNode();
                  if (node !== void 0) {
                    this.inMode = "editNode";
                    if (typeof this.options.editNode === "function") {
                      if (node.isCluster !== true) {
                        var data = util.deepExtend({}, node.options, false);
                        data.x = node.x;
                        data.y = node.y;
                        if (this.options.editNode.length === 2) {
                          this.options.editNode(data, function(finalizedData) {
                            if (finalizedData !== null && finalizedData !== void 0 && _this2.inMode === "editNode") {
                              _this2.body.data.nodes.getDataSet().update(finalizedData);
                            }
                            _this2.showManipulatorToolbar();
                          });
                        } else {
                          throw new Error("The function for edit does not support two arguments (data, callback)");
                        }
                      } else {
                        alert(this.options.locales[this.options.locale]["editClusterError"] || this.options.locales["en"]["editClusterError"]);
                      }
                    } else {
                      throw new Error("No function has been configured to handle the editing of nodes.");
                    }
                  } else {
                    this.showManipulatorToolbar();
                  }
                }
                /**
                 * create the toolbar to connect nodes
                 */
              }, {
                key: "addEdgeMode",
                value: function addEdgeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "addEdge";
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["edgeDescription"] || this.options.locales["en"]["edgeDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this._temporaryBindUI("onTouch", this._handleConnect.bind(this));
                  this._temporaryBindUI("onDragEnd", this._finishConnect.bind(this));
                  this._temporaryBindUI("onDrag", this._dragControlNode.bind(this));
                  this._temporaryBindUI("onRelease", this._finishConnect.bind(this));
                  this._temporaryBindUI("onDragStart", this._dragStartEdge.bind(this));
                  this._temporaryBindUI("onHold", function() {
                  });
                }
                /**
                 * create the toolbar to edit edges
                 */
              }, {
                key: "editEdgeMode",
                value: function editEdgeMode() {
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "editEdge";
                  if ((0, _typeof3["default"])(this.options.editEdge) === "object" && typeof this.options.editEdge.editWithoutDrag === "function") {
                    this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
                    if (this.edgeBeingEditedId !== void 0) {
                      var edge = this.body.edges[this.edgeBeingEditedId];
                      this._performEditEdge(edge.from, edge.to);
                      return;
                    }
                  }
                  if (this.guiEnabled === true) {
                    var locale = this.options.locales[this.options.locale];
                    this.manipulationDOM = {};
                    this._createBackButton(locale);
                    this._createSeperator();
                    this._createDescription(locale["editEdgeDescription"] || this.options.locales["en"]["editEdgeDescription"]);
                    this._bindHammerToDiv(this.closeDiv, this.toggleEditMode.bind(this));
                  }
                  this.edgeBeingEditedId = this.selectionHandler.getSelectedEdges()[0];
                  if (this.edgeBeingEditedId !== void 0) {
                    var _edge = this.body.edges[this.edgeBeingEditedId];
                    var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);
                    var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);
                    this.temporaryIds.nodes.push(controlNodeFrom.id);
                    this.temporaryIds.nodes.push(controlNodeTo.id);
                    this.body.nodes[controlNodeFrom.id] = controlNodeFrom;
                    this.body.nodeIndices.push(controlNodeFrom.id);
                    this.body.nodes[controlNodeTo.id] = controlNodeTo;
                    this.body.nodeIndices.push(controlNodeTo.id);
                    this._temporaryBindUI("onTouch", this._controlNodeTouch.bind(this));
                    this._temporaryBindUI("onTap", function() {
                    });
                    this._temporaryBindUI("onHold", function() {
                    });
                    this._temporaryBindUI("onDragStart", this._controlNodeDragStart.bind(this));
                    this._temporaryBindUI("onDrag", this._controlNodeDrag.bind(this));
                    this._temporaryBindUI("onDragEnd", this._controlNodeDragEnd.bind(this));
                    this._temporaryBindUI("onMouseMove", function() {
                    });
                    this._temporaryBindEvent("beforeDrawing", function(ctx) {
                      var positions = _edge.edgeType.findBorderPositions(ctx);
                      if (controlNodeFrom.selected === false) {
                        controlNodeFrom.x = positions.from.x;
                        controlNodeFrom.y = positions.from.y;
                      }
                      if (controlNodeTo.selected === false) {
                        controlNodeTo.x = positions.to.x;
                        controlNodeTo.y = positions.to.y;
                      }
                    });
                    this.body.emitter.emit("_redraw");
                  } else {
                    this.showManipulatorToolbar();
                  }
                }
                /**
                 * delete everything in the selection
                 */
              }, {
                key: "deleteSelected",
                value: function deleteSelected() {
                  var _this3 = this;
                  if (this.editMode !== true) {
                    this.enableEditMode();
                  }
                  this._clean();
                  this.inMode = "delete";
                  var selectedNodes = this.selectionHandler.getSelectedNodes();
                  var selectedEdges = this.selectionHandler.getSelectedEdges();
                  var deleteFunction = void 0;
                  if (selectedNodes.length > 0) {
                    for (var i = 0; i < selectedNodes.length; i++) {
                      if (this.body.nodes[selectedNodes[i]].isCluster === true) {
                        alert(this.options.locales[this.options.locale]["deleteClusterError"] || this.options.locales["en"]["deleteClusterError"]);
                        return;
                      }
                    }
                    if (typeof this.options.deleteNode === "function") {
                      deleteFunction = this.options.deleteNode;
                    }
                  } else if (selectedEdges.length > 0) {
                    if (typeof this.options.deleteEdge === "function") {
                      deleteFunction = this.options.deleteEdge;
                    }
                  }
                  if (typeof deleteFunction === "function") {
                    var data = { nodes: selectedNodes, edges: selectedEdges };
                    if (deleteFunction.length === 2) {
                      deleteFunction(data, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this3.inMode === "delete") {
                          _this3.body.data.edges.getDataSet().remove(finalizedData.edges);
                          _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);
                          _this3.body.emitter.emit("startSimulation");
                          _this3.showManipulatorToolbar();
                        } else {
                          _this3.body.emitter.emit("startSimulation");
                          _this3.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for delete does not support two arguments (data, callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().remove(selectedEdges);
                    this.body.data.nodes.getDataSet().remove(selectedNodes);
                    this.body.emitter.emit("startSimulation");
                    this.showManipulatorToolbar();
                  }
                }
                //********************************************** PRIVATE ***************************************//
                /**
                 * draw or remove the DOM
                 * @private
                 */
              }, {
                key: "_setup",
                value: function _setup() {
                  if (this.options.enabled === true) {
                    this.guiEnabled = true;
                    this._createWrappers();
                    if (this.editMode === false) {
                      this._createEditButton();
                    } else {
                      this.showManipulatorToolbar();
                    }
                  } else {
                    this._removeManipulationDOM();
                    this.guiEnabled = false;
                  }
                }
                /**
                 * create the div overlays that contain the DOM
                 * @private
                 */
              }, {
                key: "_createWrappers",
                value: function _createWrappers() {
                  if (this.manipulationDiv === void 0) {
                    this.manipulationDiv = document.createElement("div");
                    this.manipulationDiv.className = "vis-manipulation";
                    if (this.editMode === true) {
                      this.manipulationDiv.style.display = "block";
                    } else {
                      this.manipulationDiv.style.display = "none";
                    }
                    this.canvas.frame.appendChild(this.manipulationDiv);
                  }
                  if (this.editModeDiv === void 0) {
                    this.editModeDiv = document.createElement("div");
                    this.editModeDiv.className = "vis-edit-mode";
                    if (this.editMode === true) {
                      this.editModeDiv.style.display = "none";
                    } else {
                      this.editModeDiv.style.display = "block";
                    }
                    this.canvas.frame.appendChild(this.editModeDiv);
                  }
                  if (this.closeDiv === void 0) {
                    this.closeDiv = document.createElement("div");
                    this.closeDiv.className = "vis-close";
                    this.closeDiv.style.display = this.manipulationDiv.style.display;
                    this.canvas.frame.appendChild(this.closeDiv);
                  }
                }
                /**
                 * generate a new target node. Used for creating new edges and editing edges
                 *
                 * @param {number} x
                 * @param {number} y
                 * @returns {Node}
                 * @private
                 */
              }, {
                key: "_getNewTargetNode",
                value: function _getNewTargetNode(x, y) {
                  var controlNodeStyle = util.deepExtend({}, this.options.controlNodeStyle);
                  controlNodeStyle.id = "targetNode" + util.randomUUID();
                  controlNodeStyle.hidden = false;
                  controlNodeStyle.physics = false;
                  controlNodeStyle.x = x;
                  controlNodeStyle.y = y;
                  var node = this.body.functions.createNode(controlNodeStyle);
                  node.shape.boundingBox = { left: x, right: x, top: y, bottom: y };
                  return node;
                }
                /**
                 * Create the edit button
                 */
              }, {
                key: "_createEditButton",
                value: function _createEditButton() {
                  this._clean();
                  this.manipulationDOM = {};
                  util.recursiveDOMDelete(this.editModeDiv);
                  var locale = this.options.locales[this.options.locale];
                  var button = this._createButton("editMode", "vis-button vis-edit vis-edit-mode", locale["edit"] || this.options.locales["en"]["edit"]);
                  this.editModeDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.toggleEditMode.bind(this));
                }
                /**
                 * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
                 * @private
                 */
              }, {
                key: "_clean",
                value: function _clean() {
                  this.inMode = false;
                  if (this.guiEnabled === true) {
                    util.recursiveDOMDelete(this.editModeDiv);
                    util.recursiveDOMDelete(this.manipulationDiv);
                    this._cleanManipulatorHammers();
                  }
                  this._cleanupTemporaryNodesAndEdges();
                  this._unbindTemporaryUIs();
                  this._unbindTemporaryEvents();
                  this.body.emitter.emit("restorePhysics");
                }
                /**
                 * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
                 * @private
                 */
              }, {
                key: "_cleanManipulatorHammers",
                value: function _cleanManipulatorHammers() {
                  if (this.manipulationHammers.length != 0) {
                    for (var i = 0; i < this.manipulationHammers.length; i++) {
                      this.manipulationHammers[i].destroy();
                    }
                    this.manipulationHammers = [];
                  }
                }
                /**
                 * Remove all DOM elements created by this module.
                 * @private
                 */
              }, {
                key: "_removeManipulationDOM",
                value: function _removeManipulationDOM() {
                  this._clean();
                  util.recursiveDOMDelete(this.manipulationDiv);
                  util.recursiveDOMDelete(this.editModeDiv);
                  util.recursiveDOMDelete(this.closeDiv);
                  if (this.manipulationDiv) {
                    this.canvas.frame.removeChild(this.manipulationDiv);
                  }
                  if (this.editModeDiv) {
                    this.canvas.frame.removeChild(this.editModeDiv);
                  }
                  if (this.closeDiv) {
                    this.canvas.frame.removeChild(this.closeDiv);
                  }
                  this.manipulationDiv = void 0;
                  this.editModeDiv = void 0;
                  this.closeDiv = void 0;
                }
                /**
                 * create a seperator line. the index is to differentiate in the manipulation dom
                 * @param {number} [index=1]
                 * @private
                 */
              }, {
                key: "_createSeperator",
                value: function _createSeperator() {
                  var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                  this.manipulationDOM["seperatorLineDiv" + index] = document.createElement("div");
                  this.manipulationDOM["seperatorLineDiv" + index].className = "vis-separator-line";
                  this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv" + index]);
                }
                // ----------------------    DOM functions for buttons    --------------------------//
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createAddNodeButton",
                value: function _createAddNodeButton(locale) {
                  var button = this._createButton("addNode", "vis-button vis-add", locale["addNode"] || this.options.locales["en"]["addNode"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.addNodeMode.bind(this));
                }
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createAddEdgeButton",
                value: function _createAddEdgeButton(locale) {
                  var button = this._createButton("addEdge", "vis-button vis-connect", locale["addEdge"] || this.options.locales["en"]["addEdge"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.addEdgeMode.bind(this));
                }
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createEditNodeButton",
                value: function _createEditNodeButton(locale) {
                  var button = this._createButton("editNode", "vis-button vis-edit", locale["editNode"] || this.options.locales["en"]["editNode"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.editNode.bind(this));
                }
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createEditEdgeButton",
                value: function _createEditEdgeButton(locale) {
                  var button = this._createButton("editEdge", "vis-button vis-edit", locale["editEdge"] || this.options.locales["en"]["editEdge"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.editEdgeMode.bind(this));
                }
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createDeleteButton",
                value: function _createDeleteButton(locale) {
                  var deleteBtnClass;
                  if (this.options.rtl) {
                    deleteBtnClass = "vis-button vis-delete-rtl";
                  } else {
                    deleteBtnClass = "vis-button vis-delete";
                  }
                  var button = this._createButton("delete", deleteBtnClass, locale["del"] || this.options.locales["en"]["del"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.deleteSelected.bind(this));
                }
                /**
                 *
                 * @param {Locale} locale
                 * @private
                 */
              }, {
                key: "_createBackButton",
                value: function _createBackButton(locale) {
                  var button = this._createButton("back", "vis-button vis-back", locale["back"] || this.options.locales["en"]["back"]);
                  this.manipulationDiv.appendChild(button);
                  this._bindHammerToDiv(button, this.showManipulatorToolbar.bind(this));
                }
                /**
                 *
                 * @param {number|string} id
                 * @param {string} className
                 * @param {label} label
                 * @param {string} labelClassName
                 * @returns {HTMLElement}
                 * @private
                 */
              }, {
                key: "_createButton",
                value: function _createButton(id, className, label) {
                  var labelClassName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vis-label";
                  this.manipulationDOM[id + "Div"] = document.createElement("div");
                  this.manipulationDOM[id + "Div"].className = className;
                  this.manipulationDOM[id + "Label"] = document.createElement("div");
                  this.manipulationDOM[id + "Label"].className = labelClassName;
                  this.manipulationDOM[id + "Label"].innerHTML = label;
                  this.manipulationDOM[id + "Div"].appendChild(this.manipulationDOM[id + "Label"]);
                  return this.manipulationDOM[id + "Div"];
                }
                /**
                 *
                 * @param {Label} label
                 * @private
                 */
              }, {
                key: "_createDescription",
                value: function _createDescription(label) {
                  this.manipulationDiv.appendChild(this._createButton("description", "vis-button vis-none", label));
                }
                // -------------------------- End of DOM functions for buttons ------------------------------//
                /**
                 * this binds an event until cleanup by the clean functions.
                 * @param {Event}  event   The event
                 * @param {function} newFunction
                 * @private
                 */
              }, {
                key: "_temporaryBindEvent",
                value: function _temporaryBindEvent(event, newFunction) {
                  this.temporaryEventFunctions.push({ event, boundFunction: newFunction });
                  this.body.emitter.on(event, newFunction);
                }
                /**
                 * this overrides an UI function until cleanup by the clean function
                 * @param {string} UIfunctionName
                 * @param {function} newFunction
                 * @private
                 */
              }, {
                key: "_temporaryBindUI",
                value: function _temporaryBindUI(UIfunctionName, newFunction) {
                  if (this.body.eventListeners[UIfunctionName] !== void 0) {
                    this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];
                    this.body.eventListeners[UIfunctionName] = newFunction;
                  } else {
                    throw new Error("This UI function does not exist. Typo? You tried: " + UIfunctionName + " possible are: " + (0, _stringify2["default"])((0, _keys2["default"])(this.body.eventListeners)));
                  }
                }
                /**
                 * Restore the overridden UI functions to their original state.
                 *
                 * @private
                 */
              }, {
                key: "_unbindTemporaryUIs",
                value: function _unbindTemporaryUIs() {
                  for (var functionName in this.temporaryUIFunctions) {
                    if (this.temporaryUIFunctions.hasOwnProperty(functionName)) {
                      this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];
                      delete this.temporaryUIFunctions[functionName];
                    }
                  }
                  this.temporaryUIFunctions = {};
                }
                /**
                 * Unbind the events created by _temporaryBindEvent
                 * @private
                 */
              }, {
                key: "_unbindTemporaryEvents",
                value: function _unbindTemporaryEvents() {
                  for (var i = 0; i < this.temporaryEventFunctions.length; i++) {
                    var eventName = this.temporaryEventFunctions[i].event;
                    var boundFunction = this.temporaryEventFunctions[i].boundFunction;
                    this.body.emitter.off(eventName, boundFunction);
                  }
                  this.temporaryEventFunctions = [];
                }
                /**
                 * Bind an hammer instance to a DOM element.
                 *
                 * @param {Element} domElement
                 * @param {function} boundFunction
                 */
              }, {
                key: "_bindHammerToDiv",
                value: function _bindHammerToDiv(domElement, boundFunction) {
                  var hammer = new Hammer(domElement, {});
                  hammerUtil.onTouch(hammer, boundFunction);
                  this.manipulationHammers.push(hammer);
                }
                /**
                 * Neatly clean up temporary edges and nodes
                 * @private
                 */
              }, {
                key: "_cleanupTemporaryNodesAndEdges",
                value: function _cleanupTemporaryNodesAndEdges() {
                  for (var i = 0; i < this.temporaryIds.edges.length; i++) {
                    this.body.edges[this.temporaryIds.edges[i]].disconnect();
                    delete this.body.edges[this.temporaryIds.edges[i]];
                    var indexTempEdge = this.body.edgeIndices.indexOf(this.temporaryIds.edges[i]);
                    if (indexTempEdge !== -1) {
                      this.body.edgeIndices.splice(indexTempEdge, 1);
                    }
                  }
                  for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {
                    delete this.body.nodes[this.temporaryIds.nodes[_i]];
                    var indexTempNode = this.body.nodeIndices.indexOf(this.temporaryIds.nodes[_i]);
                    if (indexTempNode !== -1) {
                      this.body.nodeIndices.splice(indexTempNode, 1);
                    }
                  }
                  this.temporaryIds = { nodes: [], edges: [] };
                }
                // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//
                /**
                 * the touch is used to get the position of the initial click
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_controlNodeTouch",
                value: function _controlNodeTouch(event) {
                  this.selectionHandler.unselectAll();
                  this.lastTouch = this.body.functions.getPointer(event.center);
                  this.lastTouch.translation = util.extend({}, this.body.view.translation);
                }
                /**
                 * the drag start is used to mark one of the control nodes as selected.
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_controlNodeDragStart",
                value: function _controlNodeDragStart(event) {
                  var pointer = this.lastTouch;
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var from = this.body.nodes[this.temporaryIds.nodes[0]];
                  var to = this.body.nodes[this.temporaryIds.nodes[1]];
                  var edge = this.body.edges[this.edgeBeingEditedId];
                  this.selectedControlNode = void 0;
                  var fromSelect = from.isOverlappingWith(pointerObj);
                  var toSelect = to.isOverlappingWith(pointerObj);
                  if (fromSelect === true) {
                    this.selectedControlNode = from;
                    edge.edgeType.from = from;
                  } else if (toSelect === true) {
                    this.selectedControlNode = to;
                    edge.edgeType.to = to;
                  }
                  if (this.selectedControlNode !== void 0) {
                    this.selectionHandler.selectObject(this.selectedControlNode);
                  }
                  this.body.emitter.emit("_redraw");
                }
                /**
                 * dragging the control nodes or the canvas
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_controlNodeDrag",
                value: function _controlNodeDrag(event) {
                  this.body.emitter.emit("disablePhysics");
                  var pointer = this.body.functions.getPointer(event.center);
                  var pos = this.canvas.DOMtoCanvas(pointer);
                  if (this.selectedControlNode !== void 0) {
                    this.selectedControlNode.x = pos.x;
                    this.selectedControlNode.y = pos.y;
                  } else {
                    var diffX = pointer.x - this.lastTouch.x;
                    var diffY = pointer.y - this.lastTouch.y;
                    this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
                  }
                  this.body.emitter.emit("_redraw");
                }
                /**
                 * connecting or restoring the control nodes.
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_controlNodeDragEnd",
                value: function _controlNodeDragEnd(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var edge = this.body.edges[this.edgeBeingEditedId];
                  if (this.selectedControlNode === void 0) {
                    return;
                  }
                  this.selectionHandler.unselectAll();
                  var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
                  var node = void 0;
                  for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
                    if (overlappingNodeIds[i] !== this.selectedControlNode.id) {
                      node = this.body.nodes[overlappingNodeIds[i]];
                      break;
                    }
                  }
                  if (node !== void 0 && this.selectedControlNode !== void 0) {
                    if (node.isCluster === true) {
                      alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                    } else {
                      var from = this.body.nodes[this.temporaryIds.nodes[0]];
                      if (this.selectedControlNode.id === from.id) {
                        this._performEditEdge(node.id, edge.to.id);
                      } else {
                        this._performEditEdge(edge.from.id, node.id);
                      }
                    }
                  } else {
                    edge.updateEdgeType();
                    this.body.emitter.emit("restorePhysics");
                  }
                  this.body.emitter.emit("_redraw");
                }
                // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
                // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
                /**
                 * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
                 * to walk the user through the process.
                 *
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "_handleConnect",
                value: function _handleConnect(event) {
                  if ((/* @__PURE__ */ new Date()).valueOf() - this.touchTime > 100) {
                    this.lastTouch = this.body.functions.getPointer(event.center);
                    this.lastTouch.translation = util.extend({}, this.body.view.translation);
                    var pointer = this.lastTouch;
                    var node = this.selectionHandler.getNodeAt(pointer);
                    if (node !== void 0) {
                      if (node.isCluster === true) {
                        alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                      } else {
                        var targetNode = this._getNewTargetNode(node.x, node.y);
                        this.body.nodes[targetNode.id] = targetNode;
                        this.body.nodeIndices.push(targetNode.id);
                        var connectionEdge = this.body.functions.createEdge({
                          id: "connectionEdge" + util.randomUUID(),
                          from: node.id,
                          to: targetNode.id,
                          physics: false,
                          smooth: {
                            enabled: true,
                            type: "continuous",
                            roundness: 0.5
                          }
                        });
                        this.body.edges[connectionEdge.id] = connectionEdge;
                        this.body.edgeIndices.push(connectionEdge.id);
                        this.temporaryIds.nodes.push(targetNode.id);
                        this.temporaryIds.edges.push(connectionEdge.id);
                      }
                    }
                    this.touchTime = (/* @__PURE__ */ new Date()).valueOf();
                  }
                }
                /**
                 *
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "_dragControlNode",
                value: function _dragControlNode(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  if (this.temporaryIds.nodes[0] !== void 0) {
                    var targetNode = this.body.nodes[this.temporaryIds.nodes[0]];
                    targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);
                    targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);
                    this.body.emitter.emit("_redraw");
                  } else {
                    var diffX = pointer.x - this.lastTouch.x;
                    var diffY = pointer.y - this.lastTouch.y;
                    this.body.view.translation = { x: this.lastTouch.translation.x + diffX, y: this.lastTouch.translation.y + diffY };
                  }
                }
                /**
                 * Connect the new edge to the target if one exists, otherwise remove temp line
                 * @param {Event}  event   The event
                 * @private
                 */
              }, {
                key: "_finishConnect",
                value: function _finishConnect(event) {
                  var pointer = this.body.functions.getPointer(event.center);
                  var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);
                  var connectFromId = void 0;
                  if (this.temporaryIds.edges[0] !== void 0) {
                    connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;
                  }
                  var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);
                  var node = void 0;
                  for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {
                    if (this.temporaryIds.nodes.indexOf(overlappingNodeIds[i]) === -1) {
                      node = this.body.nodes[overlappingNodeIds[i]];
                      break;
                    }
                  }
                  this._cleanupTemporaryNodesAndEdges();
                  if (node !== void 0) {
                    if (node.isCluster === true) {
                      alert(this.options.locales[this.options.locale]["createEdgeError"] || this.options.locales["en"]["createEdgeError"]);
                    } else {
                      if (this.body.nodes[connectFromId] !== void 0 && this.body.nodes[node.id] !== void 0) {
                        this._performAddEdge(connectFromId, node.id);
                      }
                    }
                  }
                  this.body.emitter.emit("_redraw");
                }
                /**
                 *
                 * @param {Event} event
                 * @private
                 */
              }, {
                key: "_dragStartEdge",
                value: function _dragStartEdge(event) {
                  var pointer = this.lastTouch;
                  this.selectionHandler._generateClickEvent("dragStart", event, pointer, void 0, true);
                }
                // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
                // ------------------------------ Performing all the actual data manipulation ------------------------//
                /**
                 * Adds a node on the specified location
                 *
                 * @param {Object} clickData
                 * @private
                 */
              }, {
                key: "_performAddNode",
                value: function _performAddNode(clickData) {
                  var _this4 = this;
                  var defaultData = {
                    id: util.randomUUID(),
                    x: clickData.pointer.canvas.x,
                    y: clickData.pointer.canvas.y,
                    label: "new"
                  };
                  if (typeof this.options.addNode === "function") {
                    if (this.options.addNode.length === 2) {
                      this.options.addNode(defaultData, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this4.inMode === "addNode") {
                          _this4.body.data.nodes.getDataSet().add(finalizedData);
                          _this4.showManipulatorToolbar();
                        }
                      });
                    } else {
                      this.showManipulatorToolbar();
                      throw new Error("The function for add does not support two arguments (data,callback)");
                    }
                  } else {
                    this.body.data.nodes.getDataSet().add(defaultData);
                    this.showManipulatorToolbar();
                  }
                }
                /**
                 * connect two nodes with a new edge.
                 *
                 * @param {Node.id} sourceNodeId
                 * @param {Node.id} targetNodeId
                 * @private
                 */
              }, {
                key: "_performAddEdge",
                value: function _performAddEdge(sourceNodeId, targetNodeId) {
                  var _this5 = this;
                  var defaultData = { from: sourceNodeId, to: targetNodeId };
                  if (typeof this.options.addEdge === "function") {
                    if (this.options.addEdge.length === 2) {
                      this.options.addEdge(defaultData, function(finalizedData) {
                        if (finalizedData !== null && finalizedData !== void 0 && _this5.inMode === "addEdge") {
                          _this5.body.data.edges.getDataSet().add(finalizedData);
                          _this5.selectionHandler.unselectAll();
                          _this5.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for connect does not support two arguments (data,callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().add(defaultData);
                    this.selectionHandler.unselectAll();
                    this.showManipulatorToolbar();
                  }
                }
                /**
                 * connect two nodes with a new edge.
                 *
                 * @param {Node.id} sourceNodeId
                 * @param {Node.id} targetNodeId
                 * @private
                 */
              }, {
                key: "_performEditEdge",
                value: function _performEditEdge(sourceNodeId, targetNodeId) {
                  var _this6 = this;
                  var defaultData = { id: this.edgeBeingEditedId, from: sourceNodeId, to: targetNodeId, label: this.body.data.edges._data[this.edgeBeingEditedId].label };
                  var eeFunct = this.options.editEdge;
                  if ((typeof eeFunct === "undefined" ? "undefined" : (0, _typeof3["default"])(eeFunct)) === "object") {
                    eeFunct = eeFunct.editWithoutDrag;
                  }
                  if (typeof eeFunct === "function") {
                    if (eeFunct.length === 2) {
                      eeFunct(defaultData, function(finalizedData) {
                        if (finalizedData === null || finalizedData === void 0 || _this6.inMode !== "editEdge") {
                          _this6.body.edges[defaultData.id].updateEdgeType();
                          _this6.body.emitter.emit("_redraw");
                          _this6.showManipulatorToolbar();
                        } else {
                          _this6.body.data.edges.getDataSet().update(finalizedData);
                          _this6.selectionHandler.unselectAll();
                          _this6.showManipulatorToolbar();
                        }
                      });
                    } else {
                      throw new Error("The function for edit does not support two arguments (data, callback)");
                    }
                  } else {
                    this.body.data.edges.getDataSet().update(defaultData);
                    this.selectionHandler.unselectAll();
                    this.showManipulatorToolbar();
                  }
                }
              }]);
              return ManipulationSystem2;
            }();
            exports2["default"] = ManipulationSystem;
          },
          /* 238 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _slicedToArray2 = __webpack_require__(30);
            var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            var _FloydWarshall = __webpack_require__(239);
            var _FloydWarshall2 = _interopRequireDefault(_FloydWarshall);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var KamadaKawai = function() {
              function KamadaKawai2(body, edgeLength, edgeStrength) {
                (0, _classCallCheck3["default"])(this, KamadaKawai2);
                this.body = body;
                this.springLength = edgeLength;
                this.springConstant = edgeStrength;
                this.distanceSolver = new _FloydWarshall2["default"]();
              }
              (0, _createClass3["default"])(KamadaKawai2, [{
                key: "setOptions",
                value: function setOptions(options) {
                  if (options) {
                    if (options.springLength) {
                      this.springLength = options.springLength;
                    }
                    if (options.springConstant) {
                      this.springConstant = options.springConstant;
                    }
                  }
                }
                /**
                 * Position the system
                 * @param {Array.<Node>} nodesArray
                 * @param {Array.<vis.Edge>} edgesArray
                 * @param {boolean} [ignoreClusters=false]
                 */
              }, {
                key: "solve",
                value: function solve(nodesArray, edgesArray) {
                  var ignoreClusters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray);
                  this._createL_matrix(D_matrix);
                  this._createK_matrix(D_matrix);
                  this._createE_matrix();
                  var threshold = 0.01;
                  var innerThreshold = 1;
                  var iterations = 0;
                  var maxIterations = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));
                  var maxInnerIterations = 5;
                  var maxEnergy = 1e9;
                  var highE_nodeId = 0, dE_dx = 0, dE_dy = 0, delta_m = 0, subIterations = 0;
                  while (maxEnergy > threshold && iterations < maxIterations) {
                    iterations += 1;
                    var _getHighestEnergyNode2 = this._getHighestEnergyNode(ignoreClusters);
                    var _getHighestEnergyNode3 = (0, _slicedToArray3["default"])(_getHighestEnergyNode2, 4);
                    highE_nodeId = _getHighestEnergyNode3[0];
                    maxEnergy = _getHighestEnergyNode3[1];
                    dE_dx = _getHighestEnergyNode3[2];
                    dE_dy = _getHighestEnergyNode3[3];
                    delta_m = maxEnergy;
                    subIterations = 0;
                    while (delta_m > innerThreshold && subIterations < maxInnerIterations) {
                      subIterations += 1;
                      this._moveNode(highE_nodeId, dE_dx, dE_dy);
                      var _getEnergy2 = this._getEnergy(highE_nodeId);
                      var _getEnergy3 = (0, _slicedToArray3["default"])(_getEnergy2, 3);
                      delta_m = _getEnergy3[0];
                      dE_dx = _getEnergy3[1];
                      dE_dy = _getEnergy3[2];
                    }
                  }
                }
                /**
                 * get the node with the highest energy
                 * @param {boolean} ignoreClusters
                 * @returns {number[]}
                 * @private
                 */
              }, {
                key: "_getHighestEnergyNode",
                value: function _getHighestEnergyNode(ignoreClusters) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes = this.body.nodes;
                  var maxEnergy = 0;
                  var maxEnergyNodeId = nodesArray[0];
                  var dE_dx_max = 0, dE_dy_max = 0;
                  for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {
                    var m = nodesArray[nodeIdx];
                    if (nodes[m].predefinedPosition === false || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x === true || nodes[m].options.fixed.y === true) {
                      var _getEnergy4 = this._getEnergy(m), _getEnergy5 = (0, _slicedToArray3["default"])(_getEnergy4, 3), delta_m = _getEnergy5[0], dE_dx = _getEnergy5[1], dE_dy = _getEnergy5[2];
                      if (maxEnergy < delta_m) {
                        maxEnergy = delta_m;
                        maxEnergyNodeId = m;
                        dE_dx_max = dE_dx;
                        dE_dy_max = dE_dy;
                      }
                    }
                  }
                  return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];
                }
                /**
                 * calculate the energy of a single node
                 * @param {Node.id} m
                 * @returns {number[]}
                 * @private
                 */
              }, {
                key: "_getEnergy",
                value: function _getEnergy(m) {
                  var _E_sums$m = (0, _slicedToArray3["default"])(this.E_sums[m], 2), dE_dx = _E_sums$m[0], dE_dy = _E_sums$m[1];
                  var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));
                  return [delta_m, dE_dx, dE_dy];
                }
                /**
                 * move the node based on it's energy
                 * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
                 * @param {number} m
                 * @param {number} dE_dx
                 * @param {number} dE_dy
                 * @private
                 */
              }, {
                key: "_moveNode",
                value: function _moveNode(m, dE_dx, dE_dy) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes = this.body.nodes;
                  var d2E_dx2 = 0;
                  var d2E_dxdy = 0;
                  var d2E_dy2 = 0;
                  var x_m = nodes[m].x;
                  var y_m = nodes[m].y;
                  var km = this.K_matrix[m];
                  var lm = this.L_matrix[m];
                  for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
                    var i = nodesArray[iIdx];
                    if (i !== m) {
                      var x_i = nodes[i].x;
                      var y_i = nodes[i].y;
                      var kmat = km[i];
                      var lmat = lm[i];
                      var denominator = 1 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);
                      d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);
                      d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);
                      d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);
                    }
                  }
                  var A = d2E_dx2, B = d2E_dxdy, C = dE_dx, D = d2E_dy2, E = dE_dy;
                  var dy = (C / A + E / B) / (B / A - D / B);
                  var dx = -(B * dy + C) / A;
                  nodes[m].x += dx;
                  nodes[m].y += dy;
                  this._updateE_matrix(m);
                }
                /**
                 * Create the L matrix: edge length times shortest path
                 * @param {Object} D_matrix
                 * @private
                 */
              }, {
                key: "_createL_matrix",
                value: function _createL_matrix(D_matrix) {
                  var nodesArray = this.body.nodeIndices;
                  var edgeLength = this.springLength;
                  this.L_matrix = [];
                  for (var i = 0; i < nodesArray.length; i++) {
                    this.L_matrix[nodesArray[i]] = {};
                    for (var j = 0; j < nodesArray.length; j++) {
                      this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];
                    }
                  }
                }
                /**
                 * Create the K matrix: spring constants times shortest path
                 * @param {Object} D_matrix
                 * @private
                 */
              }, {
                key: "_createK_matrix",
                value: function _createK_matrix(D_matrix) {
                  var nodesArray = this.body.nodeIndices;
                  var edgeStrength = this.springConstant;
                  this.K_matrix = [];
                  for (var i = 0; i < nodesArray.length; i++) {
                    this.K_matrix[nodesArray[i]] = {};
                    for (var j = 0; j < nodesArray.length; j++) {
                      this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);
                    }
                  }
                }
                /**
                 *  Create matrix with all energies between nodes
                 *  @private
                 */
              }, {
                key: "_createE_matrix",
                value: function _createE_matrix() {
                  var nodesArray = this.body.nodeIndices;
                  var nodes = this.body.nodes;
                  this.E_matrix = {};
                  this.E_sums = {};
                  for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {
                    this.E_matrix[nodesArray[mIdx]] = [];
                  }
                  for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {
                    var m = nodesArray[_mIdx];
                    var x_m = nodes[m].x;
                    var y_m = nodes[m].y;
                    var dE_dx = 0;
                    var dE_dy = 0;
                    for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {
                      var i = nodesArray[iIdx];
                      if (i !== m) {
                        var x_i = nodes[i].x;
                        var y_i = nodes[i].y;
                        var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
                        this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];
                        this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];
                        dE_dx += this.E_matrix[m][iIdx][0];
                        dE_dy += this.E_matrix[m][iIdx][1];
                      }
                    }
                    this.E_sums[m] = [dE_dx, dE_dy];
                  }
                }
                /**
                 * Update method, just doing single column (rows are auto-updated) (update all sums)
                 *
                 * @param {number} m
                 * @private
                 */
              }, {
                key: "_updateE_matrix",
                value: function _updateE_matrix(m) {
                  var nodesArray = this.body.nodeIndices;
                  var nodes = this.body.nodes;
                  var colm = this.E_matrix[m];
                  var kcolm = this.K_matrix[m];
                  var lcolm = this.L_matrix[m];
                  var x_m = nodes[m].x;
                  var y_m = nodes[m].y;
                  var dE_dx = 0;
                  var dE_dy = 0;
                  for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {
                    var i = nodesArray[iIdx];
                    if (i !== m) {
                      var cell = colm[iIdx];
                      var oldDx = cell[0];
                      var oldDy = cell[1];
                      var x_i = nodes[i].x;
                      var y_i = nodes[i].y;
                      var denominator = 1 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));
                      var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);
                      var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);
                      colm[iIdx] = [dx, dy];
                      dE_dx += dx;
                      dE_dy += dy;
                      var sum = this.E_sums[i];
                      sum[0] += dx - oldDx;
                      sum[1] += dy - oldDy;
                    }
                  }
                  this.E_sums[m] = [dE_dx, dE_dy];
                }
              }]);
              return KamadaKawai2;
            }();
            exports2["default"] = KamadaKawai;
          },
          /* 239 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _classCallCheck2 = __webpack_require__(0);
            var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
            var _createClass2 = __webpack_require__(1);
            var _createClass3 = _interopRequireDefault(_createClass2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { "default": obj };
            }
            var FloydWarshall = function() {
              function FloydWarshall2() {
                (0, _classCallCheck3["default"])(this, FloydWarshall2);
              }
              (0, _createClass3["default"])(FloydWarshall2, [{
                key: "getDistances",
                value: function getDistances(body, nodesArray, edgesArray) {
                  var D_matrix = {};
                  var edges = body.edges;
                  for (var i = 0; i < nodesArray.length; i++) {
                    var node = nodesArray[i];
                    var cell = {};
                    D_matrix[node] = cell;
                    for (var j = 0; j < nodesArray.length; j++) {
                      cell[nodesArray[j]] = i == j ? 0 : 1e9;
                    }
                  }
                  for (var _i = 0; _i < edgesArray.length; _i++) {
                    var edge = edges[edgesArray[_i]];
                    if (edge.connected === true && D_matrix[edge.fromId] !== void 0 && D_matrix[edge.toId] !== void 0) {
                      D_matrix[edge.fromId][edge.toId] = 1;
                      D_matrix[edge.toId][edge.fromId] = 1;
                    }
                  }
                  var nodeCount = nodesArray.length;
                  for (var k = 0; k < nodeCount; k++) {
                    var knode = nodesArray[k];
                    var kcolm = D_matrix[knode];
                    for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {
                      var inode = nodesArray[_i2];
                      var icolm = D_matrix[inode];
                      for (var _j = _i2 + 1; _j < nodeCount; _j++) {
                        var jnode = nodesArray[_j];
                        var jcolm = D_matrix[jnode];
                        var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);
                        icolm[jnode] = val;
                        jcolm[inode] = val;
                      }
                    }
                  }
                  return D_matrix;
                }
              }]);
              return FloydWarshall2;
            }();
            exports2["default"] = FloydWarshall;
          }
          /******/
        ])
      );
    });
  }
});
export default require_vis();
/*! Bundled license information:

vis/dist/vis.js:
  (**
   * vis.js
   * https://github.com/almende/vis
   *
   * A dynamic, browser-based visualization library.
   *
   * @version 4.21.0
   * @date    2017-10-12
   *
   * @license
   * Copyright (C) 2011-2017 Almende B.V, http://almende.com
   *
   * Vis.js is dual licensed under both
   *
   * * The Apache 2.0 License
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * and
   *
   * * The MIT License
   *   http://opensource.org/licenses/MIT
   *
   * Vis.js may be distributed under either license.
   *)
  (*! moment.js *)
  (*! version : 2.19.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
  (*! Hammer.JS - v2.0.7 - 2016-04-22
  * http://hammerjs.github.io/
  *
  * Copyright (c) 2016 Jorik Tangelder;
  * Licensed under the MIT license *)
*/
//# sourceMappingURL=vis.js.map
